
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>extend-challenge-service: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">extend-challenge-service/main.go (0.0%)</option>
				
				<option value="file1">extend-challenge-service/pkg/cache/serialized_challenge_cache.go (0.0%)</option>
				
				<option value="file2">extend-challenge-service/pkg/client/ags_reward_client.go (73.2%)</option>
				
				<option value="file3">extend-challenge-service/pkg/client/noop_reward_client.go (0.0%)</option>
				
				<option value="file4">extend-challenge-service/pkg/common/authServerInterceptor.go (0.0%)</option>
				
				<option value="file5">extend-challenge-service/pkg/common/buffer_pool.go (100.0%)</option>
				
				<option value="file6">extend-challenge-service/pkg/common/gateway.go (0.0%)</option>
				
				<option value="file7">extend-challenge-service/pkg/common/logging.go (0.0%)</option>
				
				<option value="file8">extend-challenge-service/pkg/common/sonic_marshaler.go (0.0%)</option>
				
				<option value="file9">extend-challenge-service/pkg/common/tracerProvider.go (0.0%)</option>
				
				<option value="file10">extend-challenge-service/pkg/common/utils.go (0.0%)</option>
				
				<option value="file11">extend-challenge-service/pkg/handler/optimized_challenges_handler.go (0.0%)</option>
				
				<option value="file12">extend-challenge-service/pkg/mapper/challenge_mapper.go (80.4%)</option>
				
				<option value="file13">extend-challenge-service/pkg/mapper/error_mapper.go (100.0%)</option>
				
				<option value="file14">extend-challenge-service/pkg/migrations/runner.go (0.0%)</option>
				
				<option value="file15">extend-challenge-service/pkg/pb/google/api/annotations.pb.go (0.0%)</option>
				
				<option value="file16">extend-challenge-service/pkg/pb/google/api/http.pb.go (0.0%)</option>
				
				<option value="file17">extend-challenge-service/pkg/pb/permission.pb.go (0.0%)</option>
				
				<option value="file18">extend-challenge-service/pkg/pb/protoc-gen-openapiv2/options/annotations.pb.go (0.0%)</option>
				
				<option value="file19">extend-challenge-service/pkg/pb/protoc-gen-openapiv2/options/openapiv2.pb.go (0.0%)</option>
				
				<option value="file20">extend-challenge-service/pkg/pb/service.pb.go (0.0%)</option>
				
				<option value="file21">extend-challenge-service/pkg/pb/service.pb.gw.go (0.0%)</option>
				
				<option value="file22">extend-challenge-service/pkg/pb/service_grpc.pb.go (0.0%)</option>
				
				<option value="file23">extend-challenge-service/pkg/response/builder.go (0.0%)</option>
				
				<option value="file24">extend-challenge-service/pkg/response/json_injector.go (89.7%)</option>
				
				<option value="file25">extend-challenge-service/pkg/service/claim.go (91.5%)</option>
				
				<option value="file26">extend-challenge-service/pkg/service/prerequisite_checker.go (100.0%)</option>
				
				<option value="file27">extend-challenge-service/pkg/service/progress_query.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) 2023-2025 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.

package main

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "log"
        "log/slog"
        "net"
        "net/http"
        "net/http/pprof"
        "os"
        "os/signal"
        "path/filepath"
        "strings"
        "syscall"
        "time"

        "github.com/go-openapi/loads"

        "extend-challenge-service/pkg/cache"
        "extend-challenge-service/pkg/client"
        "extend-challenge-service/pkg/common"
        "extend-challenge-service/pkg/handler"
        "extend-challenge-service/pkg/mapper"
        "extend-challenge-service/pkg/migrations"
        pb "extend-challenge-service/pkg/pb"
        "extend-challenge-service/pkg/server"

        commonCache "github.com/AccelByte/extend-challenge-common/pkg/cache"
        commonClient "github.com/AccelByte/extend-challenge-common/pkg/client"
        commonConfig "github.com/AccelByte/extend-challenge-common/pkg/config"
        commonDB "github.com/AccelByte/extend-challenge-common/pkg/db"
        commonRepo "github.com/AccelByte/extend-challenge-common/pkg/repository"

        "github.com/AccelByte/accelbyte-go-sdk/services-api/pkg/factory"
        "github.com/AccelByte/accelbyte-go-sdk/services-api/pkg/repository"
        "github.com/AccelByte/accelbyte-go-sdk/services-api/pkg/service/iam"
        "github.com/AccelByte/accelbyte-go-sdk/services-api/pkg/service/platform"
        "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "github.com/sirupsen/logrus"
        "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
        "go.opentelemetry.io/contrib/propagators/b3"
        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/trace"
        "google.golang.org/grpc"
        "google.golang.org/grpc/health"
        "google.golang.org/grpc/health/grpc_health_v1"
        "google.golang.org/grpc/reflection"

        sdkAuth "github.com/AccelByte/accelbyte-go-sdk/services-api/pkg/utils/auth"
        prometheusGrpc "github.com/grpc-ecosystem/go-grpc-prometheus"
        prometheusCollectors "github.com/prometheus/client_golang/prometheus/collectors"
)

const (
        metricsEndpoint     = "/metrics"
        metricsPort         = 8080
        grpcServerPort      = 6565
        grpcGatewayHTTPPort = 8000
)

var (
        serviceName = common.GetEnv("OTEL_SERVICE_NAME", "ExtendCustomServiceGo")
        logLevelStr = common.GetEnv("LOG_LEVEL", logrus.InfoLevel.String())
        basePath    = common.GetBasePath()
)

func main() <span class="cov0" title="0">{
        logrus.Infof("Starting %s...", serviceName)

        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        logrusLevel, err := logrus.ParseLevel(logLevelStr)
        if err != nil </span><span class="cov0" title="0">{
                logrusLevel = logrus.InfoLevel
        }</span>
        <span class="cov0" title="0">logrusLogger := logrus.New()
        logrusLogger.SetLevel(logrusLevel)

        loggingOptions := []logging.Option{
                logging.WithLogOnEvents(logging.StartCall, logging.FinishCall, logging.PayloadReceived, logging.PayloadSent),
                logging.WithFieldsFromContext(func(ctx context.Context) logging.Fields </span><span class="cov0" title="0">{
                        if span := trace.SpanContextFromContext(ctx); span.IsSampled() </span><span class="cov0" title="0">{
                                return logging.Fields{"traceID", span.TraceID().String()}
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                }),
                logging.WithLevels(logging.DefaultClientCodeToLevel),
                logging.WithDurationField(logging.DurationToDurationField),
        }

        <span class="cov0" title="0">unaryServerInterceptors := []grpc.UnaryServerInterceptor{
                prometheusGrpc.UnaryServerInterceptor,
                logging.UnaryServerInterceptor(common.InterceptorLogger(logrusLogger), loggingOptions...),
        }
        streamServerInterceptors := []grpc.StreamServerInterceptor{
                prometheusGrpc.StreamServerInterceptor,
                logging.StreamServerInterceptor(common.InterceptorLogger(logrusLogger), loggingOptions...),
        }

        // Preparing the IAM authorization
        var tokenRepo repository.TokenRepository = sdkAuth.DefaultTokenRepositoryImpl()
        var configRepo repository.ConfigRepository = sdkAuth.DefaultConfigRepositoryImpl()
        var refreshRepo repository.RefreshTokenRepository = &amp;sdkAuth.RefreshTokenImpl{RefreshRate: 0.8, AutoRefresh: true}

        oauthService := iam.OAuth20Service{
                Client:                 factory.NewIamClient(configRepo),
                TokenRepository:        tokenRepo,
                RefreshTokenRepository: refreshRepo,
                ConfigRepository:       configRepo,
        }

        // Always register auth interceptor (it handles both enabled and disabled auth modes)
        permissionExtractor := common.NewProtoPermissionExtractor()
        unaryServerInterceptor := common.NewUnaryAuthServerIntercept(permissionExtractor)
        serverServerInterceptor := common.NewStreamAuthServerIntercept(permissionExtractor)

        unaryServerInterceptors = append(unaryServerInterceptors, unaryServerInterceptor)
        streamServerInterceptors = append(streamServerInterceptors, serverServerInterceptor)

        if strings.ToLower(common.GetEnv("PLUGIN_GRPC_SERVER_AUTH_ENABLED", "true")) == "true" </span><span class="cov0" title="0">{
                refreshInterval := common.GetEnvInt("REFRESH_INTERVAL", 600)
                common.Validator = common.NewTokenValidator(oauthService, time.Duration(refreshInterval)*time.Second, true)
                err := common.Validator.Initialize(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Infof("%s", err.Error())
                }</span>
                <span class="cov0" title="0">logrus.Infof("JWT authentication enabled with token validator")</span>
        } else<span class="cov0" title="0"> {
                logrus.Infof("JWT authentication disabled - using test user for local development")
        }</span>

        // Create gRPC Server
        <span class="cov0" title="0">s := grpc.NewServer(
                grpc.StatsHandler(otelgrpc.NewServerHandler()),
                grpc.ChainUnaryInterceptor(unaryServerInterceptors...),
                grpc.ChainStreamInterceptor(streamServerInterceptors...),
        )

        // Get namespace from environment
        namespace := common.GetEnv("AB_NAMESPACE", "accelbyte")
        logrus.Infof("Using namespace: %s", namespace)

        // Check if OAuth login is required (only for real mode or when auth is enabled)
        rewardMode := common.GetEnv("REWARD_CLIENT_MODE", "real")
        authEnabled := strings.ToLower(common.GetEnv("PLUGIN_GRPC_SERVER_AUTH_ENABLED", "true")) == "true"

        if rewardMode == "real" || authEnabled </span><span class="cov0" title="0">{
                // Configure IAM authorization
                clientId := configRepo.GetClientId()
                clientSecret := configRepo.GetClientSecret()
                err = oauthService.LoginClient(&amp;clientId, &amp;clientSecret)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Fatalf("Error unable to login using clientId and clientSecret: %v", err)
                }</span>
                <span class="cov0" title="0">logrus.Infof("Successfully logged in to AGS IAM")</span>
        } else<span class="cov0" title="0"> {
                logrus.Infof("Skipping AGS OAuth login (mock mode with auth disabled)")
        }</span>

        // Initialize database connection (Decision Q10: shared database package)
        <span class="cov0" title="0">dbConfig := commonDB.NewConfigFromEnv()
        db, err := commonDB.Connect(dbConfig)
        if err != nil </span><span class="cov0" title="0">{
                logrus.Fatalf("Failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := db.Close(); err != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("Failed to close database connection: %v", err)
                }</span>
        }()
        <span class="cov0" title="0">logrus.Infof("Database connected successfully")

        // Run database migrations automatically on startup
        migrationsPath := common.GetEnv("MIGRATIONS_PATH", "file:///app/migrations")
        logrus.Infof("Running database migrations from: %s", migrationsPath)
        if err := migrations.RunMigrations(db, migrationsPath); err != nil </span><span class="cov0" title="0">{
                logrus.Errorf("Failed to run database migrations: %v", err)
                logrus.Fatalf("Service cannot start without successful migrations")
        }</span>
        <span class="cov0" title="0">logrus.Infof("Database migrations completed successfully")

        // Load challenge configuration from challenges.json
        configPath := common.GetEnv("CHALLENGE_CONFIG_PATH", "config/challenges.json")
        slogLogger := slog.New(slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{Level: slog.LevelInfo}))
        configLoader := commonConfig.NewConfigLoader(configPath, slogLogger)
        challengeConfig, err := configLoader.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                logrus.Fatalf("Failed to load challenge config: %v", err)
        }</span>
        <span class="cov0" title="0">logrus.Infof("Loaded %d challenges from config", len(challengeConfig.Challenges))

        // Initialize GoalCache with in-memory implementation
        goalCache := commonCache.NewInMemoryGoalCache(challengeConfig, configPath, slogLogger)
        logrus.Infof("GoalCache initialized with %d challenges", len(challengeConfig.Challenges))

        // Initialize pre-serialization cache for optimized challenge responses (Optimization 2)
        // This cache stores pre-marshaled JSON for static challenge data, reducing CPU by ~40%
        serializedCache := cache.NewSerializedChallengeCache()

        // Convert domain challenges to protobuf format for cache warm-up
        pbChallenges := make([]*pb.Challenge, 0, len(challengeConfig.Challenges))
        for _, domainChallenge := range goalCache.GetAllChallenges() </span><span class="cov0" title="0">{
                // Convert without user progress (progress will be injected at request time)
                pbChallenge, err := mapper.ChallengeToProto(domainChallenge, nil)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Warnf("Failed to convert challenge %s for serialization cache: %v", domainChallenge.ID, err)
                        continue</span>
                }
                <span class="cov0" title="0">pbChallenges = append(pbChallenges, pbChallenge)</span>
        }

        // Warm up the serialization cache with pre-marshaled challenge JSON
        <span class="cov0" title="0">if err := serializedCache.WarmUp(pbChallenges); err != nil </span><span class="cov0" title="0">{
                logrus.Fatalf("Failed to warm up serialization cache: %v", err)
        }</span>

        <span class="cov0" title="0">challengeCount, goalCount, totalBytes := serializedCache.GetStats()
        logrus.Infof("Serialization cache warmed up: %d challenges, %d goals, %d bytes cached", challengeCount, goalCount, totalBytes)

        // Initialize GoalRepository with PostgreSQL implementation
        goalRepo := commonRepo.NewPostgresGoalRepository(db)
        logrus.Infof("GoalRepository initialized")

        // Initialize Platform SDK services for reward granting (Phase 7)
        platformClient := factory.NewPlatformClient(configRepo)
        entitlementService := &amp;platform.EntitlementService{
                Client:           platformClient,
                TokenRepository:  tokenRepo,
                ConfigRepository: configRepo,
        }
        walletService := &amp;platform.WalletService{
                Client:           platformClient,
                TokenRepository:  tokenRepo,
                ConfigRepository: configRepo,
        }
        logrus.Infof("Platform SDK services initialized (EntitlementService, WalletService)")

        // Create RewardClient based on REWARD_CLIENT_MODE environment variable (already read above)
        var rewardClient commonClient.RewardClient

        switch rewardMode </span>{
        case "mock":<span class="cov0" title="0">
                rewardClient = commonClient.NewDevMockRewardClient()
                logrus.Warnf("Using DevMockRewardClient (for local development only - rewards will be logged but not granted)")</span>
        case "real":<span class="cov0" title="0">
                rewardClient = client.NewAGSRewardClient(entitlementService, walletService, logrusLogger)
                logrus.Infof("AGSRewardClient initialized")</span>
        default:<span class="cov0" title="0">
                logrus.Fatalf("Invalid REWARD_CLIENT_MODE: %s (must be 'mock' or 'real')", rewardMode)</span>
        }

        // Create ChallengeServiceServer with all dependencies
        <span class="cov0" title="0">challengeServiceServer := server.NewChallengeServiceServer(
                goalCache,
                goalRepo,
                rewardClient,
                db,
                namespace,
        )

        // Register Challenge Service with gRPC server
        pb.RegisterServiceServer(s, challengeServiceServer)
        logrus.Infof("ChallengeService registered with gRPC server")

        // Enable gRPC Reflection
        reflection.Register(s)

        // Enable gRPC Health Check
        grpc_health_v1.RegisterHealthServer(s, health.NewServer())

        // Create a new HTTP server for the gRPC-Gateway
        grpcGateway, err := common.NewGateway(ctx, fmt.Sprintf("localhost:%d", grpcServerPort), basePath)
        if err != nil </span><span class="cov0" title="0">{
                logrus.Fatalf("Failed to create gRPC-Gateway: %v", err)
        }</span>

        // Start the gRPC-Gateway HTTP server with optimized challenge handler
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                swaggerDir := "gateway/apidocs" // Path to swagger directory

                // Create optimized challenges handler (uses pre-serialized cache for 40% CPU reduction)
                optimizedHandler := handler.NewOptimizedChallengesHandler(
                        goalCache,
                        goalRepo,
                        serializedCache,
                        namespace,
                        authEnabled,
                        common.Validator, // Token validator (may be nil if auth disabled)
                )

                grpcGatewayHTTPServer := newGRPCGatewayHTTPServer(
                        fmt.Sprintf(":%d", grpcGatewayHTTPPort),
                        grpcGateway,
                        logrus.New(),
                        swaggerDir,
                        optimizedHandler, // Pass optimized handler
                        basePath,
                )
                logrus.Infof("Starting gRPC-Gateway HTTP server on port %d (with optimized /v1/challenges endpoint)", grpcGatewayHTTPPort)
                if err := grpcGatewayHTTPServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        logrus.Fatalf("Failed to run gRPC-Gateway HTTP server: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">prometheusGrpc.Register(s)

        // Register Prometheus Metrics
        prometheusRegistry := prometheus.NewRegistry()
        prometheusRegistry.MustRegister(
                prometheusCollectors.NewGoCollector(),
                prometheusCollectors.NewProcessCollector(prometheusCollectors.ProcessCollectorOpts{}),
                prometheusGrpc.DefaultServerMetrics,
        )

        go func() </span><span class="cov0" title="0">{
                mux := http.NewServeMux()
                mux.Handle(metricsEndpoint, promhttp.HandlerFor(prometheusRegistry, promhttp.HandlerOpts{}))

                // Register pprof handlers
                mux.HandleFunc("/debug/pprof/", pprof.Index)
                mux.HandleFunc("/debug/pprof/cmdline", pprof.Cmdline)
                mux.HandleFunc("/debug/pprof/profile", pprof.Profile)
                mux.HandleFunc("/debug/pprof/symbol", pprof.Symbol)
                mux.HandleFunc("/debug/pprof/trace", pprof.Trace)

                metricsServer := &amp;http.Server{
                        Addr:              fmt.Sprintf(":%d", metricsPort),
                        Handler:           mux,
                        ReadHeaderTimeout: 10 * time.Second,
                        ReadTimeout:       30 * time.Second,
                        WriteTimeout:      30 * time.Second,
                }
                if err := metricsServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        logrus.Fatalf("Failed to run metrics server: %v", err)
                }</span>
        }()
        <span class="cov0" title="0">logrus.Infof("Metrics endpoint: (:%d%s)", metricsPort, metricsEndpoint)
        logrus.Infof("Pprof endpoints: (:%d/debug/pprof/*)", metricsPort)

        // Set Tracer Provider
        tracerProvider, err := common.NewTracerProvider(serviceName)
        if err != nil </span><span class="cov0" title="0">{
                logrus.Fatalf("Failed to create tracer provider: %v", err)

                return
        }</span>
        <span class="cov0" title="0">otel.SetTracerProvider(tracerProvider)
        defer func(ctx context.Context) </span><span class="cov0" title="0">{
                if err := tracerProvider.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        logrus.Fatal(err)
                }</span>
        }(ctx)

        // Set Text Map Propagator
        <span class="cov0" title="0">otel.SetTextMapPropagator(
                propagation.NewCompositeTextMapPropagator(
                        b3.New(),
                        propagation.TraceContext{},
                        propagation.Baggage{},
                ),
        )

        // Start gRPC Server
        lis, err := net.Listen("tcp", fmt.Sprintf(":%d", grpcServerPort))
        if err != nil </span><span class="cov0" title="0">{
                logrus.Fatalf("Failed to listen to tcp:%d: %v", grpcServerPort, err)

                return
        }</span>
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if err = s.Serve(lis); err != nil </span><span class="cov0" title="0">{
                        logrus.Fatalf("Failed to run gRPC server: %v", err)

                        return
                }</span>
        }()

        <span class="cov0" title="0">logrus.Infof("%s started", serviceName)

        ctx, stop := signal.NotifyContext(ctx, os.Interrupt, syscall.SIGTERM)
        defer stop()
        &lt;-ctx.Done()
        logrus.Infof("SIGTERM received")</span>
}

func newGRPCGatewayHTTPServer(
        addr string,
        grpcGatewayHandler http.Handler,
        logger *logrus.Logger,
        swaggerDir string,
        optimizedChallengesHandler *handler.OptimizedChallengesHandler,
        basePath string,
) *http.Server <span class="cov0" title="0">{
        // Create a new ServeMux
        mux := http.NewServeMux()

        // Register optimized challenges endpoint BEFORE the catch-all gRPC-Gateway handler
        // This endpoint uses pre-serialized challenge data for ~40% CPU reduction
        // Path must match the protobuf definition: GET /v1/challenges
        optimizedPath := basePath + "/v1/challenges"
        mux.Handle(optimizedPath, optimizedChallengesHandler)
        logger.Infof("Registered optimized handler for %s (pre-serialization enabled)", optimizedPath)

        // Add the gRPC-Gateway handler as catch-all (must be last)
        // This handles all other endpoints including /v1/challenges/{id}/goals/{id}/claim
        mux.Handle("/", grpcGatewayHandler)

        // Serve Swagger UI and JSON
        serveSwaggerUI(mux)
        serveSwaggerJSON(mux, swaggerDir)

        // Add logging middleware
        loggedMux := loggingMiddleware(logger, mux)

        return &amp;http.Server{
                Addr:              addr,
                Handler:           loggedMux,
                ReadHeaderTimeout: 10 * time.Second,
                ReadTimeout:       30 * time.Second,
                WriteTimeout:      30 * time.Second,
                ErrorLog:          log.New(os.Stderr, "httpSrv: ", log.LstdFlags), // Configure the logger for the HTTP server
        }
}</span>

// loggingMiddleware is a middleware that logs HTTP requests
func loggingMiddleware(logger *logrus.Logger, next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()
                next.ServeHTTP(w, r)
                duration := time.Since(start)
                logger.WithFields(logrus.Fields{
                        "method":   r.Method,
                        "path":     r.URL.Path,
                        "duration": duration,
                }).Info("HTTP request")
        }</span>)
}

func serveSwaggerUI(mux *http.ServeMux) <span class="cov0" title="0">{
        swaggerUIDir := "third_party/swagger-ui"
        fileServer := http.FileServer(http.Dir(swaggerUIDir))
        swaggerUiPath := fmt.Sprintf("%s/apidocs/", basePath)
        mux.Handle(swaggerUiPath, http.StripPrefix(swaggerUiPath, fileServer))
}</span>

func serveSwaggerJSON(mux *http.ServeMux, swaggerDir string) <span class="cov0" title="0">{
        fileHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                matchingFiles, err := filepath.Glob(filepath.Join(swaggerDir, "*.swagger.json"))
                if err != nil || len(matchingFiles) == 0 </span><span class="cov0" title="0">{
                        http.Error(w, "Error finding Swagger JSON file", http.StatusInternalServerError)

                        return
                }</span>

                <span class="cov0" title="0">firstMatchingFile := matchingFiles[0]
                swagger, err := loads.Spec(firstMatchingFile)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Error parsing Swagger JSON file", http.StatusInternalServerError)

                        return
                }</span>

                // Update the base path
                <span class="cov0" title="0">swagger.Spec().BasePath = basePath

                updatedSwagger, err := swagger.Spec().MarshalJSON()
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Error serializing updated Swagger JSON", http.StatusInternalServerError)

                        return
                }</span>
                <span class="cov0" title="0">var prettySwagger bytes.Buffer
                err = json.Indent(&amp;prettySwagger, updatedSwagger, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Error formatting updated Swagger JSON", http.StatusInternalServerError)

                        return
                }</span>

                <span class="cov0" title="0">_, err = w.Write(prettySwagger.Bytes())
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Error writing Swagger JSON response", http.StatusInternalServerError)

                        return
                }</span>
        })
        <span class="cov0" title="0">apidocsPath := fmt.Sprintf("%s/apidocs/api.json", basePath)
        mux.Handle(apidocsPath, fileHandler)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) 2023-2025 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.

package cache

import (
        "encoding/json"
        "fmt"
        "sync"

        "google.golang.org/protobuf/encoding/protojson"

        pb "extend-challenge-service/pkg/pb"
)

// SerializedChallengeCache caches pre-marshaled JSON for static challenge data.
//
// This cache significantly reduces CPU usage by pre-serializing challenge configurations
// at startup instead of marshaling them on every request. Since challenges are static
// (only user progress changes), this optimization can reduce marshaling overhead by ~40%.
//
// Performance impact (expected at 200 RPS):
//   - CPU reduction: ~40% (protojson marshaling overhead eliminated for static data)
//   - Memory: ~100KB for cached JSON (negligible)
//   - Trade-off: Slight increase in complexity, cache invalidation needed on config changes
//
// Thread-safety: Uses RWMutex for concurrent access (many readers, rare writers)
type SerializedChallengeCache struct {
        mu         sync.RWMutex
        challenges map[string][]byte // challengeID -&gt; pre-serialized JSON
        goals      map[string][]byte // goalID -&gt; pre-serialized JSON
        marshaler  protojson.MarshalOptions
}

// NewSerializedChallengeCache creates a new serialized challenge cache.
func NewSerializedChallengeCache() *SerializedChallengeCache <span class="cov0" title="0">{
        return &amp;SerializedChallengeCache{
                challenges: make(map[string][]byte),
                goals:      make(map[string][]byte),
                marshaler: protojson.MarshalOptions{
                        UseProtoNames:   true,
                        EmitUnpopulated: false,
                        // NOTE: UseEnumNumbers is NOT set to true to maintain compatibility with demo app
                        // See docs/OPTIMIZATION.md - Optimization 1 for details
                },
        }
}</span>

// WarmUp pre-serializes all challenges and goals at startup.
//
// This method should be called once during application initialization with all
// challenges loaded from the configuration file. It pre-marshals each challenge
// and goal to JSON, storing the results in memory for fast lookup during requests.
//
// Args:
//   - challenges: All challenges from the configuration file (without user progress)
//
// Returns:
//   - error: If any challenge or goal fails to marshal
//
// Performance: This operation takes ~10-20ms for typical configs (10-20 challenges).
// It's a one-time cost at startup that saves 40% CPU time on every request.
func (c *SerializedChallengeCache) WarmUp(challenges []*pb.Challenge) error <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        for _, challenge := range challenges </span><span class="cov0" title="0">{
                if challenge == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Pre-serialize each goal (without user progress - will be injected later)
                <span class="cov0" title="0">for _, goal := range challenge.Goals </span><span class="cov0" title="0">{
                        if goal == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Create a copy of the goal with default progress values
                        // This is what we'll serialize and store in cache
                        <span class="cov0" title="0">goalTemplate := &amp;pb.Goal{
                                GoalId:        goal.GoalId,
                                Name:          goal.Name,
                                Description:   goal.Description,
                                Requirement:   goal.Requirement,
                                Reward:        goal.Reward,
                                Prerequisites: goal.Prerequisites,
                                // Progress fields left at defaults (will be injected at request time):
                                Progress:    0,
                                Status:      "",
                                Locked:      false,
                                CompletedAt: "",
                                ClaimedAt:   "",
                        }

                        goalJSON, err := c.marshaler.Marshal(goalTemplate)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to pre-serialize goal %s: %w", goal.GoalId, err)
                        }</span>
                        <span class="cov0" title="0">c.goals[goal.GoalId] = goalJSON</span>
                }

                // Pre-serialize challenge (with goal references)
                // Note: The goals in the serialized challenge will have default progress values
                // We'll inject actual progress values at request time
                <span class="cov0" title="0">challengeTemplate := &amp;pb.Challenge{
                        ChallengeId: challenge.ChallengeId,
                        Name:        challenge.Name,
                        Description: challenge.Description,
                        Goals:       challenge.Goals, // Goals with default progress
                }

                challengeJSON, err := c.marshaler.Marshal(challengeTemplate)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to pre-serialize challenge %s: %w", challenge.ChallengeId, err)
                }</span>
                <span class="cov0" title="0">c.challenges[challenge.ChallengeId] = challengeJSON</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetGoalJSON returns pre-serialized goal JSON.
//
// Args:
//   - goalID: The unique identifier for the goal
//
// Returns:
//   - []byte: Pre-serialized JSON for the goal (without user progress)
//   - bool: True if goal was found in cache, false otherwise
//
// Thread-safety: Safe for concurrent access (read lock)
func (c *SerializedChallengeCache) GetGoalJSON(goalID string) ([]byte, bool) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        jsonData, ok := c.goals[goalID]
        return jsonData, ok
}</span>

// GetChallengeJSON returns pre-serialized challenge JSON.
//
// Args:
//   - challengeID: The unique identifier for the challenge
//
// Returns:
//   - []byte: Pre-serialized JSON for the challenge (with goals, but without user progress)
//   - bool: True if challenge was found in cache, false otherwise
//
// Thread-safety: Safe for concurrent access (read lock)
func (c *SerializedChallengeCache) GetChallengeJSON(challengeID string) ([]byte, bool) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        jsonData, ok := c.challenges[challengeID]
        return jsonData, ok
}</span>

// Refresh rebuilds the cache with new challenges.
//
// This method should be called if the challenge configuration changes at runtime.
// It's thread-safe and will atomically replace the entire cache.
//
// Args:
//   - challenges: New challenges to cache
//
// Returns:
//   - error: If any challenge or goal fails to marshal
//
// Note: In production, this should be coordinated with config file monitoring
// (e.g., using fsnotify) to automatically refresh when config changes.
func (c *SerializedChallengeCache) Refresh(challenges []*pb.Challenge) error <span class="cov0" title="0">{
        // Create new maps for atomic replacement
        newChallenges := make(map[string][]byte)
        newGoals := make(map[string][]byte)

        // Pre-serialize all challenges and goals (same logic as WarmUp)
        for _, challenge := range challenges </span><span class="cov0" title="0">{
                if challenge == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, goal := range challenge.Goals </span><span class="cov0" title="0">{
                        if goal == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">goalTemplate := &amp;pb.Goal{
                                GoalId:        goal.GoalId,
                                Name:          goal.Name,
                                Description:   goal.Description,
                                Requirement:   goal.Requirement,
                                Reward:        goal.Reward,
                                Prerequisites: goal.Prerequisites,
                                Progress:      0,
                                Status:        "",
                                Locked:        false,
                                CompletedAt:   "",
                                ClaimedAt:     "",
                        }

                        goalJSON, err := c.marshaler.Marshal(goalTemplate)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to pre-serialize goal %s during refresh: %w", goal.GoalId, err)
                        }</span>
                        <span class="cov0" title="0">newGoals[goal.GoalId] = goalJSON</span>
                }

                <span class="cov0" title="0">challengeTemplate := &amp;pb.Challenge{
                        ChallengeId: challenge.ChallengeId,
                        Name:        challenge.Name,
                        Description: challenge.Description,
                        Goals:       challenge.Goals,
                }

                challengeJSON, err := c.marshaler.Marshal(challengeTemplate)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to pre-serialize challenge %s during refresh: %w", challenge.ChallengeId, err)
                }</span>
                <span class="cov0" title="0">newChallenges[challenge.ChallengeId] = challengeJSON</span>
        }

        // Atomically replace the cache
        <span class="cov0" title="0">c.mu.Lock()
        c.challenges = newChallenges
        c.goals = newGoals
        c.mu.Unlock()

        return nil</span>
}

// GetStats returns cache statistics for monitoring.
//
// Returns:
//   - challengeCount: Number of challenges in cache
//   - goalCount: Number of goals in cache
//   - totalBytes: Total size of cached JSON in bytes (approximate)
func (c *SerializedChallengeCache) GetStats() (challengeCount, goalCount, totalBytes int) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        challengeCount = len(c.challenges)
        goalCount = len(c.goals)

        for _, data := range c.challenges </span><span class="cov0" title="0">{
                totalBytes += len(data)
        }</span>
        <span class="cov0" title="0">for _, data := range c.goals </span><span class="cov0" title="0">{
                totalBytes += len(data)
        }</span>

        <span class="cov0" title="0">return</span>
}

// ParseAndMerge is a helper method that parses pre-serialized JSON and merges it with user progress.
//
// This is used internally by the response builder to inject user progress into cached JSON.
//
// Args:
//   - staticJSON: Pre-serialized challenge JSON from cache
//   - userProgress: User progress data to inject
//
// Returns:
//   - map[string]interface{}: Parsed challenge with injected progress
//   - error: If JSON parsing fails
func (c *SerializedChallengeCache) ParseAndMerge(
        staticJSON []byte,
        userProgress map[string]interface{},
) (map[string]interface{}, error) <span class="cov0" title="0">{
        var challenge map[string]interface{}
        if err := json.Unmarshal(staticJSON, &amp;challenge); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse cached challenge JSON: %w", err)
        }</span>

        // Note: userProgress injection is handled by the caller (response builder)
        // This method provides a convenient way to parse the cached JSON
        <span class="cov0" title="0">_ = userProgress // avoid unused parameter warning

        return challenge, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package client

import (
        "context"
        "fmt"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/AccelByte/accelbyte-go-sdk/platform-sdk/pkg/platformclient/entitlement"
        "github.com/AccelByte/accelbyte-go-sdk/platform-sdk/pkg/platformclient/wallet"
        "github.com/AccelByte/accelbyte-go-sdk/platform-sdk/pkg/platformclientmodels"
        "github.com/AccelByte/accelbyte-go-sdk/services-api/pkg/service/platform"
        "github.com/sirupsen/logrus"

        commonClient "github.com/AccelByte/extend-challenge-common/pkg/client"
        commonDomain "github.com/AccelByte/extend-challenge-common/pkg/domain"
)

// AGSRewardClient implements RewardClient interface using AccelByte Gaming Services (AGS) Platform SDK.
// It provides retry logic for reliability and proper error handling for AGS-specific errors.
type AGSRewardClient struct {
        entitlementService *platform.EntitlementService
        walletService      *platform.WalletService
        logger             *logrus.Logger
}

// NewAGSRewardClient creates a new AGSRewardClient with AGS Platform SDK services.
//
// Parameters:
//   - entitlementService: AGS Platform EntitlementService for granting items
//   - walletService: AGS Platform WalletService for crediting virtual currency
//   - logger: Logger for structured logging
func NewAGSRewardClient(
        entitlementService *platform.EntitlementService,
        walletService *platform.WalletService,
        logger *logrus.Logger,
) commonClient.RewardClient <span class="cov1" title="1">{
        return &amp;AGSRewardClient{
                entitlementService: entitlementService,
                walletService:      walletService,
                logger:             logger,
        }
}</span>

// GrantItemReward grants an item entitlement to a user using AGS Platform Service.
//
// This method:
//   - Creates an EntitlementGrant request with itemID, namespace, and quantity
//   - Calls GrantUserEntitlementShort SDK function
//   - Retries on transient failures (502/503, timeouts) with exponential backoff
//   - Fails immediately on non-retryable errors (400, 404, 403)
//
// Parameters:
//   - ctx: Context for cancellation and timeout
//   - namespace: AGS namespace for the deployment
//   - userID: User's unique identifier
//   - itemID: Item code from AGS inventory catalog
//   - quantity: Number of items to grant
//
// Returns error if grant fails after retries or on non-retryable errors.
func (c *AGSRewardClient) GrantItemReward(ctx context.Context, namespace, userID, itemID string, quantity int) error <span class="cov7" title="8">{
        // Validate quantity is within int32 range to prevent overflow
        if quantity &lt; 0 || quantity &gt; 2147483647 </span><span class="cov7" title="8">{
                return &amp;commonClient.BadRequestError{
                        Message: fmt.Sprintf("quantity %d out of range for int32", quantity),
                }
        }</span>

        <span class="cov0" title="0">return c.withRetry(ctx, "grant_item", func() error </span><span class="cov0" title="0">{
                // Create entitlement grant request
                // NOTE: ItemNamespace must equal deployment namespace (no cross-namespace grants)
                //nolint:gosec // G115: Safe conversion after range validation above
                quantity32 := int32(quantity)
                grant := &amp;platformclientmodels.EntitlementGrant{
                        ItemID:        &amp;itemID,
                        ItemNamespace: &amp;namespace,
                        Quantity:      &amp;quantity32,
                }

                params := &amp;entitlement.GrantUserEntitlementParams{
                        Namespace: namespace,
                        UserID:    userID,
                        Body:      []*platformclientmodels.EntitlementGrant{grant}, // NOTE: Body is array, not single grant
                }

                // Call AGS Platform SDK
                response, err := c.entitlementService.GrantUserEntitlementShort(params)
                if err != nil </span><span class="cov0" title="0">{
                        return c.wrapSDKError(err, "failed to grant item reward")
                }</span>

                // Log response for audit (don't validate, just log)
                <span class="cov0" title="0">c.logger.WithFields(logrus.Fields{
                        "namespace": namespace,
                        "userID":    userID,
                        "itemID":    itemID,
                        "quantity":  quantity,
                        "response":  response,
                }).Info("Item reward granted successfully")

                return nil</span>
        })
}

// GrantWalletReward credits a user's wallet with virtual currency using AGS Platform Service.
//
// This method:
//   - Creates a CreditRequest with amount and currencyCode
//   - Calls CreditUserWalletShort SDK function (creates wallet if not exists)
//   - Retries on transient failures (502/503, timeouts) with exponential backoff
//   - Fails immediately on non-retryable errors (400, 404, 403)
//
// Parameters:
//   - ctx: Context for cancellation and timeout
//   - namespace: AGS namespace for the deployment
//   - userID: User's unique identifier
//   - currencyCode: Currency code from AGS wallet (e.g., "GOLD", "GEMS")
//   - amount: Amount of currency to credit
//
// Returns error if grant fails after retries or on non-retryable errors.
func (c *AGSRewardClient) GrantWalletReward(ctx context.Context, namespace, userID, currencyCode string, amount int) error <span class="cov5" title="5">{
        // Validate amount is non-negative (int64 range is much larger than int, so only check negative)
        if amount &lt; 0 </span><span class="cov5" title="5">{
                return &amp;commonClient.BadRequestError{
                        Message: fmt.Sprintf("amount %d cannot be negative", amount),
                }
        }</span>

        <span class="cov0" title="0">return c.withRetry(ctx, "grant_wallet", func() error </span><span class="cov0" title="0">{
                // Create credit request
                // NOTE: Amount is int64, not int
                amount64 := int64(amount) // Safe conversion from int to int64
                creditReq := &amp;platformclientmodels.CreditRequest{
                        Amount: &amp;amount64,
                        // Optional fields can be added here: Reason, Source, Origin, Metadata
                }

                params := &amp;wallet.CreditUserWalletParams{
                        Namespace:    namespace,
                        UserID:       userID,
                        CurrencyCode: currencyCode,
                        Body:         creditReq,
                }

                // Call AGS Platform SDK
                response, err := c.walletService.CreditUserWalletShort(params)
                if err != nil </span><span class="cov0" title="0">{
                        return c.wrapSDKError(err, "failed to credit wallet")
                }</span>

                // Log response for audit (don't validate, just log)
                <span class="cov0" title="0">c.logger.WithFields(logrus.Fields{
                        "namespace":    namespace,
                        "userID":       userID,
                        "currencyCode": currencyCode,
                        "amount":       amount,
                        "response":     response,
                }).Info("Wallet credited successfully")

                return nil</span>
        })
}

// GrantReward is a convenience method that dispatches to the appropriate grant method
// based on the reward type (ITEM or WALLET).
//
// Parameters:
//   - ctx: Context for cancellation and timeout
//   - namespace: AGS namespace for the deployment
//   - userID: User's unique identifier
//   - reward: Reward configuration from goal
//
// Returns error if reward type is unsupported or grant fails after retries.
func (c *AGSRewardClient) GrantReward(ctx context.Context, namespace, userID string, reward commonDomain.Reward) error <span class="cov4" title="3">{
        switch reward.Type </span>{
        case "ITEM":<span class="cov1" title="1">
                return c.GrantItemReward(ctx, namespace, userID, reward.RewardID, reward.Quantity)</span>
        case "WALLET":<span class="cov1" title="1">
                return c.GrantWalletReward(ctx, namespace, userID, reward.RewardID, reward.Quantity)</span>
        default:<span class="cov1" title="1">
                c.logger.WithFields(logrus.Fields{
                        "namespace":  namespace,
                        "userID":     userID,
                        "rewardType": reward.Type,
                }).Warn("Unknown reward type")
                return fmt.Errorf("unsupported reward type: %s", reward.Type)</span>
        }
}

// withRetry executes the given function with retry logic for transient failures.
//
// Retry strategy:
//   - Maximum retries: 3 (total 4 attempts)
//   - Base delay: 500ms
//   - Exponential backoff: 500ms, 1s, 2s
//   - Total timeout: 10 seconds (prevents transaction timeout)
//   - Context cancellation check before each retry
//
// The function will:
//   - Retry on transient failures: 502/503, timeouts, network errors
//   - Fail immediately on non-retryable errors: 400, 404, 403
//   - Respect context cancellation during retry delays
//
// Parameters:
//   - ctx: Context for cancellation and timeout
//   - operation: Operation name for logging (e.g., "grant_item", "grant_wallet")
//   - fn: Function to execute with retry logic
//
// Returns error if all retries are exhausted or on non-retryable errors.
func (c *AGSRewardClient) withRetry(ctx context.Context, operation string, fn func() error) error <span class="cov7" title="8">{
        const maxRetries = 3
        const baseDelay = 500 * time.Millisecond
        const totalTimeout = 10 * time.Second // NQ8: 10s total timeout to prevent transaction timeout

        // Create context with total timeout
        timeoutCtx, cancel := context.WithTimeout(ctx, totalTimeout)
        defer cancel()

        var lastErr error
        for attempt := 1; attempt &lt;= maxRetries+1; attempt++ </span><span class="cov10" title="19">{
                // Check context cancellation before retry (NQ4: always check ctx.Err())
                if err := timeoutCtx.Err(); err != nil </span><span class="cov1" title="1">{
                        c.logger.WithFields(logrus.Fields{
                                "operation": operation,
                                "attempt":   attempt,
                                "error":     err,
                        }).Warn("Context cancelled or timeout exceeded, stopping retries")
                        return fmt.Errorf("context cancelled: %w", err)
                }</span>

                // Execute operation with timeout context
                <span class="cov9" title="18">err := fn()
                if err == nil </span><span class="cov4" title="3">{
                        // Success
                        if attempt &gt; 1 </span><span class="cov3" title="2">{
                                c.logger.WithFields(logrus.Fields{
                                        "operation": operation,
                                        "attempt":   attempt,
                                }).Info("Reward grant succeeded after retry")
                        }</span>
                        <span class="cov4" title="3">return nil</span>
                }

                <span class="cov9" title="15">lastErr = err

                // Check if error is retryable (uses commonClient.IsRetryableError)
                if !commonClient.IsRetryableError(err) </span><span class="cov1" title="1">{
                        c.logger.WithFields(logrus.Fields{
                                "operation": operation,
                                "attempt":   attempt,
                                "error":     err,
                        }).Error("Non-retryable error, failing immediately")
                        return fmt.Errorf("non-retryable error: %w", err)
                }</span>

                // Don't sleep after last attempt
                <span class="cov9" title="14">if attempt &lt;= maxRetries </span><span class="cov8" title="12">{
                        delay := baseDelay * time.Duration(1&lt;&lt;(attempt-1)) // Exponential backoff: 500ms, 1s, 2s
                        c.logger.WithFields(logrus.Fields{
                                "operation": operation,
                                "attempt":   attempt,
                                "nextDelay": delay,
                                "error":     err,
                        }).Warn("Reward grant failed, will retry")

                        // Use time.After with select to respect context cancellation during sleep
                        select </span>{
                        case &lt;-time.After(delay):<span class="cov8" title="11"></span>
                                // Continue to next retry
                        case &lt;-timeoutCtx.Done():<span class="cov1" title="1">
                                c.logger.WithFields(logrus.Fields{
                                        "operation": operation,
                                        "attempt":   attempt,
                                }).Warn("Timeout during backoff delay")
                                return fmt.Errorf("timeout during retry backoff: %w", timeoutCtx.Err())</span>
                        }
                }
        }

        // All retries exhausted
        <span class="cov3" title="2">c.logger.WithFields(logrus.Fields{
                "operation": operation,
                "attempts":  maxRetries + 1,
                "error":     lastErr,
        }).Error("Reward grant failed after all retries")
        return fmt.Errorf("failed after %d attempts: %w", maxRetries+1, lastErr)</span>
}

// wrapSDKError wraps an AGS SDK error with a custom error type that includes HTTP status code.
//
// This function attempts to extract the HTTP status code from the SDK error using type assertion.
// If successful, it creates an appropriate error type (BadRequestError, NotFoundError, etc.).
// If status code extraction fails, it wraps the error with a generic message.
//
// Parameters:
//   - err: Original error from AGS SDK
//   - message: Prefix message for the error
//
// Returns a wrapped error with HTTP status code (if available).
func (c *AGSRewardClient) wrapSDKError(err error, message string) error <span class="cov7" title="8">{
        if err == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Try to extract status code from SDK error (NQ1: type assertion pattern)
        <span class="cov6" title="7">statusCode, ok := c.extractStatusCode(err)
        if !ok </span><span class="cov1" title="1">{
                // Could not extract status code, wrap with generic message
                return fmt.Errorf("%s: %w", message, err)
        }</span>

        // Map status code to appropriate error type
        <span class="cov6" title="6">switch statusCode </span>{
        case 400:<span class="cov1" title="1">
                return &amp;commonClient.BadRequestError{
                        Message: err.Error(),
                }</span>
        case 401:<span class="cov1" title="1">
                return &amp;commonClient.AuthenticationError{
                        Message: err.Error(),
                }</span>
        case 403:<span class="cov1" title="1">
                return &amp;commonClient.ForbiddenError{
                        Message: err.Error(),
                }</span>
        case 404:<span class="cov1" title="1">
                return &amp;commonClient.NotFoundError{
                        Resource: err.Error(),
                }</span>
        default:<span class="cov3" title="2">
                return &amp;commonClient.AGSError{
                        StatusCode: statusCode,
                        Message:    err.Error(),
                }</span>
        }
}

// extractStatusCode attempts to extract HTTP status code from SDK error.
//
// This function uses type assertion to identify specific SDK error types and extract their status codes.
// It handles known error types from entitlement and wallet operations, with a regex fallback for unknown types.
//
// Known SDK error types (Phase 7.6):
//   - entitlement.GrantUserEntitlementNotFound (404)
//   - entitlement.GrantUserEntitlementUnprocessableEntity (422)
//   - wallet.CreditUserWalletBadRequest (400)
//   - wallet.CreditUserWalletUnprocessableEntity (422)
//
// Fallback: Parses generic SDK error message format "[METHOD /path][CODE] errorName {...}"
//
// Parameters:
//   - err: Error from AGS SDK
//
// Returns (statusCode, true) if extraction successful, (0, false) otherwise.
func (c *AGSRewardClient) extractStatusCode(err error) (int, bool) <span class="cov9" title="15">{
        if err == nil </span><span class="cov1" title="1">{
                return 0, false
        }</span>

        // Type assertion for known SDK error types (Phase 7.6: Option B)
        <span class="cov9" title="14">switch err.(type) </span>{
        case *entitlement.GrantUserEntitlementNotFound:<span class="cov0" title="0">
                return 404, true</span>
        case *entitlement.GrantUserEntitlementUnprocessableEntity:<span class="cov0" title="0">
                return 422, true</span>
        case *wallet.CreditUserWalletBadRequest:<span class="cov0" title="0">
                return 400, true</span>
        case *wallet.CreditUserWalletUnprocessableEntity:<span class="cov0" title="0">
                return 422, true</span>
        }

        // Fallback: Parse generic SDK error message format
        // Example: "[POST /platform/...][404] grantUserEntitlementNotFound {...}"
        <span class="cov9" title="14">errMsg := err.Error()
        if strings.Contains(errMsg, "[") &amp;&amp; strings.Contains(errMsg, "]") </span><span class="cov8" title="11">{
                re := regexp.MustCompile(`\[(\d{3})\]`)
                matches := re.FindStringSubmatch(errMsg)
                if len(matches) &gt; 1 </span><span class="cov8" title="11">{
                        if code, parseErr := strconv.Atoi(matches[1]); parseErr == nil </span><span class="cov8" title="11">{
                                return code, true
                        }</span>
                }
        }

        // Could not extract status code from error
        <span class="cov4" title="3">c.logger.WithFields(logrus.Fields{
                "errorType": fmt.Sprintf("%T", err),
                "error":     err.Error(),
        }).Debug("Could not extract status code from SDK error")

        return 0, false</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package client

import (
        "context"

        "github.com/sirupsen/logrus"

        commonClient "github.com/AccelByte/extend-challenge-common/pkg/client"
        commonDomain "github.com/AccelByte/extend-challenge-common/pkg/domain"
)

// NoOpRewardClient is a no-op implementation of RewardClient for M1.
// It logs reward grants instead of making actual AGS Platform Service calls.
// This allows the service to run without AGS integration for local development and testing.
//
// In Phase 7, this will be replaced with a real AGS SDK client that calls:
// - AGS Platform Service for item entitlements
// - AGS E-Commerce Service for wallet credits
//
// Usage:
//
//        rewardClient := client.NewNoOpRewardClient(logger)
//        err := rewardClient.GrantReward(ctx, namespace, userID, reward)
type NoOpRewardClient struct {
        logger *logrus.Logger
}

// NewNoOpRewardClient creates a new no-op reward client
func NewNoOpRewardClient(logger *logrus.Logger) commonClient.RewardClient <span class="cov0" title="0">{
        return &amp;NoOpRewardClient{logger: logger}
}</span>

// GrantItemReward logs the item reward grant instead of calling AGS
func (c *NoOpRewardClient) GrantItemReward(ctx context.Context, namespace, userID, itemID string, quantity int) error <span class="cov0" title="0">{
        c.logger.WithFields(logrus.Fields{
                "namespace": namespace,
                "user_id":   userID,
                "item_id":   itemID,
                "quantity":  quantity,
        }).Info("[NO-OP] Would grant item reward (AGS integration in Phase 7)")
        return nil
}</span>

// GrantWalletReward logs the wallet reward grant instead of calling AGS
func (c *NoOpRewardClient) GrantWalletReward(ctx context.Context, namespace, userID, currencyCode string, amount int) error <span class="cov0" title="0">{
        c.logger.WithFields(logrus.Fields{
                "namespace":     namespace,
                "user_id":       userID,
                "currency_code": currencyCode,
                "amount":        amount,
        }).Info("[NO-OP] Would grant wallet reward (AGS integration in Phase 7)")
        return nil
}</span>

// GrantReward dispatches to the appropriate grant method based on reward type
func (c *NoOpRewardClient) GrantReward(ctx context.Context, namespace, userID string, reward commonDomain.Reward) error <span class="cov0" title="0">{
        switch reward.Type </span>{
        case "ITEM":<span class="cov0" title="0">
                return c.GrantItemReward(ctx, namespace, userID, reward.RewardID, reward.Quantity)</span>
        case "WALLET":<span class="cov0" title="0">
                return c.GrantWalletReward(ctx, namespace, userID, reward.RewardID, reward.Quantity)</span>
        default:<span class="cov0" title="0">
                c.logger.WithFields(logrus.Fields{
                        "namespace":   namespace,
                        "user_id":     userID,
                        "reward_type": reward.Type,
                }).Warn("[NO-OP] Unknown reward type")
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright (c) 2023 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.

// Package common provides gRPC server interceptors for authentication and authorization.
//
// # JWT Authentication Flow
//
// The auth interceptor centralizes JWT validation and claim extraction:
//
//  1. Client sends request with "Authorization: Bearer &lt;jwt&gt;" header
//  2. gRPC Gateway or gRPC client includes JWT in metadata
//  3. Auth interceptor (NewUnaryAuthServerIntercept) intercepts the request
//  4. checkAuthorizationMetadata performs two operations:
//     a. Validates JWT using AccelByte validator (signature, expiration, permissions)
//     b. Decodes JWT payload and extracts user claims (user_id, namespace)
//  5. User claims are stored in context using context.WithValue()
//  6. Modified context is passed to the gRPC handler
//  7. Handler extracts user_id using common.GetUserIDFromContext(ctx)
//
// # Benefits of This Approach
//
// - Single point of JWT validation (DRY principle)
// - Handlers don't need to understand JWT format or base64 encoding
// - Easy to mock in tests (just set context values)
// - Consistent error handling across all endpoints
// - Performance: JWT decoded once per request, not multiple times
//
// # Usage in Service Handlers
//
//        func (s *ChallengeServiceServer) GetUserChallenges(ctx context.Context, req *pb.Request) (*pb.Response, error) {
//            // Extract authenticated user ID from context (populated by auth interceptor)
//            userID, err := common.GetUserIDFromContext(ctx)
//            if err != nil {
//                return nil, err
//            }
//
//            // Use userID for business logic
//            challenges, err := s.service.GetChallenges(ctx, userID)
//            ...
//        }
//
// # Testing
//
// In unit tests, simulate the auth interceptor by setting context values:
//
//        ctx := context.Background()
//        ctx = context.WithValue(ctx, common.ContextKeyUserID, "test-user-123")
//        ctx = context.WithValue(ctx, common.ContextKeyNamespace, "test-namespace")
//
// For integration tests with JWT validation, ensure the Validator is initialized.
package common

import (
        "context"
        "crypto/rsa"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "regexp"
        "strings"
        "time"

        pb "extend-challenge-service/pkg/pb"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/reflect/protoreflect"
        "google.golang.org/protobuf/reflect/protoregistry"

        "github.com/AccelByte/accelbyte-go-sdk/iam-sdk/pkg/iamclientmodels"
        "github.com/AccelByte/accelbyte-go-sdk/services-api/pkg/service/iam"
        "github.com/AccelByte/accelbyte-go-sdk/services-api/pkg/utils/auth/validator"
        "github.com/pkg/errors"
)

var (
        Validator validator.AuthTokenValidator
)

// Context keys for storing user information extracted from JWT
type contextKey string

const (
        // ContextKeyUserID is the context key for storing the authenticated user ID from JWT
        ContextKeyUserID contextKey = "user_id"
        // ContextKeyNamespace is the context key for storing the namespace from JWT
        ContextKeyNamespace contextKey = "namespace"
)

// JWTClaims represents the standard JWT claims we extract from AccelByte tokens
type JWTClaims struct {
        Sub       string `json:"sub"`       // Subject (user ID)
        Namespace string `json:"namespace"` // Namespace
        Exp       int64  `json:"exp"`       // Expiration time
        Iat       int64  `json:"iat"`       // Issued at
}

type ProtoPermissionExtractor interface {
        ExtractPermission(infoUnary *grpc.UnaryServerInfo, infoStream *grpc.StreamServerInfo) (permission *iam.Permission, err error)
}

func NewProtoPermissionExtractor() *ProtoPermissionExtractorImpl <span class="cov0" title="0">{
        return &amp;ProtoPermissionExtractorImpl{}
}</span>

type ProtoPermissionExtractorImpl struct{}

func (p *ProtoPermissionExtractorImpl) ExtractPermission(infoUnary *grpc.UnaryServerInfo, infoStream *grpc.StreamServerInfo) (*iam.Permission, error) <span class="cov0" title="0">{
        if infoUnary != nil &amp;&amp; infoStream != nil </span><span class="cov0" title="0">{
                return nil, errors.New("both infoUnary and infoStream cannot be filled at the same time")
        }</span>

        <span class="cov0" title="0">var serviceName string
        var methodName string
        var err error

        if infoUnary != nil </span><span class="cov0" title="0">{
                serviceName, methodName, err = parseFullMethod(infoUnary.FullMethod)
        }</span> else<span class="cov0" title="0"> if infoStream != nil </span><span class="cov0" title="0">{
                serviceName, methodName, err = parseFullMethod(infoStream.FullMethod)
        }</span> else<span class="cov0" title="0"> {
                return nil, errors.New("both infoUnary and infoStream are nil")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read the required permission stated in the proto file
        <span class="cov0" title="0">desc, err := protoregistry.GlobalFiles.FindDescriptorByName(protoreflect.FullName(serviceName))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">serviceDesc := desc.(protoreflect.ServiceDescriptor)
        method := serviceDesc.Methods().ByName(protoreflect.Name(methodName))
        resource := proto.GetExtension(method.Options(), pb.E_Resource).(string)
        action := proto.GetExtension(method.Options(), pb.E_Action).(pb.Action)
        permission := wrapPermission(resource, int(action.Number()))

        if resource == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return &amp;permission, nil</span>
}

func NewUnaryAuthServerIntercept(
        permissionExtractor ProtoPermissionExtractor,
) func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) <span class="cov0" title="0">{ // nolint

        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                if !skipCheckAuthorizationMetadata(info.FullMethod) </span><span class="cov0" title="0">{
                        // Extract permission stated in the proto file
                        permission, err := permissionExtractor.ExtractPermission(info, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // Validate JWT and extract user claims into context
                        <span class="cov0" title="0">ctx, err = checkAuthorizationMetadata(ctx, permission)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov0" title="0">return handler(ctx, req)</span>
        }
}

func parseFullMethod(fullMethod string) (string, string, error) <span class="cov0" title="0">{
        // Define the regular expression according to example shown here https://github.com/grpc/grpc-java/issues/4726
        re := regexp.MustCompile(`^/([^/]+)/([^/]+)$`)
        matches := re.FindStringSubmatch(fullMethod)

        // Validate the match
        if matches == nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("invalid FullMethod format")
        }</span>

        // Extract service and method names
        <span class="cov0" title="0">serviceName, methodName := matches[1], matches[2]

        if len(serviceName) == 0 </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("invalid FullMethod format: service name is empty")
        }</span>

        <span class="cov0" title="0">if len(methodName) == 0 </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("invalid FullMethod format: method name is empty")
        }</span>

        <span class="cov0" title="0">return serviceName, methodName, nil</span>
}

func NewStreamAuthServerIntercept(
        permissionExtractor ProtoPermissionExtractor,
) func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error <span class="cov0" title="0">{
        return func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov0" title="0">{
                if !skipCheckAuthorizationMetadata(info.FullMethod) </span><span class="cov0" title="0">{
                        // Extract permission stated in the proto file
                        permission, err := permissionExtractor.ExtractPermission(nil, info)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Validate JWT and extract user claims into context
                        <span class="cov0" title="0">_, err = checkAuthorizationMetadata(ss.Context(), permission)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // Note: For stream interceptors, we can't modify the context passed to the handler
                        // This is a limitation of gRPC's stream interceptor design
                        // If needed, implement a wrapped ServerStream that returns the modified context
                }

                <span class="cov0" title="0">return handler(srv, ss)</span>
        }
}

func skipCheckAuthorizationMetadata(fullMethod string) bool <span class="cov0" title="0">{
        if strings.HasPrefix(fullMethod, "/grpc.reflection.v1alpha.ServerReflection/") </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if strings.HasPrefix(fullMethod, "/grpc.health.v1.Health/") </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// checkAuthorizationMetadata validates the JWT token and extracts user claims into the context.
// It performs two key operations:
// 1. Validates the JWT token using the AccelByte validator (signature, expiration, permissions)
// 2. Decodes the JWT payload and stores user_id and namespace in the context for downstream handlers
//
// This centralizes JWT handling in the auth interceptor, so service handlers don't need to
// re-decode the JWT token. Handlers can simply extract user_id from context using GetUserIDFromContext().
//
// If Validator is nil (auth disabled via PLUGIN_GRPC_SERVER_AUTH_ENABLED=false), this function
// injects a test user into the context for local development and testing.
//
// Returns: Modified context with user claims, or error if validation/decoding fails
func checkAuthorizationMetadata(ctx context.Context, permission *iam.Permission) (context.Context, error) <span class="cov0" title="0">{
        // When auth is disabled (Validator not initialized), inject test user for local development
        // Check for mock user ID header to support E2E testing with different user IDs
        if Validator == nil </span><span class="cov0" title="0">{
                namespace := getNamespace()
                userID := "test-user-123" // Default for local development

                // Check for mock user ID header (for E2E testing)
                // This allows tests to specify different user IDs even when auth is disabled
                meta, found := metadata.FromIncomingContext(ctx)
                if found </span><span class="cov0" title="0">{
                        // Try different possible header names (gRPC Gateway might transform the name)
                        possibleKeys := []string{"x-mock-user-id", "X-Mock-User-Id", "grpcgateway-x-mock-user-id"}
                        for _, key := range possibleKeys </span><span class="cov0" title="0">{
                                if mockUserIDs := meta.Get(key); len(mockUserIDs) &gt; 0 &amp;&amp; mockUserIDs[0] != "" </span><span class="cov0" title="0">{
                                        userID = mockUserIDs[0]
                                        break</span>
                                }
                        }
                }

                <span class="cov0" title="0">ctx = context.WithValue(ctx, ContextKeyUserID, userID)
                ctx = context.WithValue(ctx, ContextKeyNamespace, namespace)
                return ctx, nil</span>
        }

        <span class="cov0" title="0">meta, found := metadata.FromIncomingContext(ctx)

        if !found </span><span class="cov0" title="0">{
                return ctx, status.Error(codes.Unauthenticated, "metadata is missing")
        }</span>

        <span class="cov0" title="0">if _, ok := meta["authorization"]; !ok </span><span class="cov0" title="0">{
                return ctx, status.Error(codes.Unauthenticated, "authorization metadata is missing")
        }</span>

        <span class="cov0" title="0">if len(meta["authorization"]) == 0 </span><span class="cov0" title="0">{
                return ctx, status.Error(codes.Unauthenticated, "authorization metadata length is 0")
        }</span>

        <span class="cov0" title="0">authorization := meta["authorization"][0]
        token := strings.TrimPrefix(authorization, "Bearer ")
        namespace := getNamespace()

        // Validate JWT signature, expiration, and permissions using AccelByte validator
        err := Validator.Validate(token, permission, &amp;namespace, nil)
        if err != nil </span><span class="cov0" title="0">{
                return ctx, status.Error(codes.PermissionDenied, err.Error())
        }</span>

        // After successful validation, decode JWT payload to extract user claims
        <span class="cov0" title="0">claims, err := decodeJWTClaims(token)
        if err != nil </span><span class="cov0" title="0">{
                return ctx, status.Errorf(codes.Internal, "failed to decode JWT claims: %v", err)
        }</span>

        // Store user claims in context for downstream handlers
        <span class="cov0" title="0">ctx = context.WithValue(ctx, ContextKeyUserID, claims.Sub)
        ctx = context.WithValue(ctx, ContextKeyNamespace, claims.Namespace)

        return ctx, nil</span>
}

// decodeJWTClaims decodes the JWT token payload and extracts standard claims.
// This is called AFTER token validation to extract user information.
// The token format is: header.payload.signature (base64url encoded)
func decodeJWTClaims(token string) (*JWTClaims, error) <span class="cov0" title="0">{
        // Split JWT into parts
        parts := strings.Split(token, ".")
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid JWT format: expected 3 parts, got %d", len(parts))
        }</span>

        // Decode payload (second part) - try RawURLEncoding first, then URLEncoding
        <span class="cov0" title="0">payload, err := base64.RawURLEncoding.DecodeString(parts[1])
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to standard URLEncoding if RawURLEncoding fails
                payload, err = base64.URLEncoding.DecodeString(parts[1])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to decode JWT payload: %w", err)
                }</span>
        }

        // Parse JSON claims
        <span class="cov0" title="0">var claims JWTClaims
        if err := json.Unmarshal(payload, &amp;claims); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal JWT claims: %w", err)
        }</span>

        // Validate required claims
        <span class="cov0" title="0">if claims.Sub == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user ID (sub claim) is empty")
        }</span>

        <span class="cov0" title="0">return &amp;claims, nil</span>
}

// GetUserIDFromContext extracts the authenticated user ID from the request context.
// This should be called by service handlers after the auth interceptor has validated the JWT.
// Returns empty string if user ID is not found in context (which shouldn't happen after auth).
func GetUserIDFromContext(ctx context.Context) (string, error) <span class="cov0" title="0">{
        userID, ok := ctx.Value(ContextKeyUserID).(string)
        if !ok || userID == "" </span><span class="cov0" title="0">{
                return "", status.Error(codes.Unauthenticated, "user ID not found in context")
        }</span>
        <span class="cov0" title="0">return userID, nil</span>
}

// GetNamespaceFromContext extracts the namespace from the request context.
// Returns empty string if namespace is not found in context.
func GetNamespaceFromContext(ctx context.Context) string <span class="cov0" title="0">{
        namespace, ok := ctx.Value(ContextKeyNamespace).(string)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return namespace</span>
}

func getNamespace() string <span class="cov0" title="0">{
        return GetEnv("AB_NAMESPACE", "accelbyte")
}</span>

func wrapPermission(resource string, action int) iam.Permission <span class="cov0" title="0">{
        return iam.Permission{
                Action:   action,
                Resource: resource,
        }
}</span>

func NewTokenValidator(authService iam.OAuth20Service, refreshInterval time.Duration, validateLocally bool) validator.AuthTokenValidator <span class="cov0" title="0">{
        return &amp;iam.TokenValidator{
                AuthService:     authService,
                RefreshInterval: refreshInterval,

                Filter:                nil,
                JwkSet:                nil,
                JwtClaims:             iam.JWTClaims{},
                JwtEncoding:           *base64.URLEncoding.WithPadding(base64.NoPadding),
                PublicKeys:            make(map[string]*rsa.PublicKey),
                LocalValidationActive: validateLocally,
                RevokedUsers:          make(map[string]time.Time),
                Roles:                 make(map[string]*iamclientmodels.ModelRolePermissionResponseV3),
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright (c) 2023-2025 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.

package common

import (
        "bytes"
        "sync"
)

// Buffer pool configuration
const (
        // defaultBufferSize is the initial capacity for pooled buffers (32KB)
        // Typical challenge response is 10-20KB, so 32KB provides good headroom
        defaultBufferSize = 32 * 1024

        // maxBufferSize is the maximum buffer size to pool (128KB)
        // Larger buffers are discarded to prevent memory bloat
        maxBufferSize = 128 * 1024
)

var (
        // jsonBufferPool recycles buffers for JSON encoding
        // This reduces allocation overhead and GC pressure
        //
        // Performance impact (from profiling at 200 RPS):
        //   - Reduces memory allocations by ~15%
        //   - Reduces CPU time by ~10%
        //   - json.appendString allocations: 5,714 MB  ~4,857 MB (15% reduction)
        //   - json.WriteName allocations: 1,764 MB  ~1,499 MB (15% reduction)
        jsonBufferPool = sync.Pool{
                New: func() any <span class="cov2" title="6">{
                        // Pre-allocate buffer with default capacity
                        // Using make([]byte, 0, N) creates a buffer with 0 length but N capacity
                        // This avoids initial grow operations during JSON encoding
                        return bytes.NewBuffer(make([]byte, 0, defaultBufferSize))
                }</span>,
        }
)

// GetJSONBuffer retrieves a buffer from the pool for JSON encoding.
// The returned buffer should be returned to the pool using PutJSONBuffer() after use.
//
// Usage:
//
//        buf := GetJSONBuffer()
//        defer PutJSONBuffer(buf)
//        // Use buf for JSON encoding
func GetJSONBuffer() *bytes.Buffer <span class="cov9" title="10010">{
        return jsonBufferPool.Get().(*bytes.Buffer)
}</span>

// PutJSONBuffer returns a buffer to the pool for reuse.
// The buffer is reset (contents cleared) before being returned to the pool.
//
// Buffers larger than maxBufferSize are discarded to prevent memory bloat.
// This can happen if a response is unusually large (e.g., user has hundreds of challenges).
//
// IMPORTANT: After calling this function, do not use the buffer again.
// The buffer may be reused by another goroutine immediately.
func PutJSONBuffer(buf *bytes.Buffer) <span class="cov10" title="10012">{
        if buf == nil </span><span class="cov1" title="1">{
                return
        }</span>

        // Discard buffers that are too large to prevent memory bloat
        <span class="cov9" title="10011">if buf.Cap() &gt; maxBufferSize </span><span class="cov1" title="1">{
                // Don't pool this buffer - let GC collect it
                return
        }</span>

        // Reset buffer (clears contents but keeps capacity)
        <span class="cov9" title="10010">buf.Reset()

        // Return to pool for reuse
        jsonBufferPool.Put(buf)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright (c) 2023-2025 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.

package common

import (
        "context"
        "net/http"
        "strings"

        "google.golang.org/grpc/credentials/insecure"

        pb "extend-challenge-service/pkg/pb"

        "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
        "google.golang.org/grpc"
)

type Gateway struct {
        mux      *runtime.ServeMux
        basePath string
}

func NewGateway(ctx context.Context, grpcServerEndpoint string, basePath string) (*Gateway, error) <span class="cov0" title="0">{
        // Configure gRPC Gateway to forward x-mock-user-id header to gRPC metadata
        // This enables E2E testing with different user IDs when backend auth is disabled
        headerMatcher := func(key string) (string, bool) </span><span class="cov0" title="0">{
                switch strings.ToLower(key) </span>{
                case "x-mock-user-id":<span class="cov0" title="0">
                        // Forward mock user ID header for testing
                        return key, true</span>
                default:<span class="cov0" title="0">
                        // Use default behavior for other headers
                        return runtime.DefaultHeaderMatcher(key)</span>
                }
        }

        // Use sonic marshaler for 2-3x faster JSON encoding (52% CPU time reduction)
        <span class="cov0" title="0">sonicMarshaler := NewSonicMarshaler()

        mux := runtime.NewServeMux(
                runtime.WithIncomingHeaderMatcher(headerMatcher),
                runtime.WithMarshalerOption(runtime.MIMEWildcard, sonicMarshaler),
        )
        // Configure gRPC buffer sizes to reduce reallocations
        // Typical challenge list response: ~10-20KB, 32KB buffers provide headroom
        opts := []grpc.DialOption{
                grpc.WithTransportCredentials(insecure.NewCredentials()),
                grpc.WithWriteBufferSize(32 * 1024),        // 32KB write buffer
                grpc.WithReadBufferSize(32 * 1024),         // 32KB read buffer
                grpc.WithInitialWindowSize(64 * 1024),      // 64KB initial window size
                grpc.WithInitialConnWindowSize(128 * 1024), // 128KB connection window
        }
        err := pb.RegisterServiceHandlerFromEndpoint(ctx, mux, grpcServerEndpoint, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Gateway{
                mux:      mux,
                basePath: basePath,
        }, nil</span>
}

func (g *Gateway) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Strip the base path, since the base_path configuration in protofile won't actually do the routing
        // Reference: https://github.com/grpc-ecosystem/grpc-gateway/pull/919/commits/1c34df861cfc0d6cb19ea617921d7d9eaa209977
        http.StripPrefix(g.basePath, g.mux).ServeHTTP(w, r)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright (c) 2023 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.

package common

import (
        "context"
        "fmt"

        "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging"
        "github.com/sirupsen/logrus"
)

// InterceptorLogger adapts logrus logger to interceptor logger.
// This code is referenced from https://github.com/grpc-ecosystem/go-grpc-middleware/
func InterceptorLogger(l logrus.FieldLogger) logging.Logger <span class="cov0" title="0">{
        return logging.LoggerFunc(func(_ context.Context, lvl logging.Level, msg string, fields ...any) </span><span class="cov0" title="0">{
                f := make(map[string]any, len(fields)/2)
                i := logging.Fields(fields).Iterator()
                if i.Next() </span><span class="cov0" title="0">{
                        k, v := i.At()
                        f[k] = v
                }</span>
                <span class="cov0" title="0">l = l.WithFields(f)

                switch lvl </span>{
                case logging.LevelDebug:<span class="cov0" title="0">
                        l.Debug(msg)</span>
                case logging.LevelInfo:<span class="cov0" title="0">
                        l.Info(msg)</span>
                case logging.LevelWarn:<span class="cov0" title="0">
                        l.Warn(msg)</span>
                case logging.LevelError:<span class="cov0" title="0">
                        l.Error(msg)</span>
                default:<span class="cov0" title="0">
                        panic(fmt.Sprintf("unknown level %v", lvl))</span>
                }
        })
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright (c) 2023-2025 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.

package common

import (
        "io"

        "github.com/bytedance/sonic"
        "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
        "google.golang.org/protobuf/encoding/protojson"
        "google.golang.org/protobuf/proto"
)

// SonicMarshaler is a custom marshaler that uses bytedance/sonic for JSON encoding/decoding.
// It provides significant performance improvements over the default protojson marshaler.
//
// Performance benefits:
//   - 2-3x faster JSON encoding
//   - 50-60% reduction in memory allocations
//   - Lower GC pressure
//
// For protobuf messages, it uses a hybrid approach:
//  1. Convert proto message to JSON using protojson (handles proto-specific types correctly)
//  2. Re-parse and re-encode with sonic for optimized output
//
// This provides the correctness of protojson with the performance of sonic.
type SonicMarshaler struct {
        // Embed the default JSONPb marshaler for protobuf handling
        runtime.JSONPb
}

// NewSonicMarshaler creates a new SonicMarshaler with optimal settings.
func NewSonicMarshaler() *SonicMarshaler <span class="cov0" title="0">{
        return &amp;SonicMarshaler{
                JSONPb: runtime.JSONPb{
                        MarshalOptions: protojson.MarshalOptions{
                                UseProtoNames:   true,
                                EmitUnpopulated: false,
                        },
                        UnmarshalOptions: protojson.UnmarshalOptions{
                                DiscardUnknown: true,
                        },
                },
        }
}</span>

// Marshal marshals "v" into JSON using sonic for performance.
// For protobuf messages, it uses protojson with buffer pooling to reduce allocations.
// For non-proto types, it uses sonic for better performance.
func (m *SonicMarshaler) Marshal(v interface{}) ([]byte, error) <span class="cov0" title="0">{
        // For protobuf messages, use protojson with buffer pooling
        if msg, ok := v.(proto.Message); ok </span><span class="cov0" title="0">{
                // Get pooled buffer to reduce allocations
                buf := GetJSONBuffer()
                defer PutJSONBuffer(buf)

                // Marshal using MarshalAppend with pooled buffer
                opts := protojson.MarshalOptions{
                        UseProtoNames:   true,
                        EmitUnpopulated: false,
                }
                data, err := opts.MarshalAppend(buf.Bytes(), msg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Return a copy since the buffer will be returned to pool
                // The caller owns this copy and it won't be affected by buffer reuse
                <span class="cov0" title="0">result := make([]byte, len(data))
                copy(result, data)
                return result, nil</span>
        }

        // For non-proto types, use sonic for better performance
        <span class="cov0" title="0">return sonic.Marshal(v)</span>
}

// Unmarshal unmarshals JSON "data" into "v" using sonic for performance.
func (m *SonicMarshaler) Unmarshal(data []byte, v interface{}) error <span class="cov0" title="0">{
        // For protobuf messages, use protojson to ensure correct unmarshaling
        if msg, ok := v.(proto.Message); ok </span><span class="cov0" title="0">{
                return m.UnmarshalOptions.Unmarshal(data, msg)
        }</span>

        // For non-proto types, use sonic directly
        <span class="cov0" title="0">return sonic.Unmarshal(data, v)</span>
}

// NewDecoder returns a Decoder which reads from "r" using sonic.
func (m *SonicMarshaler) NewDecoder(r io.Reader) runtime.Decoder <span class="cov0" title="0">{
        return &amp;sonicDecoder{reader: r}
}</span>

// NewEncoder returns an Encoder which writes to "w" using sonic.
func (m *SonicMarshaler) NewEncoder(w io.Writer) runtime.Encoder <span class="cov0" title="0">{
        return &amp;sonicEncoder{writer: w}
}</span>

// ContentType returns the Content-Type for JSON.
func (m *SonicMarshaler) ContentType(_ interface{}) string <span class="cov0" title="0">{
        return "application/json"
}</span>

// sonicDecoder wraps sonic's decoder to implement runtime.Decoder
type sonicDecoder struct {
        reader io.Reader
}

func (d *sonicDecoder) Decode(v interface{}) error <span class="cov0" title="0">{
        // Read all data from reader
        data, err := io.ReadAll(d.reader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // For protobuf messages, use protojson for correct unmarshaling
        <span class="cov0" title="0">if msg, ok := v.(proto.Message); ok </span><span class="cov0" title="0">{
                return protojson.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(data, msg)
        }</span>

        // For non-proto types, use sonic
        <span class="cov0" title="0">return sonic.Unmarshal(data, v)</span>
}

// sonicEncoder wraps sonic's encoder to implement runtime.Encoder
type sonicEncoder struct {
        writer io.Writer
}

func (e *sonicEncoder) Encode(v interface{}) error <span class="cov0" title="0">{
        // For protobuf messages, use protojson with buffer pooling
        if msg, ok := v.(proto.Message); ok </span><span class="cov0" title="0">{
                // Get pooled buffer to reduce allocations
                buf := GetJSONBuffer()
                defer PutJSONBuffer(buf)

                // Marshal protobuf to JSON using MarshalAppend (avoids intermediate allocation)
                // MarshalAppend appends JSON to the buffer's existing bytes
                data, err := protojson.MarshalOptions{
                        UseProtoNames:   true,
                        EmitUnpopulated: false,
                }.MarshalAppend(buf.Bytes(), msg)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Write to response (data references buffer's backing array, so this is safe)
                <span class="cov0" title="0">_, err = e.writer.Write(data)
                return err</span>
        }

        // For non-proto types, use sonic directly
        <span class="cov0" title="0">data, err := sonic.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = e.writer.Write(data)
        return err</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright (c) 2023-2025 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.

package common

import (
        "time"

        "go.opentelemetry.io/otel/exporters/zipkin"
        "go.opentelemetry.io/otel/sdk/resource"

        sdkTrace "go.opentelemetry.io/otel/sdk/trace"
        semanticConventions "go.opentelemetry.io/otel/semconv/v1.12.0"
)

func NewTracerProvider(serviceName string) (*sdkTrace.TracerProvider, error) <span class="cov0" title="0">{
        zipkinEndpoint := GetEnv("OTEL_EXPORTER_ZIPKIN_ENDPOINT", "http://localhost:9411/api/v2/spans")
        exporter, err := zipkin.New(zipkinEndpoint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">res := resource.NewWithAttributes(
                semanticConventions.SchemaURL,
                semanticConventions.ServiceNameKey.String(serviceName),
        )

        return sdkTrace.NewTracerProvider(
                sdkTrace.WithBatcher(exporter, sdkTrace.WithBatchTimeout(time.Second*1)),
                sdkTrace.WithResource(res),
                sdkTrace.WithSampler(sdkTrace.AlwaysSample()),
        ), nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright (c) 2023-2025 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.

package common

import (
        "os"
        "strconv"
        "strings"

        "github.com/sirupsen/logrus"
)

func GetEnv(key, fallback string) string <span class="cov0" title="0">{
        if value, ok := os.LookupEnv(key); ok </span><span class="cov0" title="0">{
                return value
        }</span>

        <span class="cov0" title="0">return fallback</span>
}

func GetEnvInt(key string, fallback int) int <span class="cov0" title="0">{
        str := GetEnv(key, strconv.Itoa(fallback))
        val, err := strconv.Atoi(str)
        if err != nil </span><span class="cov0" title="0">{
                return fallback
        }</span>

        <span class="cov0" title="0">return val</span>
}

func GetBasePath() string <span class="cov0" title="0">{
        basePath := os.Getenv("BASE_PATH")
        if basePath == "" </span><span class="cov0" title="0">{
                logrus.Fatalf("BASE_PATH envar is not set or empty")
        }</span>
        <span class="cov0" title="0">if !strings.HasPrefix(basePath, "/") </span><span class="cov0" title="0">{
                logrus.Fatalf("BASE_PATH envar is invalid, no leading '/' found. Valid example: /basePath")
        }</span>

        <span class="cov0" title="0">return basePath</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright (c) 2023-2025 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.

package handler

import (
        "encoding/base64"
        "encoding/json"
        "net/http"
        "strings"

        "github.com/sirupsen/logrus"

        "extend-challenge-service/pkg/cache"
        "extend-challenge-service/pkg/response"

        "github.com/AccelByte/accelbyte-go-sdk/services-api/pkg/utils/auth/validator"
        commonCache "github.com/AccelByte/extend-challenge-common/pkg/cache"
        commonDomain "github.com/AccelByte/extend-challenge-common/pkg/domain"
        commonRepo "github.com/AccelByte/extend-challenge-common/pkg/repository"
)

// OptimizedChallengesHandler provides an optimized HTTP endpoint for GET /v1/challenges
// that uses pre-serialized challenge data to reduce CPU usage by ~40%.
//
// Performance improvements vs standard gRPC handler:
//   - CPU: ~40% reduction (eliminates redundant marshaling of static challenge data)
//   - Memory: ~30% reduction (less allocation overhead from marshaling)
//   - Throughput: Can handle ~400 RPS per instance (vs 200 RPS with standard handler)
//
// This handler bypasses the gRPC layer and returns JSON directly, using:
//  1. Pre-serialized challenge configurations (cached at startup)
//  2. User progress injection (only dynamic data is processed per request)
//  3. Direct JSON response (no protobuf  JSON conversion overhead)
//
// Thread-safety: Safe for concurrent use (all dependencies are thread-safe)
type OptimizedChallengesHandler struct {
        goalCache       commonCache.GoalCache
        repo            commonRepo.GoalRepository
        responseBuilder *response.ChallengeResponseBuilder
        namespace       string
        authEnabled     bool
        tokenValidator  validator.AuthTokenValidator
}

// NewOptimizedChallengesHandler creates a new optimized challenges handler.
//
// Args:
//   - goalCache: Challenge configuration cache
//   - repo: Goal repository for loading user progress
//   - serCache: Serialization cache with pre-serialized challenge JSON
//   - namespace: AGS namespace
//   - authEnabled: Whether JWT authentication is enabled
//   - tokenValidator: Token validator (can be nil if auth is disabled)
//
// Returns:
//   - *OptimizedChallengesHandler: Handler instance
func NewOptimizedChallengesHandler(
        goalCache commonCache.GoalCache,
        repo commonRepo.GoalRepository,
        serCache *cache.SerializedChallengeCache,
        namespace string,
        authEnabled bool,
        tokenValidator validator.AuthTokenValidator,
) *OptimizedChallengesHandler <span class="cov0" title="0">{
        return &amp;OptimizedChallengesHandler{
                goalCache:       goalCache,
                repo:            repo,
                responseBuilder: response.NewChallengeResponseBuilder(serCache),
                namespace:       namespace,
                authEnabled:     authEnabled,
                tokenValidator:  tokenValidator,
        }
}</span>

// ServeHTTP handles GET /v1/challenges with optimized pre-serialization.
//
// Request:
//   - Method: GET
//   - Path: /v1/challenges
//   - Headers: Authorization: Bearer &lt;JWT token&gt; (if auth enabled)
//
// Response:
//   - 200 OK: JSON array of challenges with user progress
//   - 401 Unauthorized: Invalid or missing JWT token
//   - 500 Internal Server Error: Database or cache errors
//
// Performance characteristics:
//   - Average latency: &lt;100ms @ 400 RPS (p95: &lt;150ms)
//   - CPU usage: ~50% @ 400 RPS (vs 101% with standard handler @ 200 RPS)
//   - Memory allocations: ~0.89 MB per request (vs 2.96 MB with standard handler)
func (h *OptimizedChallengesHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Only handle GET requests
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Extract user ID from JWT token or test header
        <span class="cov0" title="0">userID, err := h.extractUserID(r)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithError(err).Error("Failed to extract user ID")
                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "user_id":   userID,
                "namespace": h.namespace,
                "handler":   "optimized",
        }).Info("Getting user challenges (optimized)")

        // Get all challenges from cache
        challenges := h.goalCache.GetAllChallenges()
        if len(challenges) == 0 </span><span class="cov0" title="0">{
                // No challenges configured - return empty response
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)
                _, _ = w.Write([]byte(`{"challenges":[]}`))
                return
        }</span>

        // Get user progress from database
        <span class="cov0" title="0">ctx := r.Context()
        allProgress, err := h.repo.GetUserProgress(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "user_id":   userID,
                        "namespace": h.namespace,
                        "error":     err,
                }).Error("Failed to load user progress")
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        // Build progress map for efficient lookup
        <span class="cov0" title="0">progressMap := make(map[string]*commonDomain.UserGoalProgress, len(allProgress))
        for i := range allProgress </span><span class="cov0" title="0">{
                progressMap[allProgress[i].GoalID] = allProgress[i]
        }</span>

        // Build challenge IDs list
        <span class="cov0" title="0">challengeIDs := make([]string, 0, len(challenges))
        for _, challenge := range challenges </span><span class="cov0" title="0">{
                challengeIDs = append(challengeIDs, challenge.ID)
        }</span>

        // Use optimized response builder to create JSON
        // This uses pre-serialized challenge data and only injects user progress
        <span class="cov0" title="0">responseJSON, err := h.responseBuilder.BuildChallengesResponse(challengeIDs, progressMap)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "user_id":   userID,
                        "namespace": h.namespace,
                        "error":     err,
                }).Error("Failed to build optimized response")
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "user_id":         userID,
                "namespace":       h.namespace,
                "challenge_count": len(challenges),
                "response_size":   len(responseJSON),
                "handler":         "optimized",
        }).Info("Successfully built optimized challenge response")

        // Return JSON response
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        _, _ = w.Write(responseJSON)</span>
}

// extractUserID extracts the user ID from the request.
//
// If authentication is enabled, it validates the JWT token and extracts the user ID.
// If authentication is disabled, it uses the x-mock-user-id header for testing.
//
// Args:
//   - r: HTTP request
//
// Returns:
//   - string: User ID
//   - error: If authentication fails or user ID is missing
func (h *OptimizedChallengesHandler) extractUserID(r *http.Request) (string, error) <span class="cov0" title="0">{
        // Early return for disabled auth (test mode)
        if !h.authEnabled </span><span class="cov0" title="0">{
                userID := r.Header.Get("x-mock-user-id")
                if userID == "" </span><span class="cov0" title="0">{
                        userID = "test-user-id" // Default test user
                }</span>
                <span class="cov0" title="0">return userID, nil</span>
        }

        // Auth enabled - validate JWT token
        <span class="cov0" title="0">authHeader := r.Header.Get("Authorization")
        if authHeader == "" </span><span class="cov0" title="0">{
                return "", &amp;authError{message: "missing authorization header"}
        }</span>

        // Remove "Bearer " prefix
        <span class="cov0" title="0">token := strings.TrimPrefix(authHeader, "Bearer ")
        if token == authHeader </span><span class="cov0" title="0">{
                return "", &amp;authError{message: "invalid authorization header format"}
        }</span>

        // Validate token using AccelByte validator
        <span class="cov0" title="0">if h.tokenValidator == nil </span><span class="cov0" title="0">{
                return "", &amp;authError{message: "token validator not initialized"}
        }</span>

        // Validate token (permission=nil means no specific permission required)
        <span class="cov0" title="0">err := h.tokenValidator.Validate(token, nil, &amp;h.namespace, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", &amp;authError{message: "invalid token", cause: err}
        }</span>

        // Decode JWT claims to extract user ID
        <span class="cov0" title="0">claims, err := decodeJWTClaims(token)
        if err != nil </span><span class="cov0" title="0">{
                return "", &amp;authError{message: "failed to decode JWT claims", cause: err}
        }</span>

        // Extract user ID from claims
        <span class="cov0" title="0">if claims.Sub == "" </span><span class="cov0" title="0">{
                return "", &amp;authError{message: "user ID not found in token claims"}
        }</span>

        <span class="cov0" title="0">return claims.Sub, nil</span>
}

// JWTClaims represents JWT claims structure
type JWTClaims struct {
        Sub       string `json:"sub"`       // Subject (user ID)
        Namespace string `json:"namespace"` // Namespace
        Exp       int64  `json:"exp"`       // Expiration time
}

// decodeJWTClaims decodes JWT token payload to extract claims.
// This is a simplified version of common.decodeJWTClaims that works in HTTP context.
func decodeJWTClaims(token string) (*JWTClaims, error) <span class="cov0" title="0">{
        // JWT format: header.payload.signature
        parts := strings.Split(token, ".")
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return nil, &amp;authError{message: "invalid JWT format"}
        }</span>

        // Decode payload (second part)
        <span class="cov0" title="0">payload, err := base64.RawURLEncoding.DecodeString(parts[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;authError{message: "failed to decode JWT payload", cause: err}
        }</span>

        // Parse JSON claims
        <span class="cov0" title="0">var claims JWTClaims
        if err := json.Unmarshal(payload, &amp;claims); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;authError{message: "failed to parse JWT claims", cause: err}
        }</span>

        <span class="cov0" title="0">return &amp;claims, nil</span>
}

// authError represents an authentication error.
type authError struct {
        message string
        cause   error
}

func (e *authError) Error() string <span class="cov0" title="0">{
        if e.cause != nil </span><span class="cov0" title="0">{
                return e.message + ": " + e.cause.Error()
        }</span>
        <span class="cov0" title="0">return e.message</span>
}

func (e *authError) Unwrap() error <span class="cov0" title="0">{
        return e.cause
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package mapper

import (
        "fmt"
        "sync"
        "time"

        pb "extend-challenge-service/pkg/pb"

        "github.com/AccelByte/extend-challenge-common/pkg/domain"
)

// Object pools for protobuf message reuse (reduces allocations by ~9.3%)
var (
        goalPool = sync.Pool{
                New: func() interface{} <span class="cov7" title="5">{
                        return &amp;pb.Goal{}
                }</span>,
        }

        requirementPool = sync.Pool{
                New: func() interface{} <span class="cov7" title="6">{
                        return &amp;pb.Requirement{}
                }</span>,
        }

        rewardPool = sync.Pool{
                New: func() interface{} <span class="cov8" title="7">{
                        return &amp;pb.Reward{}
                }</span>,
        }

        challengePool = sync.Pool{
                New: func() interface{} <span class="cov5" title="3">{
                        return &amp;pb.Challenge{}
                }</span>,
        }
)

// ChallengeToProto converts domain Challenge to protobuf Challenge (Decision Q2)
// Returns error for validation failures (early validation, Decision Q2a)
// Uses object pooling to reduce allocations
func ChallengeToProto(challenge *domain.Challenge, userProgress map[string]*domain.UserGoalProgress) (*pb.Challenge, error) <span class="cov6" title="4">{
        if challenge == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("challenge cannot be nil")
        }</span>

        // Get from pool and reset
        <span class="cov5" title="3">pbChallenge := challengePool.Get().(*pb.Challenge)
        pbChallenge.ChallengeId = challenge.ID
        pbChallenge.Name = challenge.Name
        pbChallenge.Description = challenge.Description
        // Reuse slice capacity if possible
        if cap(pbChallenge.Goals) &gt;= len(challenge.Goals) </span><span class="cov3" title="2">{
                pbChallenge.Goals = pbChallenge.Goals[:0]
        }</span> else<span class="cov1" title="1"> {
                pbChallenge.Goals = make([]*pb.Goal, 0, len(challenge.Goals))
        }</span>

        <span class="cov5" title="3">for _, goal := range challenge.Goals </span><span class="cov1" title="1">{
                pbGoal, err := GoalToProto(goal, userProgress)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to convert goal %s: %w", goal.ID, err)
                }</span>
                <span class="cov1" title="1">pbChallenge.Goals = append(pbChallenge.Goals, pbGoal)</span>
        }

        <span class="cov5" title="3">return pbChallenge, nil</span>
}

// GoalToProto converts domain Goal to protobuf Goal with user progress (Decision Q2)
// Computes progress for daily goals from completed_at timestamp (Decision FQ2)
// Uses object pooling to reduce allocations
func GoalToProto(goal *domain.Goal, userProgress map[string]*domain.UserGoalProgress) (*pb.Goal, error) <span class="cov7" title="6">{
        if goal == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("goal cannot be nil")
        }</span>

        // Get user progress for this goal (if exists)
        <span class="cov7" title="5">progress, exists := userProgress[goal.ID]

        // Convert requirement
        pbRequirement, err := RequirementToProto(&amp;goal.Requirement)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert requirement: %w", err)
        }</span>

        // Convert reward
        <span class="cov7" title="5">pbReward, err := RewardToProto(&amp;goal.Reward)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert reward: %w", err)
        }</span>

        // Get from pool and reset
        <span class="cov7" title="5">pbGoal := goalPool.Get().(*pb.Goal)
        pbGoal.GoalId = goal.ID
        pbGoal.Name = goal.Name
        pbGoal.Description = goal.Description
        pbGoal.Requirement = pbRequirement
        pbGoal.Reward = pbReward
        // Reuse slice capacity for prerequisites
        if cap(pbGoal.Prerequisites) &gt;= len(goal.Prerequisites) </span><span class="cov5" title="3">{
                pbGoal.Prerequisites = pbGoal.Prerequisites[:0]
        }</span> else<span class="cov3" title="2"> {
                pbGoal.Prerequisites = make([]string, 0, len(goal.Prerequisites))
        }</span>
        <span class="cov7" title="5">pbGoal.Prerequisites = append(pbGoal.Prerequisites, goal.Prerequisites...)

        // Set progress fields from user progress (if exists)
        if exists &amp;&amp; progress != nil </span><span class="cov5" title="3">{
                pbGoal.Progress = ComputeProgress(goal, progress)
                pbGoal.Status = string(progress.Status)
                pbGoal.Locked = false // Will be computed by PrerequisiteChecker

                // Format timestamps using AppendFormat to reuse buffer (reduces allocations)
                var buf []byte
                if progress.CompletedAt != nil &amp;&amp; !progress.CompletedAt.IsZero() </span><span class="cov3" title="2">{
                        buf = progress.CompletedAt.UTC().AppendFormat(buf[:0], time.RFC3339)
                        pbGoal.CompletedAt = string(buf)
                }</span>
                <span class="cov5" title="3">if progress.ClaimedAt != nil &amp;&amp; !progress.ClaimedAt.IsZero() </span><span class="cov1" title="1">{
                        buf = progress.ClaimedAt.UTC().AppendFormat(buf[:0], time.RFC3339)
                        pbGoal.ClaimedAt = string(buf)
                }</span>
        } else<span class="cov3" title="2"> {
                // No progress yet
                pbGoal.Progress = 0
                pbGoal.Status = string(domain.GoalStatusNotStarted)
                pbGoal.Locked = len(goal.Prerequisites) &gt; 0 // Will be refined by PrerequisiteChecker
                pbGoal.CompletedAt = ""
                pbGoal.ClaimedAt = ""
        }</span>

        <span class="cov7" title="5">return pbGoal, nil</span>
}

// ComputeProgress computes the progress value for display (Decision FQ2)
// For daily goals: Returns 1 if completed today, 0 otherwise
// For other goals: Returns the actual progress value from DB
func ComputeProgress(goal *domain.Goal, progress *domain.UserGoalProgress) int32 <span class="cov10" title="11">{
        if goal == nil || progress == nil </span><span class="cov5" title="3">{
                return 0
        }</span>

        // Daily goals: Check if completed today (Decision Q9, FQ2)
        <span class="cov8" title="8">if goal.Type == domain.GoalTypeDaily </span><span class="cov5" title="3">{
                // If completed_at is today (UTC), show progress = 1
                // Compare dates directly without string allocation
                if progress.CompletedAt != nil &amp;&amp; !progress.CompletedAt.IsZero() </span><span class="cov3" title="2">{
                        cy, cm, cd := progress.CompletedAt.UTC().Date()
                        ty, tm, td := time.Now().UTC().Date()
                        if cy == ty &amp;&amp; cm == tm &amp;&amp; cd == td </span><span class="cov1" title="1">{
                                return 1
                        }</span>
                }
                // Not completed today
                <span class="cov3" title="2">return 0</span>
        }

        // Absolute and increment goals: Return actual progress from DB
        // #nosec G115 - Progress values are validated at config load time, safe to convert
        <span class="cov7" title="5">return int32(progress.Progress)</span>
}

// RequirementToProto converts domain Requirement to protobuf Requirement
// Uses object pooling to reduce allocations
func RequirementToProto(req *domain.Requirement) (*pb.Requirement, error) <span class="cov8" title="7">{
        if req == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("requirement cannot be nil")
        }</span>

        // Get from pool and reset
        <span class="cov7" title="6">pbReq := requirementPool.Get().(*pb.Requirement)
        pbReq.StatCode = req.StatCode
        pbReq.Operator = req.Operator
        // #nosec G115 - Target values are validated at config load time, safe to convert
        pbReq.TargetValue = int32(req.TargetValue)

        return pbReq, nil</span>
}

// RewardToProto converts domain Reward to protobuf Reward
// Uses object pooling to reduce allocations
func RewardToProto(reward *domain.Reward) (*pb.Reward, error) <span class="cov9" title="9">{
        if reward == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("reward cannot be nil")
        }</span>

        // Validate reward type (Decision Q2a: early validation)
        <span class="cov8" title="8">if reward.Type != string(domain.RewardTypeItem) &amp;&amp; reward.Type != string(domain.RewardTypeWallet) </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid reward type: %s (must be ITEM or WALLET)", reward.Type)
        }</span>

        // Get from pool and reset
        <span class="cov8" title="7">pbReward := rewardPool.Get().(*pb.Reward)
        pbReward.Type = reward.Type
        pbReward.RewardId = reward.RewardID
        // #nosec G115 - Reward quantities are validated at config load time, safe to convert
        pbReward.Quantity = int32(reward.Quantity)

        return pbReward, nil</span>
}

// ChallengesToProto converts a slice of domain Challenges to protobuf Challenges
func ChallengesToProto(challenges []*domain.Challenge, userProgress map[string]*domain.UserGoalProgress) ([]*pb.Challenge, error) <span class="cov5" title="3">{
        if challenges == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("challenges cannot be nil")
        }</span>

        <span class="cov3" title="2">pbChallenges := make([]*pb.Challenge, 0, len(challenges))
        for _, challenge := range challenges </span><span class="cov3" title="2">{
                pbChallenge, err := ChallengeToProto(challenge, userProgress)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to convert challenge %s: %w", challenge.ID, err)
                }</span>
                <span class="cov3" title="2">pbChallenges = append(pbChallenges, pbChallenge)</span>
        }

        <span class="cov3" title="2">return pbChallenges, nil</span>
}

// ReturnChallengeToPool returns a protobuf Challenge and all nested objects back to their pools.
// Must be called after the challenge has been serialized to JSON.
func ReturnChallengeToPool(challenge *pb.Challenge) <span class="cov0" title="0">{
        if challenge == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Return nested goals first
        <span class="cov0" title="0">for _, goal := range challenge.Goals </span><span class="cov0" title="0">{
                ReturnGoalToPool(goal)
        }</span>

        // Return the challenge itself
        <span class="cov0" title="0">challengePool.Put(challenge)</span>
}

// ReturnGoalToPool returns a protobuf Goal and its nested objects back to their pools.
// Must be called after the goal has been serialized to JSON.
func ReturnGoalToPool(goal *pb.Goal) <span class="cov0" title="0">{
        if goal == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Return nested objects first
        <span class="cov0" title="0">if goal.Requirement != nil </span><span class="cov0" title="0">{
                requirementPool.Put(goal.Requirement)
        }</span>
        <span class="cov0" title="0">if goal.Reward != nil </span><span class="cov0" title="0">{
                rewardPool.Put(goal.Reward)
        }</span>

        // Return the goal itself
        <span class="cov0" title="0">goalPool.Put(goal)</span>
}

// ReturnChallengesToPool returns a slice of protobuf Challenges back to their pools.
// Must be called after all challenges have been serialized to JSON.
func ReturnChallengesToPool(challenges []*pb.Challenge) <span class="cov0" title="0">{
        for _, challenge := range challenges </span><span class="cov0" title="0">{
                ReturnChallengeToPool(challenge)
        }</span>
}

// ReturnRewardToPool returns a protobuf Reward back to the pool.
// Must be called after the reward has been serialized to JSON.
func ReturnRewardToPool(reward *pb.Reward) <span class="cov0" title="0">{
        if reward == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">rewardPool.Put(reward)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package mapper

import (
        "errors"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// Common domain error types (Decision Q6)
var (
        ErrGoalNotFound        = errors.New("goal not found")
        ErrGoalNotCompleted    = errors.New("goal not completed")
        ErrGoalAlreadyClaimed  = errors.New("goal already claimed")
        ErrPrerequisitesNotMet = errors.New("prerequisites not completed")
        ErrRewardGrantFailed   = errors.New("failed to grant reward")
        ErrDatabaseError       = errors.New("database error")
        ErrInvalidGoalType     = errors.New("invalid goal type")
        ErrInvalidRewardType   = errors.New("invalid reward type")
        ErrChallengeNotFound   = errors.New("challenge not found")
)

// Structured domain error types
type GoalNotFoundError struct {
        GoalID      string
        ChallengeID string
}

func (e *GoalNotFoundError) Error() string <span class="cov1" title="1">{
        return "goal not found: " + e.GoalID
}</span>

type GoalNotCompletedError struct {
        GoalID string
        Status string
}

func (e *GoalNotCompletedError) Error() string <span class="cov3" title="2">{
        return "goal not completed: " + e.GoalID + " (status: " + e.Status + ")"
}</span>

type GoalAlreadyClaimedError struct {
        GoalID    string
        ClaimedAt string
}

func (e *GoalAlreadyClaimedError) Error() string <span class="cov3" title="2">{
        return "goal already claimed: " + e.GoalID + " at " + e.ClaimedAt
}</span>

type PrerequisitesNotMetError struct {
        GoalID         string
        MissingGoalIDs []string
}

func (e *PrerequisitesNotMetError) Error() string <span class="cov1" title="1">{
        return "prerequisites not met for goal: " + e.GoalID
}</span>

type RewardGrantError struct {
        GoalID string
        Err    error
}

func (e *RewardGrantError) Error() string <span class="cov3" title="2">{
        return "failed to grant reward for goal " + e.GoalID + ": " + e.Err.Error()
}</span>

// MapErrorToGRPCStatus converts domain errors to gRPC status codes (Decision Q6)
func MapErrorToGRPCStatus(err error) error <span class="cov10" title="16">{
        if err == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Check for structured error types
        <span class="cov9" title="15">var goalNotFound *GoalNotFoundError
        if errors.As(err, &amp;goalNotFound) </span><span class="cov1" title="1">{
                return status.Errorf(codes.NotFound,
                        "Goal not found or removed from config (goal_id: %s, challenge_id: %s)",
                        goalNotFound.GoalID, goalNotFound.ChallengeID)
        }</span>

        <span class="cov9" title="14">var goalNotCompleted *GoalNotCompletedError
        if errors.As(err, &amp;goalNotCompleted) </span><span class="cov1" title="1">{
                return status.Errorf(codes.FailedPrecondition,
                        "Goal not completed. Please wait 1 second and try again. (goal_id: %s, status: %s)",
                        goalNotCompleted.GoalID, goalNotCompleted.Status)
        }</span>

        <span class="cov9" title="13">var goalAlreadyClaimed *GoalAlreadyClaimedError
        if errors.As(err, &amp;goalAlreadyClaimed) </span><span class="cov1" title="1">{
                return status.Errorf(codes.AlreadyExists,
                        "Reward has already been claimed (goal_id: %s, claimed_at: %s)",
                        goalAlreadyClaimed.GoalID, goalAlreadyClaimed.ClaimedAt)
        }</span>

        <span class="cov9" title="12">var prerequisitesNotMet *PrerequisitesNotMetError
        if errors.As(err, &amp;prerequisitesNotMet) </span><span class="cov1" title="1">{
                return status.Errorf(codes.FailedPrecondition,
                        "Prerequisites not completed (goal_id: %s)",
                        prerequisitesNotMet.GoalID)
        }</span>

        <span class="cov8" title="11">var rewardGrantErr *RewardGrantError
        if errors.As(err, &amp;rewardGrantErr) </span><span class="cov1" title="1">{
                return status.Errorf(codes.Internal,
                        "Failed to grant reward via Platform Service after 3 retries (goal_id: %s)",
                        rewardGrantErr.GoalID)
        }</span>

        // Check for sentinel errors
        <span class="cov8" title="10">switch </span>{
        case errors.Is(err, ErrGoalNotFound):<span class="cov1" title="1">
                return status.Error(codes.NotFound, "Goal not found or removed from config")</span>
        case errors.Is(err, ErrGoalNotCompleted):<span class="cov1" title="1">
                return status.Error(codes.FailedPrecondition, "Goal not completed. Please wait 1 second and try again.")</span>
        case errors.Is(err, ErrGoalAlreadyClaimed):<span class="cov1" title="1">
                return status.Error(codes.AlreadyExists, "Reward has already been claimed")</span>
        case errors.Is(err, ErrPrerequisitesNotMet):<span class="cov1" title="1">
                return status.Error(codes.FailedPrecondition, "Prerequisites not completed")</span>
        case errors.Is(err, ErrRewardGrantFailed):<span class="cov1" title="1">
                return status.Error(codes.Internal, "Failed to grant reward via Platform Service after 3 retries")</span>
        case errors.Is(err, ErrDatabaseError):<span class="cov1" title="1">
                return status.Error(codes.Internal, "Database error occurred")</span>
        case errors.Is(err, ErrInvalidGoalType):<span class="cov1" title="1">
                return status.Error(codes.InvalidArgument, "Invalid goal type")</span>
        case errors.Is(err, ErrInvalidRewardType):<span class="cov1" title="1">
                return status.Error(codes.InvalidArgument, "Invalid reward type")</span>
        case errors.Is(err, ErrChallengeNotFound):<span class="cov1" title="1">
                return status.Error(codes.NotFound, "Challenge not found")</span>
        }

        // Default to internal error for unknown errors
        <span class="cov1" title="1">return status.Error(codes.Internal, "Internal server error")</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright (c) 2025 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.

package migrations

import (
        "database/sql"
        "fmt"

        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
)

// RunMigrations applies all pending database migrations
// migrationsPath should be a file:// URL to the migrations directory
// Example: "file:///app/migrations" (production) or "file://./migrations" (local dev)
func RunMigrations(db *sql.DB, migrationsPath string) error <span class="cov0" title="0">{
        // Create postgres driver instance
        driver, err := postgres.WithInstance(db, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrate driver: %w", err)
        }</span>

        // Create migrate instance
        <span class="cov0" title="0">m, err := migrate.NewWithDatabaseInstance(
                migrationsPath,
                "postgres",
                driver,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrate instance: %w", err)
        }</span>

        // Apply all up migrations
        <span class="cov0" title="0">if err := m.Up(); err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply migrations: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright (c) 2015, Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.30.0
//         protoc        v3.21.9
// source: google/api/annotations.proto

package annotations

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        descriptorpb "google.golang.org/protobuf/types/descriptorpb"
        reflect "reflect"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

var file_google_api_annotations_proto_extTypes = []protoimpl.ExtensionInfo{
        {
                ExtendedType:  (*descriptorpb.MethodOptions)(nil),
                ExtensionType: (*HttpRule)(nil),
                Field:         72295728,
                Name:          "google.api.http",
                Tag:           "bytes,72295728,opt,name=http",
                Filename:      "google/api/annotations.proto",
        },
}

// Extension fields to descriptorpb.MethodOptions.
var (
        // See `HttpRule`.
        //
        // optional google.api.HttpRule http = 72295728;
        E_Http = &amp;file_google_api_annotations_proto_extTypes[0]
)

var File_google_api_annotations_proto protoreflect.FileDescriptor

var file_google_api_annotations_proto_rawDesc = []byte{
        0x0a, 0x1c, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x61, 0x6e, 0x6e,
        0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a,
        0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x1a, 0x15, 0x67, 0x6f, 0x6f, 0x67,
        0x6c, 0x65, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x68, 0x74, 0x74, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x1a, 0x20, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
        0x75, 0x66, 0x2f, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x3a, 0x4b, 0x0a, 0x04, 0x68, 0x74, 0x74, 0x70, 0x12, 0x1e, 0x2e, 0x67, 0x6f,
        0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x4d, 0x65,
        0x74, 0x68, 0x6f, 0x64, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xb0, 0xca, 0xbc, 0x22,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x61, 0x70,
        0x69, 0x2e, 0x48, 0x74, 0x74, 0x70, 0x52, 0x75, 0x6c, 0x65, 0x52, 0x04, 0x68, 0x74, 0x74, 0x70,
        0x42, 0x6e, 0x0a, 0x0e, 0x63, 0x6f, 0x6d, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x61,
        0x70, 0x69, 0x42, 0x10, 0x41, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x50,
        0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x41, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x67,
        0x6f, 0x6c, 0x61, 0x6e, 0x67, 0x2e, 0x6f, 0x72, 0x67, 0x2f, 0x67, 0x65, 0x6e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x2f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x61, 0x70, 0x69, 0x73, 0x2f, 0x61, 0x70,
        0x69, 0x2f, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x3b, 0x61, 0x6e,
        0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0xa2, 0x02, 0x04, 0x47, 0x41, 0x50, 0x49,
        0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var file_google_api_annotations_proto_goTypes = []interface{}{
        (*descriptorpb.MethodOptions)(nil), // 0: google.protobuf.MethodOptions
        (*HttpRule)(nil),                   // 1: google.api.HttpRule
}
var file_google_api_annotations_proto_depIdxs = []int32{
        0, // 0: google.api.http:extendee -&gt; google.protobuf.MethodOptions
        1, // 1: google.api.http:type_name -&gt; google.api.HttpRule
        2, // [2:2] is the sub-list for method output_type
        2, // [2:2] is the sub-list for method input_type
        1, // [1:2] is the sub-list for extension type_name
        0, // [0:1] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_google_api_annotations_proto_init() }</span>
func file_google_api_annotations_proto_init() <span class="cov0" title="0">{
        if File_google_api_annotations_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">file_google_api_http_proto_init()
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_google_api_annotations_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   0,
                        NumExtensions: 1,
                        NumServices:   0,
                },
                GoTypes:           file_google_api_annotations_proto_goTypes,
                DependencyIndexes: file_google_api_annotations_proto_depIdxs,
                ExtensionInfos:    file_google_api_annotations_proto_extTypes,
        }.Build()
        File_google_api_annotations_proto = out.File
        file_google_api_annotations_proto_rawDesc = nil
        file_google_api_annotations_proto_goTypes = nil
        file_google_api_annotations_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.30.0
//         protoc        v3.21.9
// source: google/api/http.proto

package annotations

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Defines the HTTP configuration for an API service. It contains a list of
// [HttpRule][google.api.HttpRule], each specifying the mapping of an RPC method
// to one or more HTTP REST API methods.
type Http struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // A list of HTTP configuration rules that apply to individual API methods.
        //
        // **NOTE:** All service configuration rules follow "last one wins" order.
        Rules []*HttpRule `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
        // When set to true, URL path parameters will be fully URI-decoded except in
        // cases of single segment matches in reserved expansion, where "%2F" will be
        // left encoded.
        //
        // The default behavior is to not decode RFC 6570 reserved characters in multi
        // segment matches.
        FullyDecodeReservedExpansion bool `protobuf:"varint,2,opt,name=fully_decode_reserved_expansion,json=fullyDecodeReservedExpansion,proto3" json:"fully_decode_reserved_expansion,omitempty"`
}

func (x *Http) Reset() <span class="cov0" title="0">{
        *x = Http{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_google_api_http_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Http) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Http) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Http) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_google_api_http_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Http.ProtoReflect.Descriptor instead.
func (*Http) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_google_api_http_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Http) GetRules() []*HttpRule <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rules
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Http) GetFullyDecodeReservedExpansion() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FullyDecodeReservedExpansion
        }</span>
        <span class="cov0" title="0">return false</span>
}

// # gRPC Transcoding
//
// gRPC Transcoding is a feature for mapping between a gRPC method and one or
// more HTTP REST endpoints. It allows developers to build a single API service
// that supports both gRPC APIs and REST APIs. Many systems, including [Google
// APIs](https://github.com/googleapis/googleapis),
// [Cloud Endpoints](https://cloud.google.com/endpoints), [gRPC
// Gateway](https://github.com/grpc-ecosystem/grpc-gateway),
// and [Envoy](https://github.com/envoyproxy/envoy) proxy support this feature
// and use it for large scale production services.
//
// `HttpRule` defines the schema of the gRPC/REST mapping. The mapping specifies
// how different portions of the gRPC request message are mapped to the URL
// path, URL query parameters, and HTTP request body. It also controls how the
// gRPC response message is mapped to the HTTP response body. `HttpRule` is
// typically specified as an `google.api.http` annotation on the gRPC method.
//
// Each mapping specifies a URL path template and an HTTP method. The path
// template may refer to one or more fields in the gRPC request message, as long
// as each field is a non-repeated field with a primitive (non-message) type.
// The path template controls how fields of the request message are mapped to
// the URL path.
//
// Example:
//
//        service Messaging {
//          rpc GetMessage(GetMessageRequest) returns (Message) {
//            option (google.api.http) = {
//                get: "/v1/{name=messages/*}"
//            };
//          }
//        }
//        message GetMessageRequest {
//          string name = 1; // Mapped to URL path.
//        }
//        message Message {
//          string text = 1; // The resource content.
//        }
//
// This enables an HTTP REST to gRPC mapping as below:
//
// HTTP | gRPC
// -----|-----
// `GET /v1/messages/123456`  | `GetMessage(name: "messages/123456")`
//
// Any fields in the request message which are not bound by the path template
// automatically become HTTP query parameters if there is no HTTP request body.
// For example:
//
//        service Messaging {
//          rpc GetMessage(GetMessageRequest) returns (Message) {
//            option (google.api.http) = {
//                get:"/v1/messages/{message_id}"
//            };
//          }
//        }
//        message GetMessageRequest {
//          message SubMessage {
//            string subfield = 1;
//          }
//          string message_id = 1; // Mapped to URL path.
//          int64 revision = 2;    // Mapped to URL query parameter `revision`.
//          SubMessage sub = 3;    // Mapped to URL query parameter `sub.subfield`.
//        }
//
// This enables a HTTP JSON to RPC mapping as below:
//
// HTTP | gRPC
// -----|-----
// `GET /v1/messages/123456?revision=2&amp;sub.subfield=foo` |
// `GetMessage(message_id: "123456" revision: 2 sub: SubMessage(subfield:
// "foo"))`
//
// Note that fields which are mapped to URL query parameters must have a
// primitive type or a repeated primitive type or a non-repeated message type.
// In the case of a repeated type, the parameter can be repeated in the URL
// as `...?param=A&amp;param=B`. In the case of a message type, each field of the
// message is mapped to a separate parameter, such as
// `...?foo.a=A&amp;foo.b=B&amp;foo.c=C`.
//
// For HTTP methods that allow a request body, the `body` field
// specifies the mapping. Consider a REST update method on the
// message resource collection:
//
//        service Messaging {
//          rpc UpdateMessage(UpdateMessageRequest) returns (Message) {
//            option (google.api.http) = {
//              patch: "/v1/messages/{message_id}"
//              body: "message"
//            };
//          }
//        }
//        message UpdateMessageRequest {
//          string message_id = 1; // mapped to the URL
//          Message message = 2;   // mapped to the body
//        }
//
// The following HTTP JSON to RPC mapping is enabled, where the
// representation of the JSON in the request body is determined by
// protos JSON encoding:
//
// HTTP | gRPC
// -----|-----
// `PATCH /v1/messages/123456 { "text": "Hi!" }` | `UpdateMessage(message_id:
// "123456" message { text: "Hi!" })`
//
// The special name `*` can be used in the body mapping to define that
// every field not bound by the path template should be mapped to the
// request body.  This enables the following alternative definition of
// the update method:
//
//        service Messaging {
//          rpc UpdateMessage(Message) returns (Message) {
//            option (google.api.http) = {
//              patch: "/v1/messages/{message_id}"
//              body: "*"
//            };
//          }
//        }
//        message Message {
//          string message_id = 1;
//          string text = 2;
//        }
//
// The following HTTP JSON to RPC mapping is enabled:
//
// HTTP | gRPC
// -----|-----
// `PATCH /v1/messages/123456 { "text": "Hi!" }` | `UpdateMessage(message_id:
// "123456" text: "Hi!")`
//
// Note that when using `*` in the body mapping, it is not possible to
// have HTTP parameters, as all fields not bound by the path end in
// the body. This makes this option more rarely used in practice when
// defining REST APIs. The common usage of `*` is in custom methods
// which don't use the URL at all for transferring data.
//
// It is possible to define multiple HTTP methods for one RPC by using
// the `additional_bindings` option. Example:
//
//        service Messaging {
//          rpc GetMessage(GetMessageRequest) returns (Message) {
//            option (google.api.http) = {
//              get: "/v1/messages/{message_id}"
//              additional_bindings {
//                get: "/v1/users/{user_id}/messages/{message_id}"
//              }
//            };
//          }
//        }
//        message GetMessageRequest {
//          string message_id = 1;
//          string user_id = 2;
//        }
//
// This enables the following two alternative HTTP JSON to RPC mappings:
//
// HTTP | gRPC
// -----|-----
// `GET /v1/messages/123456` | `GetMessage(message_id: "123456")`
// `GET /v1/users/me/messages/123456` | `GetMessage(user_id: "me" message_id:
// "123456")`
//
// ## Rules for HTTP mapping
//
//  1. Leaf request fields (recursive expansion nested messages in the request
//     message) are classified into three categories:
//     - Fields referred by the path template. They are passed via the URL path.
//     - Fields referred by the [HttpRule.body][google.api.HttpRule.body]. They are passed via the HTTP
//     request body.
//     - All other fields are passed via the URL query parameters, and the
//     parameter name is the field path in the request message. A repeated
//     field can be represented as multiple query parameters under the same
//     name.
//  2. If [HttpRule.body][google.api.HttpRule.body] is "*", there is no URL query parameter, all fields
//     are passed via URL path and HTTP request body.
//  3. If [HttpRule.body][google.api.HttpRule.body] is omitted, there is no HTTP request body, all
//     fields are passed via URL path and URL query parameters.
//
// ### Path template syntax
//
//        Template = "/" Segments [ Verb ] ;
//        Segments = Segment { "/" Segment } ;
//        Segment  = "*" | "**" | LITERAL | Variable ;
//        Variable = "{" FieldPath [ "=" Segments ] "}" ;
//        FieldPath = IDENT { "." IDENT } ;
//        Verb     = ":" LITERAL ;
//
// The syntax `*` matches a single URL path segment. The syntax `**` matches
// zero or more URL path segments, which must be the last part of the URL path
// except the `Verb`.
//
// The syntax `Variable` matches part of the URL path as specified by its
// template. A variable template must not contain other variables. If a variable
// matches a single path segment, its template may be omitted, e.g. `{var}`
// is equivalent to `{var=*}`.
//
// The syntax `LITERAL` matches literal text in the URL path. If the `LITERAL`
// contains any reserved character, such characters should be percent-encoded
// before the matching.
//
// If a variable contains exactly one path segment, such as `"{var}"` or
// `"{var=*}"`, when such a variable is expanded into a URL path on the client
// side, all characters except `[-_.~0-9a-zA-Z]` are percent-encoded. The
// server side does the reverse decoding. Such variables show up in the
// [Discovery
// Document](https://developers.google.com/discovery/v1/reference/apis) as
// `{var}`.
//
// If a variable contains multiple path segments, such as `"{var=foo/*}"`
// or `"{var=**}"`, when such a variable is expanded into a URL path on the
// client side, all characters except `[-_.~/0-9a-zA-Z]` are percent-encoded.
// The server side does the reverse decoding, except "%2F" and "%2f" are left
// unchanged. Such variables show up in the
// [Discovery
// Document](https://developers.google.com/discovery/v1/reference/apis) as
// `{+var}`.
//
// ## Using gRPC API Service Configuration
//
// gRPC API Service Configuration (service config) is a configuration language
// for configuring a gRPC service to become a user-facing product. The
// service config is simply the YAML representation of the `google.api.Service`
// proto message.
//
// As an alternative to annotating your proto file, you can configure gRPC
// transcoding in your service config YAML files. You do this by specifying a
// `HttpRule` that maps the gRPC method to a REST endpoint, achieving the same
// effect as the proto annotation. This can be particularly useful if you
// have a proto that is reused in multiple services. Note that any transcoding
// specified in the service config will override any matching transcoding
// configuration in the proto.
//
// Example:
//
//        http:
//          rules:
//            # Selects a gRPC method and applies HttpRule to it.
//            - selector: example.v1.Messaging.GetMessage
//              get: /v1/messages/{message_id}/{sub.subfield}
//
// ## Special notes
//
// When gRPC Transcoding is used to map a gRPC to JSON REST endpoints, the
// proto to JSON conversion must follow the [proto3
// specification](https://developers.google.com/protocol-buffers/docs/proto3#json).
//
// While the single segment variable follows the semantics of
// [RFC 6570](https://tools.ietf.org/html/rfc6570) Section 3.2.2 Simple String
// Expansion, the multi segment variable **does not** follow RFC 6570 Section
// 3.2.3 Reserved Expansion. The reason is that the Reserved Expansion
// does not expand special characters like `?` and `#`, which would lead
// to invalid URLs. As the result, gRPC Transcoding uses a custom encoding
// for multi segment variables.
//
// The path variables **must not** refer to any repeated or mapped field,
// because client libraries are not capable of handling such variable expansion.
//
// The path variables **must not** capture the leading "/" character. The reason
// is that the most common use case "{var}" does not capture the leading "/"
// character. For consistency, all path variables must share the same behavior.
//
// Repeated message fields must not be mapped to URL query parameters, because
// no client library can support such complicated mapping.
//
// If an API needs to use a JSON array for request or response body, it can map
// the request or response body to a repeated field. However, some gRPC
// Transcoding implementations may not support this feature.
type HttpRule struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Selects a method to which this rule applies.
        //
        // Refer to [selector][google.api.DocumentationRule.selector] for syntax details.
        Selector string `protobuf:"bytes,1,opt,name=selector,proto3" json:"selector,omitempty"`
        // Determines the URL pattern is matched by this rules. This pattern can be
        // used with any of the {get|put|post|delete|patch} methods. A custom method
        // can be defined using the 'custom' field.
        //
        // Types that are assignable to Pattern:
        //
        //        *HttpRule_Get
        //        *HttpRule_Put
        //        *HttpRule_Post
        //        *HttpRule_Delete
        //        *HttpRule_Patch
        //        *HttpRule_Custom
        Pattern isHttpRule_Pattern `protobuf_oneof:"pattern"`
        // The name of the request field whose value is mapped to the HTTP request
        // body, or `*` for mapping all request fields not captured by the path
        // pattern to the HTTP body, or omitted for not having any HTTP request body.
        //
        // NOTE: the referred field must be present at the top-level of the request
        // message type.
        Body string `protobuf:"bytes,7,opt,name=body,proto3" json:"body,omitempty"`
        // Optional. The name of the response field whose value is mapped to the HTTP
        // response body. When omitted, the entire response message will be used
        // as the HTTP response body.
        //
        // NOTE: The referred field must be present at the top-level of the response
        // message type.
        ResponseBody string `protobuf:"bytes,12,opt,name=response_body,json=responseBody,proto3" json:"response_body,omitempty"`
        // Additional HTTP bindings for the selector. Nested bindings must
        // not contain an `additional_bindings` field themselves (that is,
        // the nesting may only be one level deep).
        AdditionalBindings []*HttpRule `protobuf:"bytes,11,rep,name=additional_bindings,json=additionalBindings,proto3" json:"additional_bindings,omitempty"`
}

func (x *HttpRule) Reset() <span class="cov0" title="0">{
        *x = HttpRule{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_google_api_http_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *HttpRule) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*HttpRule) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *HttpRule) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_google_api_http_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use HttpRule.ProtoReflect.Descriptor instead.
func (*HttpRule) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_google_api_http_proto_rawDescGZIP(), []int{1}
}</span>

func (x *HttpRule) GetSelector() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Selector
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *HttpRule) GetPattern() isHttpRule_Pattern <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Pattern
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *HttpRule) GetGet() string <span class="cov0" title="0">{
        if x, ok := x.GetPattern().(*HttpRule_Get); ok </span><span class="cov0" title="0">{
                return x.Get
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HttpRule) GetPut() string <span class="cov0" title="0">{
        if x, ok := x.GetPattern().(*HttpRule_Put); ok </span><span class="cov0" title="0">{
                return x.Put
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HttpRule) GetPost() string <span class="cov0" title="0">{
        if x, ok := x.GetPattern().(*HttpRule_Post); ok </span><span class="cov0" title="0">{
                return x.Post
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HttpRule) GetDelete() string <span class="cov0" title="0">{
        if x, ok := x.GetPattern().(*HttpRule_Delete); ok </span><span class="cov0" title="0">{
                return x.Delete
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HttpRule) GetPatch() string <span class="cov0" title="0">{
        if x, ok := x.GetPattern().(*HttpRule_Patch); ok </span><span class="cov0" title="0">{
                return x.Patch
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HttpRule) GetCustom() *CustomHttpPattern <span class="cov0" title="0">{
        if x, ok := x.GetPattern().(*HttpRule_Custom); ok </span><span class="cov0" title="0">{
                return x.Custom
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *HttpRule) GetBody() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Body
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HttpRule) GetResponseBody() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ResponseBody
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HttpRule) GetAdditionalBindings() []*HttpRule <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AdditionalBindings
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isHttpRule_Pattern interface {
        isHttpRule_Pattern()
}

type HttpRule_Get struct {
        // Maps to HTTP GET. Used for listing and getting information about
        // resources.
        Get string `protobuf:"bytes,2,opt,name=get,proto3,oneof"`
}

type HttpRule_Put struct {
        // Maps to HTTP PUT. Used for replacing a resource.
        Put string `protobuf:"bytes,3,opt,name=put,proto3,oneof"`
}

type HttpRule_Post struct {
        // Maps to HTTP POST. Used for creating a resource or performing an action.
        Post string `protobuf:"bytes,4,opt,name=post,proto3,oneof"`
}

type HttpRule_Delete struct {
        // Maps to HTTP DELETE. Used for deleting a resource.
        Delete string `protobuf:"bytes,5,opt,name=delete,proto3,oneof"`
}

type HttpRule_Patch struct {
        // Maps to HTTP PATCH. Used for updating a resource.
        Patch string `protobuf:"bytes,6,opt,name=patch,proto3,oneof"`
}

type HttpRule_Custom struct {
        // The custom pattern is used for specifying an HTTP method that is not
        // included in the `pattern` field, such as HEAD, or "*" to leave the
        // HTTP method unspecified for this rule. The wild-card rule is useful
        // for services that provide content to Web (HTML) clients.
        Custom *CustomHttpPattern `protobuf:"bytes,8,opt,name=custom,proto3,oneof"`
}

func (*HttpRule_Get) isHttpRule_Pattern() {<span class="cov0" title="0">}</span>

func (*HttpRule_Put) isHttpRule_Pattern() {<span class="cov0" title="0">}</span>

func (*HttpRule_Post) isHttpRule_Pattern() {<span class="cov0" title="0">}</span>

func (*HttpRule_Delete) isHttpRule_Pattern() {<span class="cov0" title="0">}</span>

func (*HttpRule_Patch) isHttpRule_Pattern() {<span class="cov0" title="0">}</span>

func (*HttpRule_Custom) isHttpRule_Pattern() {<span class="cov0" title="0">}</span>

// A custom pattern is used for defining custom HTTP verb.
type CustomHttpPattern struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // The name of this custom HTTP verb.
        Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
        // The path matched by this custom verb.
        Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
}

func (x *CustomHttpPattern) Reset() <span class="cov0" title="0">{
        *x = CustomHttpPattern{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_google_api_http_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *CustomHttpPattern) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CustomHttpPattern) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CustomHttpPattern) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_google_api_http_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CustomHttpPattern.ProtoReflect.Descriptor instead.
func (*CustomHttpPattern) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_google_api_http_proto_rawDescGZIP(), []int{2}
}</span>

func (x *CustomHttpPattern) GetKind() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Kind
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CustomHttpPattern) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_google_api_http_proto protoreflect.FileDescriptor

var file_google_api_http_proto_rawDesc = []byte{
        0x0a, 0x15, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x68, 0x74, 0x74,
        0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
        0x61, 0x70, 0x69, 0x22, 0x79, 0x0a, 0x04, 0x48, 0x74, 0x74, 0x70, 0x12, 0x2a, 0x0a, 0x05, 0x72,
        0x75, 0x6c, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x48, 0x74, 0x74, 0x70, 0x52, 0x75, 0x6c, 0x65,
        0x52, 0x05, 0x72, 0x75, 0x6c, 0x65, 0x73, 0x12, 0x45, 0x0a, 0x1f, 0x66, 0x75, 0x6c, 0x6c, 0x79,
        0x5f, 0x64, 0x65, 0x63, 0x6f, 0x64, 0x65, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64,
        0x5f, 0x65, 0x78, 0x70, 0x61, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08,
        0x52, 0x1c, 0x66, 0x75, 0x6c, 0x6c, 0x79, 0x44, 0x65, 0x63, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x73,
        0x65, 0x72, 0x76, 0x65, 0x64, 0x45, 0x78, 0x70, 0x61, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0xda,
        0x02, 0x0a, 0x08, 0x48, 0x74, 0x74, 0x70, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x73,
        0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x73,
        0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x12, 0x0a, 0x03, 0x67, 0x65, 0x74, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x03, 0x67, 0x65, 0x74, 0x12, 0x12, 0x0a, 0x03, 0x70,
        0x75, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x03, 0x70, 0x75, 0x74, 0x12,
        0x14, 0x0a, 0x04, 0x70, 0x6f, 0x73, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52,
        0x04, 0x70, 0x6f, 0x73, 0x74, 0x12, 0x18, 0x0a, 0x06, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x18,
        0x05, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x06, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x12,
        0x16, 0x0a, 0x05, 0x70, 0x61, 0x74, 0x63, 0x68, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00,
        0x52, 0x05, 0x70, 0x61, 0x74, 0x63, 0x68, 0x12, 0x37, 0x0a, 0x06, 0x63, 0x75, 0x73, 0x74, 0x6f,
        0x6d, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
        0x2e, 0x61, 0x70, 0x69, 0x2e, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x48, 0x74, 0x74, 0x70, 0x50,
        0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x48, 0x00, 0x52, 0x06, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d,
        0x12, 0x12, 0x0a, 0x04, 0x62, 0x6f, 0x64, 0x79, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
        0x62, 0x6f, 0x64, 0x79, 0x12, 0x23, 0x0a, 0x0d, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x5f, 0x62, 0x6f, 0x64, 0x79, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x72, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x6f, 0x64, 0x79, 0x12, 0x45, 0x0a, 0x13, 0x61, 0x64, 0x64,
        0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x5f, 0x62, 0x69, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x73,
        0x18, 0x0b, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
        0x61, 0x70, 0x69, 0x2e, 0x48, 0x74, 0x74, 0x70, 0x52, 0x75, 0x6c, 0x65, 0x52, 0x12, 0x61, 0x64,
        0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x42, 0x69, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x73,
        0x42, 0x09, 0x0a, 0x07, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x22, 0x3b, 0x0a, 0x11, 0x43,
        0x75, 0x73, 0x74, 0x6f, 0x6d, 0x48, 0x74, 0x74, 0x70, 0x50, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e,
        0x12, 0x12, 0x0a, 0x04, 0x6b, 0x69, 0x6e, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
        0x6b, 0x69, 0x6e, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x04, 0x70, 0x61, 0x74, 0x68, 0x42, 0x6a, 0x0a, 0x0e, 0x63, 0x6f, 0x6d, 0x2e,
        0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x61, 0x70, 0x69, 0x42, 0x09, 0x48, 0x74, 0x74, 0x70,
        0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x41, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
        0x67, 0x6f, 0x6c, 0x61, 0x6e, 0x67, 0x2e, 0x6f, 0x72, 0x67, 0x2f, 0x67, 0x65, 0x6e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x61, 0x70, 0x69, 0x73, 0x2f, 0x61,
        0x70, 0x69, 0x2f, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x3b, 0x61,
        0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0xf8, 0x01, 0x01, 0xa2, 0x02, 0x04,
        0x47, 0x41, 0x50, 0x49, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_google_api_http_proto_rawDescOnce sync.Once
        file_google_api_http_proto_rawDescData = file_google_api_http_proto_rawDesc
)

func file_google_api_http_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_google_api_http_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_google_api_http_proto_rawDescData = protoimpl.X.CompressGZIP(file_google_api_http_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_google_api_http_proto_rawDescData</span>
}

var file_google_api_http_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_google_api_http_proto_goTypes = []interface{}{
        (*Http)(nil),              // 0: google.api.Http
        (*HttpRule)(nil),          // 1: google.api.HttpRule
        (*CustomHttpPattern)(nil), // 2: google.api.CustomHttpPattern
}
var file_google_api_http_proto_depIdxs = []int32{
        1, // 0: google.api.Http.rules:type_name -&gt; google.api.HttpRule
        2, // 1: google.api.HttpRule.custom:type_name -&gt; google.api.CustomHttpPattern
        1, // 2: google.api.HttpRule.additional_bindings:type_name -&gt; google.api.HttpRule
        3, // [3:3] is the sub-list for method output_type
        3, // [3:3] is the sub-list for method input_type
        3, // [3:3] is the sub-list for extension type_name
        3, // [3:3] is the sub-list for extension extendee
        0, // [0:3] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_google_api_http_proto_init() }</span>
func file_google_api_http_proto_init() <span class="cov0" title="0">{
        if File_google_api_http_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_google_api_http_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Http); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_google_api_http_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*HttpRule); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_google_api_http_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*CustomHttpPattern); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">file_google_api_http_proto_msgTypes[1].OneofWrappers = []interface{}{
                (*HttpRule_Get)(nil),
                (*HttpRule_Put)(nil),
                (*HttpRule_Post)(nil),
                (*HttpRule_Delete)(nil),
                (*HttpRule_Patch)(nil),
                (*HttpRule_Custom)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_google_api_http_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   3,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_google_api_http_proto_goTypes,
                DependencyIndexes: file_google_api_http_proto_depIdxs,
                MessageInfos:      file_google_api_http_proto_msgTypes,
        }.Build()
        File_google_api_http_proto = out.File
        file_google_api_http_proto_rawDesc = nil
        file_google_api_http_proto_goTypes = nil
        file_google_api_http_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.30.0
//         protoc        v3.21.9
// source: permission.proto

package challengeservice

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        descriptorpb "google.golang.org/protobuf/types/descriptorpb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Action int32

const (
        Action_unknown Action = 0 // don't use this
        Action_CREATE  Action = 1
        Action_READ    Action = 2
        Action_UPDATE  Action = 4
        Action_DELETE  Action = 8
)

// Enum value maps for Action.
var (
        Action_name = map[int32]string{
                0: "unknown",
                1: "CREATE",
                2: "READ",
                4: "UPDATE",
                8: "DELETE",
        }
        Action_value = map[string]int32{
                "unknown": 0,
                "CREATE":  1,
                "READ":    2,
                "UPDATE":  4,
                "DELETE":  8,
        }
)

func (x Action) Enum() *Action <span class="cov0" title="0">{
        p := new(Action)
        *p = x
        return p
}</span>

func (x Action) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (Action) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_permission_proto_enumTypes[0].Descriptor()
}</span>

func (Action) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_permission_proto_enumTypes[0]
}</span>

func (x Action) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use Action.Descriptor instead.
func (Action) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_permission_proto_rawDescGZIP(), []int{0}
}</span>

var file_permission_proto_extTypes = []protoimpl.ExtensionInfo{
        {
                ExtendedType:  (*descriptorpb.MethodOptions)(nil),
                ExtensionType: (*string)(nil),
                Field:         50001,
                Name:          "permission.resource",
                Tag:           "bytes,50001,opt,name=resource",
                Filename:      "permission.proto",
        },
        {
                ExtendedType:  (*descriptorpb.MethodOptions)(nil),
                ExtensionType: (*Action)(nil),
                Field:         50002,
                Name:          "permission.action",
                Tag:           "varint,50002,opt,name=action,enum=permission.Action",
                Filename:      "permission.proto",
        },
}

// Extension fields to descriptorpb.MethodOptions.
var (
        // optional string resource = 50001;
        E_Resource = &amp;file_permission_proto_extTypes[0]
        // optional permission.Action action = 50002;
        E_Action = &amp;file_permission_proto_extTypes[1]
)

var File_permission_proto protoreflect.FileDescriptor

var file_permission_proto_rawDesc = []byte{
        0x0a, 0x10, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x12, 0x0a, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x1a, 0x20,
        0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f,
        0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2a, 0x43, 0x0a, 0x06, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x0b, 0x0a, 0x07, 0x75, 0x6e,
        0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x10, 0x00, 0x12, 0x0a, 0x0a, 0x06, 0x43, 0x52, 0x45, 0x41, 0x54,
        0x45, 0x10, 0x01, 0x12, 0x08, 0x0a, 0x04, 0x52, 0x45, 0x41, 0x44, 0x10, 0x02, 0x12, 0x0a, 0x0a,
        0x06, 0x55, 0x50, 0x44, 0x41, 0x54, 0x45, 0x10, 0x04, 0x12, 0x0a, 0x0a, 0x06, 0x44, 0x45, 0x4c,
        0x45, 0x54, 0x45, 0x10, 0x08, 0x3a, 0x3c, 0x0a, 0x08, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63,
        0x65, 0x12, 0x1e, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2e, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x18, 0xd1, 0x86, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x65, 0x73, 0x6f, 0x75,
        0x72, 0x63, 0x65, 0x3a, 0x4c, 0x0a, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1e, 0x2e,
        0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
        0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0xd2, 0x86,
        0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x12, 0x2e, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69,
        0x6f, 0x6e, 0x2e, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x06, 0x61, 0x63, 0x74, 0x69, 0x6f,
        0x6e, 0x42, 0x74, 0x0a, 0x25, 0x6e, 0x65, 0x74, 0x2e, 0x61, 0x63, 0x63, 0x65, 0x6c, 0x62, 0x79,
        0x74, 0x65, 0x2e, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x64, 0x2e, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65,
        0x6e, 0x67, 0x65, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x50, 0x01, 0x5a, 0x25, 0x61, 0x63,
        0x63, 0x65, 0x6c, 0x62, 0x79, 0x74, 0x65, 0x2e, 0x6e, 0x65, 0x74, 0x2f, 0x65, 0x78, 0x74, 0x65,
        0x6e, 0x64, 0x2f, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73, 0x65, 0x72, 0x76,
        0x69, 0x63, 0x65, 0xaa, 0x02, 0x21, 0x41, 0x63, 0x63, 0x65, 0x6c, 0x42, 0x79, 0x74, 0x65, 0x2e,
        0x45, 0x78, 0x74, 0x65, 0x6e, 0x64, 0x2e, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65,
        0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_permission_proto_rawDescOnce sync.Once
        file_permission_proto_rawDescData = file_permission_proto_rawDesc
)

func file_permission_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_permission_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_permission_proto_rawDescData = protoimpl.X.CompressGZIP(file_permission_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_permission_proto_rawDescData</span>
}

var file_permission_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_permission_proto_goTypes = []interface{}{
        (Action)(0),                        // 0: permission.Action
        (*descriptorpb.MethodOptions)(nil), // 1: google.protobuf.MethodOptions
}
var file_permission_proto_depIdxs = []int32{
        1, // 0: permission.resource:extendee -&gt; google.protobuf.MethodOptions
        1, // 1: permission.action:extendee -&gt; google.protobuf.MethodOptions
        0, // 2: permission.action:type_name -&gt; permission.Action
        3, // [3:3] is the sub-list for method output_type
        3, // [3:3] is the sub-list for method input_type
        2, // [2:3] is the sub-list for extension type_name
        0, // [0:2] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_permission_proto_init() }</span>
func file_permission_proto_init() <span class="cov0" title="0">{
        if File_permission_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_permission_proto_rawDesc,
                        NumEnums:      1,
                        NumMessages:   0,
                        NumExtensions: 2,
                        NumServices:   0,
                },
                GoTypes:           file_permission_proto_goTypes,
                DependencyIndexes: file_permission_proto_depIdxs,
                EnumInfos:         file_permission_proto_enumTypes,
                ExtensionInfos:    file_permission_proto_extTypes,
        }.Build()
        File_permission_proto = out.File
        file_permission_proto_rawDesc = nil
        file_permission_proto_goTypes = nil
        file_permission_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.30.0
//         protoc        v3.21.9
// source: protoc-gen-openapiv2/options/annotations.proto

package options

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        descriptorpb "google.golang.org/protobuf/types/descriptorpb"
        reflect "reflect"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

var file_protoc_gen_openapiv2_options_annotations_proto_extTypes = []protoimpl.ExtensionInfo{
        {
                ExtendedType:  (*descriptorpb.FileOptions)(nil),
                ExtensionType: (*Swagger)(nil),
                Field:         1042,
                Name:          "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger",
                Tag:           "bytes,1042,opt,name=openapiv2_swagger",
                Filename:      "protoc-gen-openapiv2/options/annotations.proto",
        },
        {
                ExtendedType:  (*descriptorpb.MethodOptions)(nil),
                ExtensionType: (*Operation)(nil),
                Field:         1042,
                Name:          "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation",
                Tag:           "bytes,1042,opt,name=openapiv2_operation",
                Filename:      "protoc-gen-openapiv2/options/annotations.proto",
        },
        {
                ExtendedType:  (*descriptorpb.MessageOptions)(nil),
                ExtensionType: (*Schema)(nil),
                Field:         1042,
                Name:          "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema",
                Tag:           "bytes,1042,opt,name=openapiv2_schema",
                Filename:      "protoc-gen-openapiv2/options/annotations.proto",
        },
        {
                ExtendedType:  (*descriptorpb.ServiceOptions)(nil),
                ExtensionType: (*Tag)(nil),
                Field:         1042,
                Name:          "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_tag",
                Tag:           "bytes,1042,opt,name=openapiv2_tag",
                Filename:      "protoc-gen-openapiv2/options/annotations.proto",
        },
        {
                ExtendedType:  (*descriptorpb.FieldOptions)(nil),
                ExtensionType: (*JSONSchema)(nil),
                Field:         1042,
                Name:          "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field",
                Tag:           "bytes,1042,opt,name=openapiv2_field",
                Filename:      "protoc-gen-openapiv2/options/annotations.proto",
        },
}

// Extension fields to descriptorpb.FileOptions.
var (
        // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
        //
        // All IDs are the same, as assigned. It is okay that they are the same, as they extend
        // different descriptor messages.
        //
        // optional grpc.gateway.protoc_gen_openapiv2.options.Swagger openapiv2_swagger = 1042;
        E_Openapiv2Swagger = &amp;file_protoc_gen_openapiv2_options_annotations_proto_extTypes[0]
)

// Extension fields to descriptorpb.MethodOptions.
var (
        // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
        //
        // All IDs are the same, as assigned. It is okay that they are the same, as they extend
        // different descriptor messages.
        //
        // optional grpc.gateway.protoc_gen_openapiv2.options.Operation openapiv2_operation = 1042;
        E_Openapiv2Operation = &amp;file_protoc_gen_openapiv2_options_annotations_proto_extTypes[1]
)

// Extension fields to descriptorpb.MessageOptions.
var (
        // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
        //
        // All IDs are the same, as assigned. It is okay that they are the same, as they extend
        // different descriptor messages.
        //
        // optional grpc.gateway.protoc_gen_openapiv2.options.Schema openapiv2_schema = 1042;
        E_Openapiv2Schema = &amp;file_protoc_gen_openapiv2_options_annotations_proto_extTypes[2]
)

// Extension fields to descriptorpb.ServiceOptions.
var (
        // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
        //
        // All IDs are the same, as assigned. It is okay that they are the same, as they extend
        // different descriptor messages.
        //
        // optional grpc.gateway.protoc_gen_openapiv2.options.Tag openapiv2_tag = 1042;
        E_Openapiv2Tag = &amp;file_protoc_gen_openapiv2_options_annotations_proto_extTypes[3]
)

// Extension fields to descriptorpb.FieldOptions.
var (
        // ID assigned by protobuf-global-extension-registry@google.com for gRPC-Gateway project.
        //
        // All IDs are the same, as assigned. It is okay that they are the same, as they extend
        // different descriptor messages.
        //
        // optional grpc.gateway.protoc_gen_openapiv2.options.JSONSchema openapiv2_field = 1042;
        E_Openapiv2Field = &amp;file_protoc_gen_openapiv2_options_annotations_proto_extTypes[4]
)

var File_protoc_gen_openapiv2_options_annotations_proto protoreflect.FileDescriptor

var file_protoc_gen_openapiv2_options_annotations_proto_rawDesc = []byte{
        0x0a, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x2d, 0x67, 0x65, 0x6e, 0x2d, 0x6f, 0x70, 0x65,
        0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x61,
        0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x12, 0x29, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70,
        0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x20, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x65, 0x73,
        0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2c, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x63, 0x2d, 0x67, 0x65, 0x6e, 0x2d, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70,
        0x69, 0x76, 0x32, 0x2f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x6f, 0x70, 0x65, 0x6e,
        0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x3a, 0x7e, 0x0a, 0x11, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x5f, 0x73, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72,
        0x12, 0x1c, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
        0x75, 0x66, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x92,
        0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74,
        0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f,
        0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x2e, 0x53, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72, 0x52, 0x10, 0x6f, 0x70, 0x65, 0x6e, 0x61,
        0x70, 0x69, 0x76, 0x32, 0x53, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72, 0x3a, 0x86, 0x01, 0x0a, 0x13,
        0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x5f, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x12, 0x1e, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x4f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x18, 0x92, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x34, 0x2e, 0x67, 0x72, 0x70,
        0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
        0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
        0x52, 0x12, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x4f, 0x70, 0x65, 0x72, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x7e, 0x0a, 0x10, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x12, 0x1f, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
        0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x4d, 0x65, 0x73, 0x73, 0x61,
        0x67, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x92, 0x08, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x31, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61,
        0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x63, 0x68,
        0x65, 0x6d, 0x61, 0x52, 0x0f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x53, 0x63,
        0x68, 0x65, 0x6d, 0x61, 0x3a, 0x75, 0x0a, 0x0d, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x5f, 0x74, 0x61, 0x67, 0x12, 0x1f, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x4f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x92, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e,
        0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x54, 0x61, 0x67, 0x52, 0x0c, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x54, 0x61, 0x67, 0x3a, 0x7e, 0x0a, 0x0f, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x12, 0x1d,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x92, 0x08,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65,
        0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x2e, 0x4a, 0x53, 0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x52, 0x0e, 0x6f, 0x70, 0x65,
        0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x42, 0x48, 0x5a, 0x46, 0x67,
        0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x2d, 0x65,
        0x63, 0x6f, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x2d, 0x67, 0x61,
        0x74, 0x65, 0x77, 0x61, 0x79, 0x2f, 0x76, 0x32, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x2d,
        0x67, 0x65, 0x6e, 0x2d, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2f, 0x6f, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x73, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var file_protoc_gen_openapiv2_options_annotations_proto_goTypes = []interface{}{
        (*descriptorpb.FileOptions)(nil),    // 0: google.protobuf.FileOptions
        (*descriptorpb.MethodOptions)(nil),  // 1: google.protobuf.MethodOptions
        (*descriptorpb.MessageOptions)(nil), // 2: google.protobuf.MessageOptions
        (*descriptorpb.ServiceOptions)(nil), // 3: google.protobuf.ServiceOptions
        (*descriptorpb.FieldOptions)(nil),   // 4: google.protobuf.FieldOptions
        (*Swagger)(nil),                     // 5: grpc.gateway.protoc_gen_openapiv2.options.Swagger
        (*Operation)(nil),                   // 6: grpc.gateway.protoc_gen_openapiv2.options.Operation
        (*Schema)(nil),                      // 7: grpc.gateway.protoc_gen_openapiv2.options.Schema
        (*Tag)(nil),                         // 8: grpc.gateway.protoc_gen_openapiv2.options.Tag
        (*JSONSchema)(nil),                  // 9: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema
}
var file_protoc_gen_openapiv2_options_annotations_proto_depIdxs = []int32{
        0,  // 0: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger:extendee -&gt; google.protobuf.FileOptions
        1,  // 1: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation:extendee -&gt; google.protobuf.MethodOptions
        2,  // 2: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema:extendee -&gt; google.protobuf.MessageOptions
        3,  // 3: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_tag:extendee -&gt; google.protobuf.ServiceOptions
        4,  // 4: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field:extendee -&gt; google.protobuf.FieldOptions
        5,  // 5: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Swagger
        6,  // 6: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Operation
        7,  // 7: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Schema
        8,  // 8: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_tag:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Tag
        9,  // 9: grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.JSONSchema
        10, // [10:10] is the sub-list for method output_type
        10, // [10:10] is the sub-list for method input_type
        5,  // [5:10] is the sub-list for extension type_name
        0,  // [0:5] is the sub-list for extension extendee
        0,  // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_protoc_gen_openapiv2_options_annotations_proto_init() }</span>
func file_protoc_gen_openapiv2_options_annotations_proto_init() <span class="cov0" title="0">{
        if File_protoc_gen_openapiv2_options_annotations_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_init()
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_protoc_gen_openapiv2_options_annotations_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   0,
                        NumExtensions: 5,
                        NumServices:   0,
                },
                GoTypes:           file_protoc_gen_openapiv2_options_annotations_proto_goTypes,
                DependencyIndexes: file_protoc_gen_openapiv2_options_annotations_proto_depIdxs,
                ExtensionInfos:    file_protoc_gen_openapiv2_options_annotations_proto_extTypes,
        }.Build()
        File_protoc_gen_openapiv2_options_annotations_proto = out.File
        file_protoc_gen_openapiv2_options_annotations_proto_rawDesc = nil
        file_protoc_gen_openapiv2_options_annotations_proto_goTypes = nil
        file_protoc_gen_openapiv2_options_annotations_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.30.0
//         protoc        v3.21.9
// source: protoc-gen-openapiv2/options/openapiv2.proto

package options

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        structpb "google.golang.org/protobuf/types/known/structpb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Scheme describes the schemes supported by the OpenAPI Swagger
// and Operation objects.
type Scheme int32

const (
        Scheme_UNKNOWN Scheme = 0
        Scheme_HTTP    Scheme = 1
        Scheme_HTTPS   Scheme = 2
        Scheme_WS      Scheme = 3
        Scheme_WSS     Scheme = 4
)

// Enum value maps for Scheme.
var (
        Scheme_name = map[int32]string{
                0: "UNKNOWN",
                1: "HTTP",
                2: "HTTPS",
                3: "WS",
                4: "WSS",
        }
        Scheme_value = map[string]int32{
                "UNKNOWN": 0,
                "HTTP":    1,
                "HTTPS":   2,
                "WS":      3,
                "WSS":     4,
        }
)

func (x Scheme) Enum() *Scheme <span class="cov0" title="0">{
        p := new(Scheme)
        *p = x
        return p
}</span>

func (x Scheme) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (Scheme) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[0].Descriptor()
}</span>

func (Scheme) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[0]
}</span>

func (x Scheme) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use Scheme.Descriptor instead.
func (Scheme) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{0}
}</span>

// `Type` is a a supported HTTP header type.
// See https://swagger.io/specification/v2/#parameterType.
type HeaderParameter_Type int32

const (
        HeaderParameter_UNKNOWN HeaderParameter_Type = 0
        HeaderParameter_STRING  HeaderParameter_Type = 1
        HeaderParameter_NUMBER  HeaderParameter_Type = 2
        HeaderParameter_INTEGER HeaderParameter_Type = 3
        HeaderParameter_BOOLEAN HeaderParameter_Type = 4
)

// Enum value maps for HeaderParameter_Type.
var (
        HeaderParameter_Type_name = map[int32]string{
                0: "UNKNOWN",
                1: "STRING",
                2: "NUMBER",
                3: "INTEGER",
                4: "BOOLEAN",
        }
        HeaderParameter_Type_value = map[string]int32{
                "UNKNOWN": 0,
                "STRING":  1,
                "NUMBER":  2,
                "INTEGER": 3,
                "BOOLEAN": 4,
        }
)

func (x HeaderParameter_Type) Enum() *HeaderParameter_Type <span class="cov0" title="0">{
        p := new(HeaderParameter_Type)
        *p = x
        return p
}</span>

func (x HeaderParameter_Type) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (HeaderParameter_Type) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[1].Descriptor()
}</span>

func (HeaderParameter_Type) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[1]
}</span>

func (x HeaderParameter_Type) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use HeaderParameter_Type.Descriptor instead.
func (HeaderParameter_Type) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{3, 0}
}</span>

type JSONSchema_JSONSchemaSimpleTypes int32

const (
        JSONSchema_UNKNOWN JSONSchema_JSONSchemaSimpleTypes = 0
        JSONSchema_ARRAY   JSONSchema_JSONSchemaSimpleTypes = 1
        JSONSchema_BOOLEAN JSONSchema_JSONSchemaSimpleTypes = 2
        JSONSchema_INTEGER JSONSchema_JSONSchemaSimpleTypes = 3
        JSONSchema_NULL    JSONSchema_JSONSchemaSimpleTypes = 4
        JSONSchema_NUMBER  JSONSchema_JSONSchemaSimpleTypes = 5
        JSONSchema_OBJECT  JSONSchema_JSONSchemaSimpleTypes = 6
        JSONSchema_STRING  JSONSchema_JSONSchemaSimpleTypes = 7
)

// Enum value maps for JSONSchema_JSONSchemaSimpleTypes.
var (
        JSONSchema_JSONSchemaSimpleTypes_name = map[int32]string{
                0: "UNKNOWN",
                1: "ARRAY",
                2: "BOOLEAN",
                3: "INTEGER",
                4: "NULL",
                5: "NUMBER",
                6: "OBJECT",
                7: "STRING",
        }
        JSONSchema_JSONSchemaSimpleTypes_value = map[string]int32{
                "UNKNOWN": 0,
                "ARRAY":   1,
                "BOOLEAN": 2,
                "INTEGER": 3,
                "NULL":    4,
                "NUMBER":  5,
                "OBJECT":  6,
                "STRING":  7,
        }
)

func (x JSONSchema_JSONSchemaSimpleTypes) Enum() *JSONSchema_JSONSchemaSimpleTypes <span class="cov0" title="0">{
        p := new(JSONSchema_JSONSchemaSimpleTypes)
        *p = x
        return p
}</span>

func (x JSONSchema_JSONSchemaSimpleTypes) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (JSONSchema_JSONSchemaSimpleTypes) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[2].Descriptor()
}</span>

func (JSONSchema_JSONSchemaSimpleTypes) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[2]
}</span>

func (x JSONSchema_JSONSchemaSimpleTypes) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use JSONSchema_JSONSchemaSimpleTypes.Descriptor instead.
func (JSONSchema_JSONSchemaSimpleTypes) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{11, 0}
}</span>

// The type of the security scheme. Valid values are "basic",
// "apiKey" or "oauth2".
type SecurityScheme_Type int32

const (
        SecurityScheme_TYPE_INVALID SecurityScheme_Type = 0
        SecurityScheme_TYPE_BASIC   SecurityScheme_Type = 1
        SecurityScheme_TYPE_API_KEY SecurityScheme_Type = 2
        SecurityScheme_TYPE_OAUTH2  SecurityScheme_Type = 3
)

// Enum value maps for SecurityScheme_Type.
var (
        SecurityScheme_Type_name = map[int32]string{
                0: "TYPE_INVALID",
                1: "TYPE_BASIC",
                2: "TYPE_API_KEY",
                3: "TYPE_OAUTH2",
        }
        SecurityScheme_Type_value = map[string]int32{
                "TYPE_INVALID": 0,
                "TYPE_BASIC":   1,
                "TYPE_API_KEY": 2,
                "TYPE_OAUTH2":  3,
        }
)

func (x SecurityScheme_Type) Enum() *SecurityScheme_Type <span class="cov0" title="0">{
        p := new(SecurityScheme_Type)
        *p = x
        return p
}</span>

func (x SecurityScheme_Type) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (SecurityScheme_Type) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[3].Descriptor()
}</span>

func (SecurityScheme_Type) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[3]
}</span>

func (x SecurityScheme_Type) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use SecurityScheme_Type.Descriptor instead.
func (SecurityScheme_Type) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{14, 0}
}</span>

// The location of the API key. Valid values are "query" or "header".
type SecurityScheme_In int32

const (
        SecurityScheme_IN_INVALID SecurityScheme_In = 0
        SecurityScheme_IN_QUERY   SecurityScheme_In = 1
        SecurityScheme_IN_HEADER  SecurityScheme_In = 2
)

// Enum value maps for SecurityScheme_In.
var (
        SecurityScheme_In_name = map[int32]string{
                0: "IN_INVALID",
                1: "IN_QUERY",
                2: "IN_HEADER",
        }
        SecurityScheme_In_value = map[string]int32{
                "IN_INVALID": 0,
                "IN_QUERY":   1,
                "IN_HEADER":  2,
        }
)

func (x SecurityScheme_In) Enum() *SecurityScheme_In <span class="cov0" title="0">{
        p := new(SecurityScheme_In)
        *p = x
        return p
}</span>

func (x SecurityScheme_In) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (SecurityScheme_In) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[4].Descriptor()
}</span>

func (SecurityScheme_In) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[4]
}</span>

func (x SecurityScheme_In) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use SecurityScheme_In.Descriptor instead.
func (SecurityScheme_In) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{14, 1}
}</span>

// The flow used by the OAuth2 security scheme. Valid values are
// "implicit", "password", "application" or "accessCode".
type SecurityScheme_Flow int32

const (
        SecurityScheme_FLOW_INVALID     SecurityScheme_Flow = 0
        SecurityScheme_FLOW_IMPLICIT    SecurityScheme_Flow = 1
        SecurityScheme_FLOW_PASSWORD    SecurityScheme_Flow = 2
        SecurityScheme_FLOW_APPLICATION SecurityScheme_Flow = 3
        SecurityScheme_FLOW_ACCESS_CODE SecurityScheme_Flow = 4
)

// Enum value maps for SecurityScheme_Flow.
var (
        SecurityScheme_Flow_name = map[int32]string{
                0: "FLOW_INVALID",
                1: "FLOW_IMPLICIT",
                2: "FLOW_PASSWORD",
                3: "FLOW_APPLICATION",
                4: "FLOW_ACCESS_CODE",
        }
        SecurityScheme_Flow_value = map[string]int32{
                "FLOW_INVALID":     0,
                "FLOW_IMPLICIT":    1,
                "FLOW_PASSWORD":    2,
                "FLOW_APPLICATION": 3,
                "FLOW_ACCESS_CODE": 4,
        }
)

func (x SecurityScheme_Flow) Enum() *SecurityScheme_Flow <span class="cov0" title="0">{
        p := new(SecurityScheme_Flow)
        *p = x
        return p
}</span>

func (x SecurityScheme_Flow) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (SecurityScheme_Flow) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[5].Descriptor()
}</span>

func (SecurityScheme_Flow) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes[5]
}</span>

func (x SecurityScheme_Flow) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use SecurityScheme_Flow.Descriptor instead.
func (SecurityScheme_Flow) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{14, 2}
}</span>

// `Swagger` is a representation of OpenAPI v2 specification's Swagger object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#swaggerObject
//
// Example:
//
//        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
//          info: {
//            title: "Echo API";
//            version: "1.0";
//            description: "";
//            contact: {
//              name: "gRPC-Gateway project";
//              url: "https://github.com/grpc-ecosystem/grpc-gateway";
//              email: "none@example.com";
//            };
//            license: {
//              name: "BSD 3-Clause License";
//              url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/main/LICENSE.txt";
//            };
//          };
//          schemes: HTTPS;
//          consumes: "application/json";
//          produces: "application/json";
//        };
type Swagger struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Specifies the OpenAPI Specification version being used. It can be
        // used by the OpenAPI UI and other clients to interpret the API listing. The
        // value MUST be "2.0".
        Swagger string `protobuf:"bytes,1,opt,name=swagger,proto3" json:"swagger,omitempty"`
        // Provides metadata about the API. The metadata can be used by the
        // clients if needed.
        Info *Info `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
        // The host (name or ip) serving the API. This MUST be the host only and does
        // not include the scheme nor sub-paths. It MAY include a port. If the host is
        // not included, the host serving the documentation is to be used (including
        // the port). The host does not support path templating.
        Host string `protobuf:"bytes,3,opt,name=host,proto3" json:"host,omitempty"`
        // The base path on which the API is served, which is relative to the host. If
        // it is not included, the API is served directly under the host. The value
        // MUST start with a leading slash (/). The basePath does not support path
        // templating.
        // Note that using `base_path` does not change the endpoint paths that are
        // generated in the resulting OpenAPI file. If you wish to use `base_path`
        // with relatively generated OpenAPI paths, the `base_path` prefix must be
        // manually removed from your `google.api.http` paths and your code changed to
        // serve the API from the `base_path`.
        BasePath string `protobuf:"bytes,4,opt,name=base_path,json=basePath,proto3" json:"base_path,omitempty"`
        // The transfer protocol of the API. Values MUST be from the list: "http",
        // "https", "ws", "wss". If the schemes is not included, the default scheme to
        // be used is the one used to access the OpenAPI definition itself.
        Schemes []Scheme `protobuf:"varint,5,rep,packed,name=schemes,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.Scheme" json:"schemes,omitempty"`
        // A list of MIME types the APIs can consume. This is global to all APIs but
        // can be overridden on specific API calls. Value MUST be as described under
        // Mime Types.
        Consumes []string `protobuf:"bytes,6,rep,name=consumes,proto3" json:"consumes,omitempty"`
        // A list of MIME types the APIs can produce. This is global to all APIs but
        // can be overridden on specific API calls. Value MUST be as described under
        // Mime Types.
        Produces []string `protobuf:"bytes,7,rep,name=produces,proto3" json:"produces,omitempty"`
        // An object to hold responses that can be used across operations. This
        // property does not define global responses for all operations.
        Responses map[string]*Response `protobuf:"bytes,10,rep,name=responses,proto3" json:"responses,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Security scheme definitions that can be used across the specification.
        SecurityDefinitions *SecurityDefinitions `protobuf:"bytes,11,opt,name=security_definitions,json=securityDefinitions,proto3" json:"security_definitions,omitempty"`
        // A declaration of which security schemes are applied for the API as a whole.
        // The list of values describes alternative security schemes that can be used
        // (that is, there is a logical OR between the security requirements).
        // Individual operations can override this definition.
        Security []*SecurityRequirement `protobuf:"bytes,12,rep,name=security,proto3" json:"security,omitempty"`
        // A list of tags for API documentation control. Tags can be used for logical
        // grouping of operations by resources or any other qualifier.
        Tags []*Tag `protobuf:"bytes,13,rep,name=tags,proto3" json:"tags,omitempty"`
        // Additional external documentation.
        ExternalDocs *ExternalDocumentation `protobuf:"bytes,14,opt,name=external_docs,json=externalDocs,proto3" json:"external_docs,omitempty"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value `protobuf:"bytes,15,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *Swagger) Reset() <span class="cov0" title="0">{
        *x = Swagger{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Swagger) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Swagger) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Swagger) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Swagger.ProtoReflect.Descriptor instead.
func (*Swagger) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Swagger) GetSwagger() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Swagger
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Swagger) GetInfo() *Info <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Info
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetHost() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Host
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Swagger) GetBasePath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BasePath
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Swagger) GetSchemes() []Scheme <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Schemes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetConsumes() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Consumes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetProduces() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Produces
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetResponses() map[string]*Response <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Responses
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetSecurityDefinitions() *SecurityDefinitions <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SecurityDefinitions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetSecurity() []*SecurityRequirement <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Security
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetTags() []*Tag <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetExternalDocs() *ExternalDocumentation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExternalDocs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Swagger) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// `Operation` is a representation of OpenAPI v2 specification's Operation object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#operationObject
//
// Example:
//
//        service EchoService {
//          rpc Echo(SimpleMessage) returns (SimpleMessage) {
//            option (google.api.http) = {
//              get: "/v1/example/echo/{id}"
//            };
//
//            option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation) = {
//              summary: "Get a message.";
//              operation_id: "getMessage";
//              tags: "echo";
//              responses: {
//                key: "200"
//                  value: {
//                  description: "OK";
//                }
//              }
//            };
//          }
//        }
type Operation struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // A list of tags for API documentation control. Tags can be used for logical
        // grouping of operations by resources or any other qualifier.
        Tags []string `protobuf:"bytes,1,rep,name=tags,proto3" json:"tags,omitempty"`
        // A short summary of what the operation does. For maximum readability in the
        // swagger-ui, this field SHOULD be less than 120 characters.
        Summary string `protobuf:"bytes,2,opt,name=summary,proto3" json:"summary,omitempty"`
        // A verbose explanation of the operation behavior. GFM syntax can be used for
        // rich text representation.
        Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
        // Additional external documentation for this operation.
        ExternalDocs *ExternalDocumentation `protobuf:"bytes,4,opt,name=external_docs,json=externalDocs,proto3" json:"external_docs,omitempty"`
        // Unique string used to identify the operation. The id MUST be unique among
        // all operations described in the API. Tools and libraries MAY use the
        // operationId to uniquely identify an operation, therefore, it is recommended
        // to follow common programming naming conventions.
        OperationId string `protobuf:"bytes,5,opt,name=operation_id,json=operationId,proto3" json:"operation_id,omitempty"`
        // A list of MIME types the operation can consume. This overrides the consumes
        // definition at the OpenAPI Object. An empty value MAY be used to clear the
        // global definition. Value MUST be as described under Mime Types.
        Consumes []string `protobuf:"bytes,6,rep,name=consumes,proto3" json:"consumes,omitempty"`
        // A list of MIME types the operation can produce. This overrides the produces
        // definition at the OpenAPI Object. An empty value MAY be used to clear the
        // global definition. Value MUST be as described under Mime Types.
        Produces []string `protobuf:"bytes,7,rep,name=produces,proto3" json:"produces,omitempty"`
        // The list of possible responses as they are returned from executing this
        // operation.
        Responses map[string]*Response `protobuf:"bytes,9,rep,name=responses,proto3" json:"responses,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // The transfer protocol for the operation. Values MUST be from the list:
        // "http", "https", "ws", "wss". The value overrides the OpenAPI Object
        // schemes definition.
        Schemes []Scheme `protobuf:"varint,10,rep,packed,name=schemes,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.Scheme" json:"schemes,omitempty"`
        // Declares this operation to be deprecated. Usage of the declared operation
        // should be refrained. Default value is false.
        Deprecated bool `protobuf:"varint,11,opt,name=deprecated,proto3" json:"deprecated,omitempty"`
        // A declaration of which security schemes are applied for this operation. The
        // list of values describes alternative security schemes that can be used
        // (that is, there is a logical OR between the security requirements). This
        // definition overrides any declared top-level security. To remove a top-level
        // security declaration, an empty array can be used.
        Security []*SecurityRequirement `protobuf:"bytes,12,rep,name=security,proto3" json:"security,omitempty"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value `protobuf:"bytes,13,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Custom parameters such as HTTP request headers.
        // See: https://swagger.io/docs/specification/2-0/describing-parameters/
        // and https://swagger.io/specification/v2/#parameter-object.
        Parameters *Parameters `protobuf:"bytes,14,opt,name=parameters,proto3" json:"parameters,omitempty"`
}

func (x *Operation) Reset() <span class="cov0" title="0">{
        *x = Operation{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Operation) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Operation) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Operation) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Operation.ProtoReflect.Descriptor instead.
func (*Operation) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{1}
}</span>

func (x *Operation) GetTags() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetSummary() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Summary
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Operation) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Operation) GetExternalDocs() *ExternalDocumentation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExternalDocs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetOperationId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OperationId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Operation) GetConsumes() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Consumes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetProduces() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Produces
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetResponses() map[string]*Response <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Responses
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetSchemes() []Scheme <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Schemes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetDeprecated() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Deprecated
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Operation) GetSecurity() []*SecurityRequirement <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Security
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Operation) GetParameters() *Parameters <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Parameters
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// `Parameters` is a representation of OpenAPI v2 specification's parameters object.
// Note: This technically breaks compatibility with the OpenAPI 2 definition structure as we only
// allow header parameters to be set here since we do not want users specifying custom non-header
// parameters beyond those inferred from the Protobuf schema.
// See: https://swagger.io/specification/v2/#parameter-object
type Parameters struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // `Headers` is one or more HTTP header parameter.
        // See: https://swagger.io/docs/specification/2-0/describing-parameters/#header-parameters
        Headers []*HeaderParameter `protobuf:"bytes,1,rep,name=headers,proto3" json:"headers,omitempty"`
}

func (x *Parameters) Reset() <span class="cov0" title="0">{
        *x = Parameters{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Parameters) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Parameters) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Parameters) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Parameters.ProtoReflect.Descriptor instead.
func (*Parameters) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{2}
}</span>

func (x *Parameters) GetHeaders() []*HeaderParameter <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Headers
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// `HeaderParameter` a HTTP header parameter.
// See: https://swagger.io/specification/v2/#parameter-object
type HeaderParameter struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // `Name` is the header name.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // `Description` is a short description of the header.
        Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        // `Type` is the type of the object. The value MUST be one of "string", "number", "integer", or "boolean". The "array" type is not supported.
        // See: https://swagger.io/specification/v2/#parameterType.
        Type HeaderParameter_Type `protobuf:"varint,3,opt,name=type,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.HeaderParameter_Type" json:"type,omitempty"`
        // `Format` The extending format for the previously mentioned type.
        Format string `protobuf:"bytes,4,opt,name=format,proto3" json:"format,omitempty"`
        // `Required` indicates if the header is optional
        Required bool `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
}

func (x *HeaderParameter) Reset() <span class="cov0" title="0">{
        *x = HeaderParameter{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *HeaderParameter) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*HeaderParameter) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *HeaderParameter) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use HeaderParameter.ProtoReflect.Descriptor instead.
func (*HeaderParameter) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{3}
}</span>

func (x *HeaderParameter) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HeaderParameter) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HeaderParameter) GetType() HeaderParameter_Type <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return HeaderParameter_UNKNOWN</span>
}

func (x *HeaderParameter) GetFormat() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Format
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HeaderParameter) GetRequired() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Required
        }</span>
        <span class="cov0" title="0">return false</span>
}

// `Header` is a representation of OpenAPI v2 specification's Header object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#headerObject
type Header struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // `Description` is a short description of the header.
        Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
        // The type of the object. The value MUST be one of "string", "number", "integer", or "boolean". The "array" type is not supported.
        Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
        // `Format` The extending format for the previously mentioned type.
        Format string `protobuf:"bytes,3,opt,name=format,proto3" json:"format,omitempty"`
        // `Default` Declares the value of the header that the server will use if none is provided.
        // See: https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
        // Unlike JSON Schema this value MUST conform to the defined type for the header.
        Default string `protobuf:"bytes,6,opt,name=default,proto3" json:"default,omitempty"`
        // 'Pattern' See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.3.
        Pattern string `protobuf:"bytes,13,opt,name=pattern,proto3" json:"pattern,omitempty"`
}

func (x *Header) Reset() <span class="cov0" title="0">{
        *x = Header{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Header) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Header) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Header) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Header.ProtoReflect.Descriptor instead.
func (*Header) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{4}
}</span>

func (x *Header) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetFormat() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Format
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetDefault() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Default
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Header) GetPattern() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Pattern
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// `Response` is a representation of OpenAPI v2 specification's Response object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#responseObject
type Response struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // `Description` is a short description of the response.
        // GFM syntax can be used for rich text representation.
        Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
        // `Schema` optionally defines the structure of the response.
        // If `Schema` is not provided, it means there is no content to the response.
        Schema *Schema `protobuf:"bytes,2,opt,name=schema,proto3" json:"schema,omitempty"`
        // `Headers` A list of headers that are sent with the response.
        // `Header` name is expected to be a string in the canonical format of the MIME header key
        // See: https://golang.org/pkg/net/textproto/#CanonicalMIMEHeaderKey
        Headers map[string]*Header `protobuf:"bytes,3,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // `Examples` gives per-mimetype response examples.
        // See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#example-object
        Examples map[string]string `protobuf:"bytes,4,rep,name=examples,proto3" json:"examples,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value `protobuf:"bytes,5,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *Response) Reset() <span class="cov0" title="0">{
        *x = Response{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Response) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Response) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Response) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Response.ProtoReflect.Descriptor instead.
func (*Response) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{5}
}</span>

func (x *Response) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Response) GetSchema() *Schema <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Schema
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Response) GetHeaders() map[string]*Header <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Headers
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Response) GetExamples() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Examples
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Response) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// `Info` is a representation of OpenAPI v2 specification's Info object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#infoObject
//
// Example:
//
//        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
//          info: {
//            title: "Echo API";
//            version: "1.0";
//            description: "";
//            contact: {
//              name: "gRPC-Gateway project";
//              url: "https://github.com/grpc-ecosystem/grpc-gateway";
//              email: "none@example.com";
//            };
//            license: {
//              name: "BSD 3-Clause License";
//              url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/main/LICENSE.txt";
//            };
//          };
//          ...
//        };
type Info struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // The title of the application.
        Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
        // A short description of the application. GFM syntax can be used for rich
        // text representation.
        Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        // The Terms of Service for the API.
        TermsOfService string `protobuf:"bytes,3,opt,name=terms_of_service,json=termsOfService,proto3" json:"terms_of_service,omitempty"`
        // The contact information for the exposed API.
        Contact *Contact `protobuf:"bytes,4,opt,name=contact,proto3" json:"contact,omitempty"`
        // The license information for the exposed API.
        License *License `protobuf:"bytes,5,opt,name=license,proto3" json:"license,omitempty"`
        // Provides the version of the application API (not to be confused
        // with the specification version).
        Version string `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value `protobuf:"bytes,7,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *Info) Reset() <span class="cov0" title="0">{
        *x = Info{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Info) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Info) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Info) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Info.ProtoReflect.Descriptor instead.
func (*Info) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{6}
}</span>

func (x *Info) GetTitle() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Info) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Info) GetTermsOfService() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TermsOfService
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Info) GetContact() *Contact <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Contact
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Info) GetLicense() *License <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.License
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Info) GetVersion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Version
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Info) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// `Contact` is a representation of OpenAPI v2 specification's Contact object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#contactObject
//
// Example:
//
//        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
//          info: {
//            ...
//            contact: {
//              name: "gRPC-Gateway project";
//              url: "https://github.com/grpc-ecosystem/grpc-gateway";
//              email: "none@example.com";
//            };
//            ...
//          };
//          ...
//        };
type Contact struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // The identifying name of the contact person/organization.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // The URL pointing to the contact information. MUST be in the format of a
        // URL.
        Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
        // The email address of the contact person/organization. MUST be in the format
        // of an email address.
        Email string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
}

func (x *Contact) Reset() <span class="cov0" title="0">{
        *x = Contact{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Contact) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Contact) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Contact) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Contact.ProtoReflect.Descriptor instead.
func (*Contact) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{7}
}</span>

func (x *Contact) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Contact) GetUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Url
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Contact) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// `License` is a representation of OpenAPI v2 specification's License object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#licenseObject
//
// Example:
//
//        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
//          info: {
//            ...
//            license: {
//              name: "BSD 3-Clause License";
//              url: "https://github.com/grpc-ecosystem/grpc-gateway/blob/main/LICENSE.txt";
//            };
//            ...
//          };
//          ...
//        };
type License struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // The license name used for the API.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // A URL to the license used for the API. MUST be in the format of a URL.
        Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
}

func (x *License) Reset() <span class="cov0" title="0">{
        *x = License{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *License) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*License) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *License) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use License.ProtoReflect.Descriptor instead.
func (*License) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{8}
}</span>

func (x *License) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *License) GetUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Url
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// `ExternalDocumentation` is a representation of OpenAPI v2 specification's
// ExternalDocumentation object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#externalDocumentationObject
//
// Example:
//
//        option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
//          ...
//          external_docs: {
//            description: "More about gRPC-Gateway";
//            url: "https://github.com/grpc-ecosystem/grpc-gateway";
//          }
//          ...
//        };
type ExternalDocumentation struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // A short description of the target documentation. GFM syntax can be used for
        // rich text representation.
        Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
        // The URL for the target documentation. Value MUST be in the format
        // of a URL.
        Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
}

func (x *ExternalDocumentation) Reset() <span class="cov0" title="0">{
        *x = ExternalDocumentation{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ExternalDocumentation) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ExternalDocumentation) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ExternalDocumentation) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ExternalDocumentation.ProtoReflect.Descriptor instead.
func (*ExternalDocumentation) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{9}
}</span>

func (x *ExternalDocumentation) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ExternalDocumentation) GetUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Url
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// `Schema` is a representation of OpenAPI v2 specification's Schema object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
type Schema struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        JsonSchema *JSONSchema `protobuf:"bytes,1,opt,name=json_schema,json=jsonSchema,proto3" json:"json_schema,omitempty"`
        // Adds support for polymorphism. The discriminator is the schema property
        // name that is used to differentiate between other schema that inherit this
        // schema. The property name used MUST be defined at this schema and it MUST
        // be in the required property list. When used, the value MUST be the name of
        // this schema or any schema that inherits it.
        Discriminator string `protobuf:"bytes,2,opt,name=discriminator,proto3" json:"discriminator,omitempty"`
        // Relevant only for Schema "properties" definitions. Declares the property as
        // "read only". This means that it MAY be sent as part of a response but MUST
        // NOT be sent as part of the request. Properties marked as readOnly being
        // true SHOULD NOT be in the required list of the defined schema. Default
        // value is false.
        ReadOnly bool `protobuf:"varint,3,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
        // Additional external documentation for this schema.
        ExternalDocs *ExternalDocumentation `protobuf:"bytes,5,opt,name=external_docs,json=externalDocs,proto3" json:"external_docs,omitempty"`
        // A free-form property to include an example of an instance for this schema in JSON.
        // This is copied verbatim to the output.
        Example string `protobuf:"bytes,6,opt,name=example,proto3" json:"example,omitempty"`
}

func (x *Schema) Reset() <span class="cov0" title="0">{
        *x = Schema{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[10]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Schema) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Schema) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Schema) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[10]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Schema.ProtoReflect.Descriptor instead.
func (*Schema) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{10}
}</span>

func (x *Schema) GetJsonSchema() *JSONSchema <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.JsonSchema
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Schema) GetDiscriminator() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Discriminator
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Schema) GetReadOnly() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReadOnly
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Schema) GetExternalDocs() *ExternalDocumentation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExternalDocs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Schema) GetExample() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Example
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// `JSONSchema` represents properties from JSON Schema taken, and as used, in
// the OpenAPI v2 spec.
//
// This includes changes made by OpenAPI v2.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
//
// See also: https://cswr.github.io/JsonSchema/spec/basic_types/,
// https://github.com/json-schema-org/json-schema-spec/blob/master/schema.json
//
// Example:
//
//        message SimpleMessage {
//          option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
//            json_schema: {
//              title: "SimpleMessage"
//              description: "A simple message."
//              required: ["id"]
//            }
//          };
//
//          // Id represents the message identifier.
//          string id = 1; [
//              (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {
//                description: "The unique identifier of the simple message."
//              }];
//        }
type JSONSchema struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Ref is used to define an external reference to include in the message.
        // This could be a fully qualified proto message reference, and that type must
        // be imported into the protofile. If no message is identified, the Ref will
        // be used verbatim in the output.
        // For example:
        //
        //        `ref: ".google.protobuf.Timestamp"`.
        Ref string `protobuf:"bytes,3,opt,name=ref,proto3" json:"ref,omitempty"`
        // The title of the schema.
        Title string `protobuf:"bytes,5,opt,name=title,proto3" json:"title,omitempty"`
        // A short description of the schema.
        Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
        Default     string `protobuf:"bytes,7,opt,name=default,proto3" json:"default,omitempty"`
        ReadOnly    bool   `protobuf:"varint,8,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
        // A free-form property to include a JSON example of this field. This is copied
        // verbatim to the output swagger.json. Quotes must be escaped.
        // This property is the same for 2.0 and 3.0.0 https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/3.0.0.md#schemaObject  https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#schemaObject
        Example    string  `protobuf:"bytes,9,opt,name=example,proto3" json:"example,omitempty"`
        MultipleOf float64 `protobuf:"fixed64,10,opt,name=multiple_of,json=multipleOf,proto3" json:"multiple_of,omitempty"`
        // Maximum represents an inclusive upper limit for a numeric instance. The
        // value of MUST be a number,
        Maximum          float64 `protobuf:"fixed64,11,opt,name=maximum,proto3" json:"maximum,omitempty"`
        ExclusiveMaximum bool    `protobuf:"varint,12,opt,name=exclusive_maximum,json=exclusiveMaximum,proto3" json:"exclusive_maximum,omitempty"`
        // minimum represents an inclusive lower limit for a numeric instance. The
        // value of MUST be a number,
        Minimum          float64  `protobuf:"fixed64,13,opt,name=minimum,proto3" json:"minimum,omitempty"`
        ExclusiveMinimum bool     `protobuf:"varint,14,opt,name=exclusive_minimum,json=exclusiveMinimum,proto3" json:"exclusive_minimum,omitempty"`
        MaxLength        uint64   `protobuf:"varint,15,opt,name=max_length,json=maxLength,proto3" json:"max_length,omitempty"`
        MinLength        uint64   `protobuf:"varint,16,opt,name=min_length,json=minLength,proto3" json:"min_length,omitempty"`
        Pattern          string   `protobuf:"bytes,17,opt,name=pattern,proto3" json:"pattern,omitempty"`
        MaxItems         uint64   `protobuf:"varint,20,opt,name=max_items,json=maxItems,proto3" json:"max_items,omitempty"`
        MinItems         uint64   `protobuf:"varint,21,opt,name=min_items,json=minItems,proto3" json:"min_items,omitempty"`
        UniqueItems      bool     `protobuf:"varint,22,opt,name=unique_items,json=uniqueItems,proto3" json:"unique_items,omitempty"`
        MaxProperties    uint64   `protobuf:"varint,24,opt,name=max_properties,json=maxProperties,proto3" json:"max_properties,omitempty"`
        MinProperties    uint64   `protobuf:"varint,25,opt,name=min_properties,json=minProperties,proto3" json:"min_properties,omitempty"`
        Required         []string `protobuf:"bytes,26,rep,name=required,proto3" json:"required,omitempty"`
        // Items in 'array' must be unique.
        Array []string                           `protobuf:"bytes,34,rep,name=array,proto3" json:"array,omitempty"`
        Type  []JSONSchema_JSONSchemaSimpleTypes `protobuf:"varint,35,rep,packed,name=type,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.JSONSchema_JSONSchemaSimpleTypes" json:"type,omitempty"`
        // `Format`
        Format string `protobuf:"bytes,36,opt,name=format,proto3" json:"format,omitempty"`
        // Items in `enum` must be unique https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1
        Enum []string `protobuf:"bytes,46,rep,name=enum,proto3" json:"enum,omitempty"`
        // Additional field level properties used when generating the OpenAPI v2 file.
        FieldConfiguration *JSONSchema_FieldConfiguration `protobuf:"bytes,1001,opt,name=field_configuration,json=fieldConfiguration,proto3" json:"field_configuration,omitempty"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value `protobuf:"bytes,48,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *JSONSchema) Reset() <span class="cov0" title="0">{
        *x = JSONSchema{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[11]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *JSONSchema) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*JSONSchema) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *JSONSchema) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[11]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use JSONSchema.ProtoReflect.Descriptor instead.
func (*JSONSchema) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{11}
}</span>

func (x *JSONSchema) GetRef() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Ref
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetTitle() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Title
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetDefault() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Default
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetReadOnly() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReadOnly
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *JSONSchema) GetExample() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Example
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetMultipleOf() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MultipleOf
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetMaximum() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Maximum
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetExclusiveMaximum() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExclusiveMaximum
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *JSONSchema) GetMinimum() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Minimum
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetExclusiveMinimum() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExclusiveMinimum
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *JSONSchema) GetMaxLength() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxLength
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetMinLength() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MinLength
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetPattern() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Pattern
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetMaxItems() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxItems
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetMinItems() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MinItems
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetUniqueItems() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UniqueItems
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *JSONSchema) GetMaxProperties() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxProperties
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetMinProperties() uint64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MinProperties
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *JSONSchema) GetRequired() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Required
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *JSONSchema) GetArray() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Array
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *JSONSchema) GetType() []JSONSchema_JSONSchemaSimpleTypes <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *JSONSchema) GetFormat() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Format
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *JSONSchema) GetEnum() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Enum
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *JSONSchema) GetFieldConfiguration() *JSONSchema_FieldConfiguration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FieldConfiguration
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *JSONSchema) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// `Tag` is a representation of OpenAPI v2 specification's Tag object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#tagObject
type Tag struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // The name of the tag. Use it to allow override of the name of a
        // global Tag object, then use that name to reference the tag throughout the
        // OpenAPI file.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // A short description for the tag. GFM syntax can be used for rich text
        // representation.
        Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        // Additional external documentation for this tag.
        ExternalDocs *ExternalDocumentation `protobuf:"bytes,3,opt,name=external_docs,json=externalDocs,proto3" json:"external_docs,omitempty"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value `protobuf:"bytes,4,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *Tag) Reset() <span class="cov0" title="0">{
        *x = Tag{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[12]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Tag) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Tag) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Tag) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[12]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Tag.ProtoReflect.Descriptor instead.
func (*Tag) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{12}
}</span>

func (x *Tag) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Tag) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Tag) GetExternalDocs() *ExternalDocumentation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExternalDocs
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Tag) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// `SecurityDefinitions` is a representation of OpenAPI v2 specification's
// Security Definitions object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securityDefinitionsObject
//
// A declaration of the security schemes available to be used in the
// specification. This does not enforce the security schemes on the operations
// and only serves to provide the relevant details for each scheme.
type SecurityDefinitions struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // A single security scheme definition, mapping a "name" to the scheme it
        // defines.
        Security map[string]*SecurityScheme `protobuf:"bytes,1,rep,name=security,proto3" json:"security,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *SecurityDefinitions) Reset() <span class="cov0" title="0">{
        *x = SecurityDefinitions{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[13]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SecurityDefinitions) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SecurityDefinitions) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SecurityDefinitions) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[13]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SecurityDefinitions.ProtoReflect.Descriptor instead.
func (*SecurityDefinitions) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{13}
}</span>

func (x *SecurityDefinitions) GetSecurity() map[string]*SecurityScheme <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Security
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// `SecurityScheme` is a representation of OpenAPI v2 specification's
// Security Scheme object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securitySchemeObject
//
// Allows the definition of a security scheme that can be used by the
// operations. Supported schemes are basic authentication, an API key (either as
// a header or as a query parameter) and OAuth2's common flows (implicit,
// password, application and access code).
type SecurityScheme struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // The type of the security scheme. Valid values are "basic",
        // "apiKey" or "oauth2".
        Type SecurityScheme_Type `protobuf:"varint,1,opt,name=type,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme_Type" json:"type,omitempty"`
        // A short description for security scheme.
        Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        // The name of the header or query parameter to be used.
        // Valid for apiKey.
        Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
        // The location of the API key. Valid values are "query" or
        // "header".
        // Valid for apiKey.
        In SecurityScheme_In `protobuf:"varint,4,opt,name=in,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme_In" json:"in,omitempty"`
        // The flow used by the OAuth2 security scheme. Valid values are
        // "implicit", "password", "application" or "accessCode".
        // Valid for oauth2.
        Flow SecurityScheme_Flow `protobuf:"varint,5,opt,name=flow,proto3,enum=grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme_Flow" json:"flow,omitempty"`
        // The authorization URL to be used for this flow. This SHOULD be in
        // the form of a URL.
        // Valid for oauth2/implicit and oauth2/accessCode.
        AuthorizationUrl string `protobuf:"bytes,6,opt,name=authorization_url,json=authorizationUrl,proto3" json:"authorization_url,omitempty"`
        // The token URL to be used for this flow. This SHOULD be in the
        // form of a URL.
        // Valid for oauth2/password, oauth2/application and oauth2/accessCode.
        TokenUrl string `protobuf:"bytes,7,opt,name=token_url,json=tokenUrl,proto3" json:"token_url,omitempty"`
        // The available scopes for the OAuth2 security scheme.
        // Valid for oauth2.
        Scopes *Scopes `protobuf:"bytes,8,opt,name=scopes,proto3" json:"scopes,omitempty"`
        // Custom properties that start with "x-" such as "x-foo" used to describe
        // extra functionality that is not covered by the standard OpenAPI Specification.
        // See: https://swagger.io/docs/specification/2-0/swagger-extensions/
        Extensions map[string]*structpb.Value `protobuf:"bytes,9,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *SecurityScheme) Reset() <span class="cov0" title="0">{
        *x = SecurityScheme{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[14]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SecurityScheme) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SecurityScheme) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SecurityScheme) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[14]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SecurityScheme.ProtoReflect.Descriptor instead.
func (*SecurityScheme) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{14}
}</span>

func (x *SecurityScheme) GetType() SecurityScheme_Type <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return SecurityScheme_TYPE_INVALID</span>
}

func (x *SecurityScheme) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SecurityScheme) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SecurityScheme) GetIn() SecurityScheme_In <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.In
        }</span>
        <span class="cov0" title="0">return SecurityScheme_IN_INVALID</span>
}

func (x *SecurityScheme) GetFlow() SecurityScheme_Flow <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Flow
        }</span>
        <span class="cov0" title="0">return SecurityScheme_FLOW_INVALID</span>
}

func (x *SecurityScheme) GetAuthorizationUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AuthorizationUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SecurityScheme) GetTokenUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TokenUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SecurityScheme) GetScopes() *Scopes <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Scopes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SecurityScheme) GetExtensions() map[string]*structpb.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Extensions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// `SecurityRequirement` is a representation of OpenAPI v2 specification's
// Security Requirement object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#securityRequirementObject
//
// Lists the required security schemes to execute this operation. The object can
// have multiple security schemes declared in it which are all required (that
// is, there is a logical AND between the schemes).
//
// The name used for each property MUST correspond to a security scheme
// declared in the Security Definitions.
type SecurityRequirement struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Each name must correspond to a security scheme which is declared in
        // the Security Definitions. If the security scheme is of type "oauth2",
        // then the value is a list of scope names required for the execution.
        // For other security scheme types, the array MUST be empty.
        SecurityRequirement map[string]*SecurityRequirement_SecurityRequirementValue `protobuf:"bytes,1,rep,name=security_requirement,json=securityRequirement,proto3" json:"security_requirement,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *SecurityRequirement) Reset() <span class="cov0" title="0">{
        *x = SecurityRequirement{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[15]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SecurityRequirement) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SecurityRequirement) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SecurityRequirement) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[15]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SecurityRequirement.ProtoReflect.Descriptor instead.
func (*SecurityRequirement) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{15}
}</span>

func (x *SecurityRequirement) GetSecurityRequirement() map[string]*SecurityRequirement_SecurityRequirementValue <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SecurityRequirement
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// `Scopes` is a representation of OpenAPI v2 specification's Scopes object.
//
// See: https://github.com/OAI/OpenAPI-Specification/blob/3.0.0/versions/2.0.md#scopesObject
//
// Lists the available scopes for an OAuth2 security scheme.
type Scopes struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Maps between a name of a scope to a short description of it (as the value
        // of the property).
        Scope map[string]string `protobuf:"bytes,1,rep,name=scope,proto3" json:"scope,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *Scopes) Reset() <span class="cov0" title="0">{
        *x = Scopes{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[16]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Scopes) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Scopes) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Scopes) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[16]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Scopes.ProtoReflect.Descriptor instead.
func (*Scopes) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{16}
}</span>

func (x *Scopes) GetScope() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Scope
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// 'FieldConfiguration' provides additional field level properties used when generating the OpenAPI v2 file.
// These properties are not defined by OpenAPIv2, but they are used to control the generation.
type JSONSchema_FieldConfiguration struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Alternative parameter name when used as path parameter. If set, this will
        // be used as the complete parameter name when this field is used as a path
        // parameter. Use this to avoid having auto generated path parameter names
        // for overlapping paths.
        PathParamName string `protobuf:"bytes,47,opt,name=path_param_name,json=pathParamName,proto3" json:"path_param_name,omitempty"`
}

func (x *JSONSchema_FieldConfiguration) Reset() <span class="cov0" title="0">{
        *x = JSONSchema_FieldConfiguration{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[25]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *JSONSchema_FieldConfiguration) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*JSONSchema_FieldConfiguration) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *JSONSchema_FieldConfiguration) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[25]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use JSONSchema_FieldConfiguration.ProtoReflect.Descriptor instead.
func (*JSONSchema_FieldConfiguration) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{11, 0}
}</span>

func (x *JSONSchema_FieldConfiguration) GetPathParamName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PathParamName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// If the security scheme is of type "oauth2", then the value is a list of
// scope names required for the execution. For other security scheme types,
// the array MUST be empty.
type SecurityRequirement_SecurityRequirementValue struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Scope []string `protobuf:"bytes,1,rep,name=scope,proto3" json:"scope,omitempty"`
}

func (x *SecurityRequirement_SecurityRequirementValue) Reset() <span class="cov0" title="0">{
        *x = SecurityRequirement_SecurityRequirementValue{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[30]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SecurityRequirement_SecurityRequirementValue) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SecurityRequirement_SecurityRequirementValue) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SecurityRequirement_SecurityRequirementValue) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[30]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SecurityRequirement_SecurityRequirementValue.ProtoReflect.Descriptor instead.
func (*SecurityRequirement_SecurityRequirementValue) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP(), []int{15, 0}
}</span>

func (x *SecurityRequirement_SecurityRequirementValue) GetScope() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Scope
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_protoc_gen_openapiv2_options_openapiv2_proto protoreflect.FileDescriptor

var file_protoc_gen_openapiv2_options_openapiv2_proto_rawDesc = []byte{
        0x0a, 0x2c, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x2d, 0x67, 0x65, 0x6e, 0x2d, 0x6f, 0x70, 0x65,
        0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x29,
        0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x1c, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
        0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x73, 0x74, 0x72, 0x75, 0x63,
        0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xb3, 0x08, 0x0a, 0x07, 0x53, 0x77, 0x61, 0x67,
        0x67, 0x65, 0x72, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x73, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72, 0x12, 0x43, 0x0a,
        0x04, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x67, 0x72,
        0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e,
        0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x04, 0x69, 0x6e,
        0x66, 0x6f, 0x12, 0x12, 0x0a, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x70,
        0x61, 0x74, 0x68, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x62, 0x61, 0x73, 0x65, 0x50,
        0x61, 0x74, 0x68, 0x12, 0x4b, 0x0a, 0x07, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x73, 0x18, 0x05,
        0x20, 0x03, 0x28, 0x0e, 0x32, 0x31, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65,
        0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x2e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x52, 0x07, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x73,
        0x12, 0x1a, 0x0a, 0x08, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x73, 0x18, 0x06, 0x20, 0x03,
        0x28, 0x09, 0x52, 0x08, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x73, 0x12, 0x1a, 0x0a, 0x08,
        0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08,
        0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x73, 0x12, 0x5f, 0x0a, 0x09, 0x72, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x41, 0x2e, 0x67, 0x72,
        0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e,
        0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72, 0x2e,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x09,
        0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x12, 0x71, 0x0a, 0x14, 0x73, 0x65, 0x63,
        0x75, 0x72, 0x69, 0x74, 0x79, 0x5f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x3e, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67,
        0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65,
        0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x44, 0x65, 0x66, 0x69,
        0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x52, 0x13, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74,
        0x79, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x5a, 0x0a, 0x08,
        0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x18, 0x0c, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x3e,
        0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69,
        0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72,
        0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x52, 0x08,
        0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x12, 0x42, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73,
        0x18, 0x0d, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61,
        0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e,
        0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x2e, 0x54, 0x61, 0x67, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x12, 0x65, 0x0a, 0x0d,
        0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x64, 0x6f, 0x63, 0x73, 0x18, 0x0e, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x40, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77,
        0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70,
        0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e,
        0x45, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44,
        0x6f, 0x63, 0x73, 0x12, 0x62, 0x0a, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e,
        0x73, 0x18, 0x0f, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x42, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67,
        0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65,
        0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x77, 0x61, 0x67, 0x67, 0x65, 0x72, 0x2e, 0x45, 0x78, 0x74, 0x65,
        0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x65, 0x78, 0x74,
        0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x71, 0x0a, 0x0e, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x49, 0x0a, 0x05, 0x76,
        0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x67, 0x72, 0x70,
        0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
        0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x52,
        0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x1a, 0x55, 0x0a, 0x0f, 0x45, 0x78,
        0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a,
        0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12,
        0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38,
        0x01, 0x4a, 0x04, 0x08, 0x08, 0x10, 0x09, 0x4a, 0x04, 0x08, 0x09, 0x10, 0x0a, 0x22, 0xd6, 0x07,
        0x0a, 0x09, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a, 0x04, 0x74,
        0x61, 0x67, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x12,
        0x18, 0x0a, 0x07, 0x73, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x07, 0x73, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73,
        0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b,
        0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x65, 0x0a, 0x0d, 0x65,
        0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x64, 0x6f, 0x63, 0x73, 0x18, 0x04, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x40, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61,
        0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65,
        0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x45,
        0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f,
        0x63, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
        0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65,
        0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65,
        0x73, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x73, 0x18, 0x07, 0x20,
        0x03, 0x28, 0x09, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x73, 0x12, 0x61, 0x0a,
        0x09, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b,
        0x32, 0x43, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61,
        0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4f, 0x70, 0x65,
        0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x09, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73,
        0x12, 0x4b, 0x0a, 0x07, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28,
        0x0e, 0x32, 0x31, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e,
        0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x63,
        0x68, 0x65, 0x6d, 0x65, 0x52, 0x07, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x73, 0x12, 0x1e, 0x0a,
        0x0a, 0x64, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0x18, 0x0b, 0x20, 0x01, 0x28,
        0x08, 0x52, 0x0a, 0x64, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0x12, 0x5a, 0x0a,
        0x08, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x18, 0x0c, 0x20, 0x03, 0x28, 0x0b, 0x32,
        0x3e, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70,
        0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75,
        0x72, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x52,
        0x08, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x12, 0x64, 0x0a, 0x0a, 0x65, 0x78, 0x74,
        0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x0d, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x44, 0x2e,
        0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e,
        0x74, 0x72, 0x79, 0x52, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x12,
        0x55, 0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x0e, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77,
        0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70,
        0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e,
        0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x52, 0x0a, 0x70, 0x61, 0x72, 0x61,
        0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x1a, 0x71, 0x0a, 0x0e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x49, 0x0a, 0x05, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x67, 0x72, 0x70, 0x63,
        0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f,
        0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x52, 0x05,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x1a, 0x55, 0x0a, 0x0f, 0x45, 0x78, 0x74,
        0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03,
        0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x2c,
        0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e,
        0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
        0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01,
        0x4a, 0x04, 0x08, 0x08, 0x10, 0x09, 0x22, 0x62, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65,
        0x74, 0x65, 0x72, 0x73, 0x12, 0x54, 0x0a, 0x07, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x18,
        0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x3a, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74,
        0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f,
        0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x2e, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
        0x72, 0x52, 0x07, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x22, 0xa3, 0x02, 0x0a, 0x0f, 0x48,
        0x65, 0x61, 0x64, 0x65, 0x72, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x12, 0x12,
        0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61,
        0x6d, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x12, 0x53, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x0e, 0x32, 0x3f, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61,
        0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65,
        0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x48,
        0x65, 0x61, 0x64, 0x65, 0x72, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x2e, 0x54,
        0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x66, 0x6f, 0x72,
        0x6d, 0x61, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61,
        0x74, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x18, 0x05, 0x20,
        0x01, 0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x45, 0x0a,
        0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e,
        0x10, 0x00, 0x12, 0x0a, 0x0a, 0x06, 0x53, 0x54, 0x52, 0x49, 0x4e, 0x47, 0x10, 0x01, 0x12, 0x0a,
        0x0a, 0x06, 0x4e, 0x55, 0x4d, 0x42, 0x45, 0x52, 0x10, 0x02, 0x12, 0x0b, 0x0a, 0x07, 0x49, 0x4e,
        0x54, 0x45, 0x47, 0x45, 0x52, 0x10, 0x03, 0x12, 0x0b, 0x0a, 0x07, 0x42, 0x4f, 0x4f, 0x4c, 0x45,
        0x41, 0x4e, 0x10, 0x04, 0x4a, 0x04, 0x08, 0x06, 0x10, 0x07, 0x4a, 0x04, 0x08, 0x07, 0x10, 0x08,
        0x22, 0xd8, 0x01, 0x0a, 0x06, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x12, 0x20, 0x0a, 0x0b, 0x64,
        0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a,
        0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x79, 0x70,
        0x65, 0x12, 0x16, 0x0a, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x64, 0x65, 0x66,
        0x61, 0x75, 0x6c, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x64, 0x65, 0x66, 0x61,
        0x75, 0x6c, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x18, 0x0d,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x4a, 0x04, 0x08,
        0x04, 0x10, 0x05, 0x4a, 0x04, 0x08, 0x05, 0x10, 0x06, 0x4a, 0x04, 0x08, 0x07, 0x10, 0x08, 0x4a,
        0x04, 0x08, 0x08, 0x10, 0x09, 0x4a, 0x04, 0x08, 0x09, 0x10, 0x0a, 0x4a, 0x04, 0x08, 0x0a, 0x10,
        0x0b, 0x4a, 0x04, 0x08, 0x0b, 0x10, 0x0c, 0x4a, 0x04, 0x08, 0x0c, 0x10, 0x0d, 0x4a, 0x04, 0x08,
        0x0e, 0x10, 0x0f, 0x4a, 0x04, 0x08, 0x0f, 0x10, 0x10, 0x4a, 0x04, 0x08, 0x10, 0x10, 0x11, 0x4a,
        0x04, 0x08, 0x11, 0x10, 0x12, 0x4a, 0x04, 0x08, 0x12, 0x10, 0x13, 0x22, 0x9a, 0x05, 0x0a, 0x08,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63,
        0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64,
        0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x49, 0x0a, 0x06, 0x73, 0x63,
        0x68, 0x65, 0x6d, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x67, 0x72, 0x70,
        0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
        0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x52, 0x06, 0x73,
        0x63, 0x68, 0x65, 0x6d, 0x61, 0x12, 0x5a, 0x0a, 0x07, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73,
        0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x40, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61,
        0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e,
        0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x48, 0x65, 0x61, 0x64,
        0x65, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x07, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72,
        0x73, 0x12, 0x5d, 0x0a, 0x08, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x73, 0x18, 0x04, 0x20,
        0x03, 0x28, 0x0b, 0x32, 0x41, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77,
        0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70,
        0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x45, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65,
        0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x08, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x73,
        0x12, 0x63, 0x0a, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x05,
        0x20, 0x03, 0x28, 0x0b, 0x32, 0x43, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65,
        0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73,
        0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e,
        0x73, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x6d, 0x0a, 0x0c, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x47, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61,
        0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e,
        0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x2e, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x3a, 0x02, 0x38, 0x01, 0x1a, 0x3b, 0x0a, 0x0d, 0x45, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x73,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38,
        0x01, 0x1a, 0x55, 0x0a, 0x0f, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45,
        0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76,
        0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xd6, 0x03, 0x0a, 0x04, 0x49, 0x6e, 0x66,
        0x6f, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x05, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72,
        0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65,
        0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x28, 0x0a, 0x10, 0x74, 0x65, 0x72,
        0x6d, 0x73, 0x5f, 0x6f, 0x66, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x18, 0x03, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x65, 0x72, 0x6d, 0x73, 0x4f, 0x66, 0x53, 0x65, 0x72, 0x76,
        0x69, 0x63, 0x65, 0x12, 0x4c, 0x0a, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x63, 0x74, 0x18, 0x04,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65,
        0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x63, 0x74, 0x52, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x63,
        0x74, 0x12, 0x4c, 0x0a, 0x07, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x18, 0x05, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x32, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61,
        0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65,
        0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4c,
        0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x52, 0x07, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x12,
        0x18, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x5f, 0x0a, 0x0a, 0x65, 0x78, 0x74,
        0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x3f, 0x2e,
        0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x45,
        0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a,
        0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x55, 0x0a, 0x0f, 0x45, 0x78,
        0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a,
        0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12,
        0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38,
        0x01, 0x22, 0x45, 0x0a, 0x07, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x63, 0x74, 0x12, 0x12, 0x0a, 0x04,
        0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65,
        0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75,
        0x72, 0x6c, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x22, 0x2f, 0x0a, 0x07, 0x4c, 0x69, 0x63, 0x65,
        0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75, 0x72, 0x6c, 0x22, 0x4b, 0x0a, 0x15, 0x45, 0x78, 0x74,
        0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x03, 0x75, 0x72, 0x6c, 0x22, 0xaa, 0x02, 0x0a, 0x06, 0x53, 0x63, 0x68, 0x65, 0x6d,
        0x61, 0x12, 0x56, 0x0a, 0x0b, 0x6a, 0x73, 0x6f, 0x6e, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61,
        0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e,
        0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x2e, 0x4a, 0x53, 0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x52, 0x0a, 0x6a,
        0x73, 0x6f, 0x6e, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x12, 0x24, 0x0a, 0x0d, 0x64, 0x69, 0x73,
        0x63, 0x72, 0x69, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x0d, 0x64, 0x69, 0x73, 0x63, 0x72, 0x69, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x6f, 0x72, 0x12,
        0x1b, 0x0a, 0x09, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x6f, 0x6e, 0x6c, 0x79, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0x12, 0x65, 0x0a, 0x0d,
        0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x64, 0x6f, 0x63, 0x73, 0x18, 0x05, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x40, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77,
        0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70,
        0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e,
        0x45, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44,
        0x6f, 0x63, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x18, 0x06,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x4a, 0x04, 0x08,
        0x04, 0x10, 0x05, 0x22, 0xd7, 0x0a, 0x0a, 0x0a, 0x4a, 0x53, 0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65,
        0x6d, 0x61, 0x12, 0x10, 0x0a, 0x03, 0x72, 0x65, 0x66, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x03, 0x72, 0x65, 0x66, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x18, 0x05, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65,
        0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x18, 0x0a, 0x07,
        0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x64,
        0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x6f,
        0x6e, 0x6c, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x72, 0x65, 0x61, 0x64, 0x4f,
        0x6e, 0x6c, 0x79, 0x12, 0x18, 0x0a, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x18, 0x09,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x12, 0x1f, 0x0a,
        0x0b, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x5f, 0x6f, 0x66, 0x18, 0x0a, 0x20, 0x01,
        0x28, 0x01, 0x52, 0x0a, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x4f, 0x66, 0x12, 0x18,
        0x0a, 0x07, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x01, 0x52,
        0x07, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x12, 0x2b, 0x0a, 0x11, 0x65, 0x78, 0x63, 0x6c,
        0x75, 0x73, 0x69, 0x76, 0x65, 0x5f, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x18, 0x0c, 0x20,
        0x01, 0x28, 0x08, 0x52, 0x10, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x73, 0x69, 0x76, 0x65, 0x4d, 0x61,
        0x78, 0x69, 0x6d, 0x75, 0x6d, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d,
        0x18, 0x0d, 0x20, 0x01, 0x28, 0x01, 0x52, 0x07, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x12,
        0x2b, 0x0a, 0x11, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x73, 0x69, 0x76, 0x65, 0x5f, 0x6d, 0x69, 0x6e,
        0x69, 0x6d, 0x75, 0x6d, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x08, 0x52, 0x10, 0x65, 0x78, 0x63, 0x6c,
        0x75, 0x73, 0x69, 0x76, 0x65, 0x4d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x12, 0x1d, 0x0a, 0x0a,
        0x6d, 0x61, 0x78, 0x5f, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x04,
        0x52, 0x09, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x12, 0x1d, 0x0a, 0x0a, 0x6d,
        0x69, 0x6e, 0x5f, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x18, 0x10, 0x20, 0x01, 0x28, 0x04, 0x52,
        0x09, 0x6d, 0x69, 0x6e, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61,
        0x74, 0x74, 0x65, 0x72, 0x6e, 0x18, 0x11, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x61, 0x74,
        0x74, 0x65, 0x72, 0x6e, 0x12, 0x1b, 0x0a, 0x09, 0x6d, 0x61, 0x78, 0x5f, 0x69, 0x74, 0x65, 0x6d,
        0x73, 0x18, 0x14, 0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x6d, 0x61, 0x78, 0x49, 0x74, 0x65, 0x6d,
        0x73, 0x12, 0x1b, 0x0a, 0x09, 0x6d, 0x69, 0x6e, 0x5f, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18, 0x15,
        0x20, 0x01, 0x28, 0x04, 0x52, 0x08, 0x6d, 0x69, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x12, 0x21,
        0x0a, 0x0c, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x5f, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x18, 0x16,
        0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x49, 0x74, 0x65, 0x6d,
        0x73, 0x12, 0x25, 0x0a, 0x0e, 0x6d, 0x61, 0x78, 0x5f, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74,
        0x69, 0x65, 0x73, 0x18, 0x18, 0x20, 0x01, 0x28, 0x04, 0x52, 0x0d, 0x6d, 0x61, 0x78, 0x50, 0x72,
        0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x12, 0x25, 0x0a, 0x0e, 0x6d, 0x69, 0x6e, 0x5f,
        0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x18, 0x19, 0x20, 0x01, 0x28, 0x04,
        0x52, 0x0d, 0x6d, 0x69, 0x6e, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x12,
        0x1a, 0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x18, 0x1a, 0x20, 0x03, 0x28,
        0x09, 0x52, 0x08, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x61,
        0x72, 0x72, 0x61, 0x79, 0x18, 0x22, 0x20, 0x03, 0x28, 0x09, 0x52, 0x05, 0x61, 0x72, 0x72, 0x61,
        0x79, 0x12, 0x5f, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x23, 0x20, 0x03, 0x28, 0x0e, 0x32,
        0x4b, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70,
        0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4a, 0x53, 0x4f, 0x4e,
        0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x4a, 0x53, 0x4f, 0x4e, 0x53, 0x63, 0x68, 0x65, 0x6d,
        0x61, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x73, 0x52, 0x04, 0x74, 0x79,
        0x70, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x24, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x65, 0x6e,
        0x75, 0x6d, 0x18, 0x2e, 0x20, 0x03, 0x28, 0x09, 0x52, 0x04, 0x65, 0x6e, 0x75, 0x6d, 0x12, 0x7a,
        0x0a, 0x13, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0xe9, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x48, 0x2e, 0x67,
        0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32,
        0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4a, 0x53, 0x4f, 0x4e, 0x53, 0x63, 0x68,
        0x65, 0x6d, 0x61, 0x2e, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75,
        0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x12, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x6f, 0x6e,
        0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x65, 0x0a, 0x0a, 0x65, 0x78,
        0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x30, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x45,
        0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69,
        0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x4a, 0x53, 0x4f, 0x4e, 0x53,
        0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e,
        0x73, 0x1a, 0x3c, 0x0a, 0x12, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,
        0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x26, 0x0a, 0x0f, 0x70, 0x61, 0x74, 0x68, 0x5f,
        0x70, 0x61, 0x72, 0x61, 0x6d, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x2f, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x0d, 0x70, 0x61, 0x74, 0x68, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x4e, 0x61, 0x6d, 0x65, 0x1a,
        0x55, 0x0a, 0x0f, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x45, 0x6e, 0x74,
        0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x03, 0x6b, 0x65, 0x79, 0x12, 0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c,
        0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x77, 0x0a, 0x15, 0x4a, 0x53, 0x4f, 0x4e, 0x53, 0x63,
        0x68, 0x65, 0x6d, 0x61, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x73, 0x12,
        0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x09, 0x0a, 0x05,
        0x41, 0x52, 0x52, 0x41, 0x59, 0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x42, 0x4f, 0x4f, 0x4c, 0x45,
        0x41, 0x4e, 0x10, 0x02, 0x12, 0x0b, 0x0a, 0x07, 0x49, 0x4e, 0x54, 0x45, 0x47, 0x45, 0x52, 0x10,
        0x03, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x55, 0x4c, 0x4c, 0x10, 0x04, 0x12, 0x0a, 0x0a, 0x06, 0x4e,
        0x55, 0x4d, 0x42, 0x45, 0x52, 0x10, 0x05, 0x12, 0x0a, 0x0a, 0x06, 0x4f, 0x42, 0x4a, 0x45, 0x43,
        0x54, 0x10, 0x06, 0x12, 0x0a, 0x0a, 0x06, 0x53, 0x54, 0x52, 0x49, 0x4e, 0x47, 0x10, 0x07, 0x4a,
        0x04, 0x08, 0x01, 0x10, 0x02, 0x4a, 0x04, 0x08, 0x02, 0x10, 0x03, 0x4a, 0x04, 0x08, 0x04, 0x10,
        0x05, 0x4a, 0x04, 0x08, 0x12, 0x10, 0x13, 0x4a, 0x04, 0x08, 0x13, 0x10, 0x14, 0x4a, 0x04, 0x08,
        0x17, 0x10, 0x18, 0x4a, 0x04, 0x08, 0x1b, 0x10, 0x1c, 0x4a, 0x04, 0x08, 0x1c, 0x10, 0x1d, 0x4a,
        0x04, 0x08, 0x1d, 0x10, 0x1e, 0x4a, 0x04, 0x08, 0x1e, 0x10, 0x22, 0x4a, 0x04, 0x08, 0x25, 0x10,
        0x2a, 0x4a, 0x04, 0x08, 0x2a, 0x10, 0x2b, 0x4a, 0x04, 0x08, 0x2b, 0x10, 0x2e, 0x22, 0xd9, 0x02,
        0x0a, 0x03, 0x54, 0x61, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73,
        0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b,
        0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x65, 0x0a, 0x0d, 0x65,
        0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x5f, 0x64, 0x6f, 0x63, 0x73, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x40, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61,
        0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65,
        0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x45,
        0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x44, 0x6f,
        0x63, 0x73, 0x12, 0x5e, 0x0a, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73,
        0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x3e, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61,
        0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e,
        0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x2e, 0x54, 0x61, 0x67, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e,
        0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f,
        0x6e, 0x73, 0x1a, 0x55, 0x0a, 0x0f, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xf7, 0x01, 0x0a, 0x13, 0x53, 0x65,
        0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x12, 0x68, 0x0a, 0x08, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20,
        0x03, 0x28, 0x0b, 0x32, 0x4c, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77,
        0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70,
        0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e,
        0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x45, 0x6e, 0x74, 0x72,
        0x79, 0x52, 0x08, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x1a, 0x76, 0x0a, 0x0d, 0x53,
        0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03,
        0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x4f,
        0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x39, 0x2e,
        0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76,
        0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69,
        0x74, 0x79, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a,
        0x02, 0x38, 0x01, 0x22, 0xff, 0x06, 0x0a, 0x0e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79,
        0x53, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x12, 0x52, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x0e, 0x32, 0x3e, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65,
        0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f,
        0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x2e,
        0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65,
        0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a, 0x04,
        0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65,
        0x12, 0x4c, 0x0a, 0x02, 0x69, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x3c, 0x2e, 0x67,
        0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32,
        0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74,
        0x79, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x2e, 0x49, 0x6e, 0x52, 0x02, 0x69, 0x6e, 0x12, 0x52,
        0x0a, 0x04, 0x66, 0x6c, 0x6f, 0x77, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x3e, 0x2e, 0x67,
        0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32,
        0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74,
        0x79, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x2e, 0x46, 0x6c, 0x6f, 0x77, 0x52, 0x04, 0x66, 0x6c,
        0x6f, 0x77, 0x12, 0x2b, 0x0a, 0x11, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x5f, 0x75, 0x72, 0x6c, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x61,
        0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x55, 0x72, 0x6c, 0x12,
        0x1b, 0x0a, 0x09, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x75, 0x72, 0x6c, 0x18, 0x07, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x08, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x55, 0x72, 0x6c, 0x12, 0x49, 0x0a, 0x06,
        0x73, 0x63, 0x6f, 0x70, 0x65, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x67,
        0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32,
        0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x63, 0x6f, 0x70, 0x65, 0x73, 0x52,
        0x06, 0x73, 0x63, 0x6f, 0x70, 0x65, 0x73, 0x12, 0x69, 0x0a, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e,
        0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x49, 0x2e, 0x67, 0x72,
        0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e,
        0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79,
        0x53, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e,
        0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f,
        0x6e, 0x73, 0x1a, 0x55, 0x0a, 0x0f, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x73,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x2c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x4b, 0x0a, 0x04, 0x54, 0x79, 0x70,
        0x65, 0x12, 0x10, 0x0a, 0x0c, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49,
        0x44, 0x10, 0x00, 0x12, 0x0e, 0x0a, 0x0a, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x42, 0x41, 0x53, 0x49,
        0x43, 0x10, 0x01, 0x12, 0x10, 0x0a, 0x0c, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x41, 0x50, 0x49, 0x5f,
        0x4b, 0x45, 0x59, 0x10, 0x02, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x4f, 0x41,
        0x55, 0x54, 0x48, 0x32, 0x10, 0x03, 0x22, 0x31, 0x0a, 0x02, 0x49, 0x6e, 0x12, 0x0e, 0x0a, 0x0a,
        0x49, 0x4e, 0x5f, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x10, 0x00, 0x12, 0x0c, 0x0a, 0x08,
        0x49, 0x4e, 0x5f, 0x51, 0x55, 0x45, 0x52, 0x59, 0x10, 0x01, 0x12, 0x0d, 0x0a, 0x09, 0x49, 0x4e,
        0x5f, 0x48, 0x45, 0x41, 0x44, 0x45, 0x52, 0x10, 0x02, 0x22, 0x6a, 0x0a, 0x04, 0x46, 0x6c, 0x6f,
        0x77, 0x12, 0x10, 0x0a, 0x0c, 0x46, 0x4c, 0x4f, 0x57, 0x5f, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49,
        0x44, 0x10, 0x00, 0x12, 0x11, 0x0a, 0x0d, 0x46, 0x4c, 0x4f, 0x57, 0x5f, 0x49, 0x4d, 0x50, 0x4c,
        0x49, 0x43, 0x49, 0x54, 0x10, 0x01, 0x12, 0x11, 0x0a, 0x0d, 0x46, 0x4c, 0x4f, 0x57, 0x5f, 0x50,
        0x41, 0x53, 0x53, 0x57, 0x4f, 0x52, 0x44, 0x10, 0x02, 0x12, 0x14, 0x0a, 0x10, 0x46, 0x4c, 0x4f,
        0x57, 0x5f, 0x41, 0x50, 0x50, 0x4c, 0x49, 0x43, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x03, 0x12,
        0x14, 0x0a, 0x10, 0x46, 0x4c, 0x4f, 0x57, 0x5f, 0x41, 0x43, 0x43, 0x45, 0x53, 0x53, 0x5f, 0x43,
        0x4f, 0x44, 0x45, 0x10, 0x04, 0x22, 0xf6, 0x02, 0x0a, 0x13, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69,
        0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x8a, 0x01,
        0x0a, 0x14, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x69,
        0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x57, 0x2e, 0x67,
        0x72, 0x70, 0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x63, 0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32,
        0x2e, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74,
        0x79, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x65, 0x63,
        0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x13, 0x73, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52,
        0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x1a, 0x30, 0x0a, 0x18, 0x53, 0x65,
        0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e,
        0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x63, 0x6f, 0x70, 0x65, 0x18,
        0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x05, 0x73, 0x63, 0x6f, 0x70, 0x65, 0x1a, 0x9f, 0x01, 0x0a,
        0x18, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65,
        0x6d, 0x65, 0x6e, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x6d, 0x0a, 0x05, 0x76,
        0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x57, 0x2e, 0x67, 0x72, 0x70,
        0x63, 0x2e, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
        0x5f, 0x67, 0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72, 0x69, 0x74, 0x79, 0x52,
        0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x53, 0x65, 0x63, 0x75, 0x72,
        0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x56, 0x61,
        0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x96,
        0x01, 0x0a, 0x06, 0x53, 0x63, 0x6f, 0x70, 0x65, 0x73, 0x12, 0x52, 0x0a, 0x05, 0x73, 0x63, 0x6f,
        0x70, 0x65, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x3c, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e,
        0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x5f, 0x67,
        0x65, 0x6e, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2e, 0x6f, 0x70, 0x74,
        0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x53, 0x63, 0x6f, 0x70, 0x65, 0x73, 0x2e, 0x53, 0x63, 0x6f, 0x70,
        0x65, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x05, 0x73, 0x63, 0x6f, 0x70, 0x65, 0x1a, 0x38, 0x0a,
        0x0a, 0x53, 0x63, 0x6f, 0x70, 0x65, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b,
        0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a,
        0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x2a, 0x3b, 0x0a, 0x06, 0x53, 0x63, 0x68, 0x65, 0x6d,
        0x65, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00, 0x12, 0x08,
        0x0a, 0x04, 0x48, 0x54, 0x54, 0x50, 0x10, 0x01, 0x12, 0x09, 0x0a, 0x05, 0x48, 0x54, 0x54, 0x50,
        0x53, 0x10, 0x02, 0x12, 0x06, 0x0a, 0x02, 0x57, 0x53, 0x10, 0x03, 0x12, 0x07, 0x0a, 0x03, 0x57,
        0x53, 0x53, 0x10, 0x04, 0x42, 0x48, 0x5a, 0x46, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63,
        0x6f, 0x6d, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x2d, 0x65, 0x63, 0x6f, 0x73, 0x79, 0x73, 0x74, 0x65,
        0x6d, 0x2f, 0x67, 0x72, 0x70, 0x63, 0x2d, 0x67, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x2f, 0x76,
        0x32, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x2d, 0x67, 0x65, 0x6e, 0x2d, 0x6f, 0x70, 0x65,
        0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x62, 0x06,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescOnce sync.Once
        file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescData = file_protoc_gen_openapiv2_options_openapiv2_proto_rawDesc
)

func file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescData = protoimpl.X.CompressGZIP(file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_protoc_gen_openapiv2_options_openapiv2_proto_rawDescData</span>
}

var file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes = make([]protoimpl.EnumInfo, 6)
var file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes = make([]protoimpl.MessageInfo, 33)
var file_protoc_gen_openapiv2_options_openapiv2_proto_goTypes = []interface{}{
        (Scheme)(0),                           // 0: grpc.gateway.protoc_gen_openapiv2.options.Scheme
        (HeaderParameter_Type)(0),             // 1: grpc.gateway.protoc_gen_openapiv2.options.HeaderParameter.Type
        (JSONSchema_JSONSchemaSimpleTypes)(0), // 2: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.JSONSchemaSimpleTypes
        (SecurityScheme_Type)(0),              // 3: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Type
        (SecurityScheme_In)(0),                // 4: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.In
        (SecurityScheme_Flow)(0),              // 5: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Flow
        (*Swagger)(nil),                       // 6: grpc.gateway.protoc_gen_openapiv2.options.Swagger
        (*Operation)(nil),                     // 7: grpc.gateway.protoc_gen_openapiv2.options.Operation
        (*Parameters)(nil),                    // 8: grpc.gateway.protoc_gen_openapiv2.options.Parameters
        (*HeaderParameter)(nil),               // 9: grpc.gateway.protoc_gen_openapiv2.options.HeaderParameter
        (*Header)(nil),                        // 10: grpc.gateway.protoc_gen_openapiv2.options.Header
        (*Response)(nil),                      // 11: grpc.gateway.protoc_gen_openapiv2.options.Response
        (*Info)(nil),                          // 12: grpc.gateway.protoc_gen_openapiv2.options.Info
        (*Contact)(nil),                       // 13: grpc.gateway.protoc_gen_openapiv2.options.Contact
        (*License)(nil),                       // 14: grpc.gateway.protoc_gen_openapiv2.options.License
        (*ExternalDocumentation)(nil),         // 15: grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation
        (*Schema)(nil),                        // 16: grpc.gateway.protoc_gen_openapiv2.options.Schema
        (*JSONSchema)(nil),                    // 17: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema
        (*Tag)(nil),                           // 18: grpc.gateway.protoc_gen_openapiv2.options.Tag
        (*SecurityDefinitions)(nil),           // 19: grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions
        (*SecurityScheme)(nil),                // 20: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme
        (*SecurityRequirement)(nil),           // 21: grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement
        (*Scopes)(nil),                        // 22: grpc.gateway.protoc_gen_openapiv2.options.Scopes
        nil,                                   // 23: grpc.gateway.protoc_gen_openapiv2.options.Swagger.ResponsesEntry
        nil,                                   // 24: grpc.gateway.protoc_gen_openapiv2.options.Swagger.ExtensionsEntry
        nil,                                   // 25: grpc.gateway.protoc_gen_openapiv2.options.Operation.ResponsesEntry
        nil,                                   // 26: grpc.gateway.protoc_gen_openapiv2.options.Operation.ExtensionsEntry
        nil,                                   // 27: grpc.gateway.protoc_gen_openapiv2.options.Response.HeadersEntry
        nil,                                   // 28: grpc.gateway.protoc_gen_openapiv2.options.Response.ExamplesEntry
        nil,                                   // 29: grpc.gateway.protoc_gen_openapiv2.options.Response.ExtensionsEntry
        nil,                                   // 30: grpc.gateway.protoc_gen_openapiv2.options.Info.ExtensionsEntry
        (*JSONSchema_FieldConfiguration)(nil), // 31: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration
        nil,                                   // 32: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.ExtensionsEntry
        nil,                                   // 33: grpc.gateway.protoc_gen_openapiv2.options.Tag.ExtensionsEntry
        nil,                                   // 34: grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions.SecurityEntry
        nil,                                   // 35: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.ExtensionsEntry
        (*SecurityRequirement_SecurityRequirementValue)(nil), // 36: grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue
        nil,                    // 37: grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementEntry
        nil,                    // 38: grpc.gateway.protoc_gen_openapiv2.options.Scopes.ScopeEntry
        (*structpb.Value)(nil), // 39: google.protobuf.Value
}
var file_protoc_gen_openapiv2_options_openapiv2_proto_depIdxs = []int32{
        12, // 0: grpc.gateway.protoc_gen_openapiv2.options.Swagger.info:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Info
        0,  // 1: grpc.gateway.protoc_gen_openapiv2.options.Swagger.schemes:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Scheme
        23, // 2: grpc.gateway.protoc_gen_openapiv2.options.Swagger.responses:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Swagger.ResponsesEntry
        19, // 3: grpc.gateway.protoc_gen_openapiv2.options.Swagger.security_definitions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions
        21, // 4: grpc.gateway.protoc_gen_openapiv2.options.Swagger.security:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement
        18, // 5: grpc.gateway.protoc_gen_openapiv2.options.Swagger.tags:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Tag
        15, // 6: grpc.gateway.protoc_gen_openapiv2.options.Swagger.external_docs:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation
        24, // 7: grpc.gateway.protoc_gen_openapiv2.options.Swagger.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Swagger.ExtensionsEntry
        15, // 8: grpc.gateway.protoc_gen_openapiv2.options.Operation.external_docs:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation
        25, // 9: grpc.gateway.protoc_gen_openapiv2.options.Operation.responses:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Operation.ResponsesEntry
        0,  // 10: grpc.gateway.protoc_gen_openapiv2.options.Operation.schemes:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Scheme
        21, // 11: grpc.gateway.protoc_gen_openapiv2.options.Operation.security:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement
        26, // 12: grpc.gateway.protoc_gen_openapiv2.options.Operation.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Operation.ExtensionsEntry
        8,  // 13: grpc.gateway.protoc_gen_openapiv2.options.Operation.parameters:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Parameters
        9,  // 14: grpc.gateway.protoc_gen_openapiv2.options.Parameters.headers:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.HeaderParameter
        1,  // 15: grpc.gateway.protoc_gen_openapiv2.options.HeaderParameter.type:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.HeaderParameter.Type
        16, // 16: grpc.gateway.protoc_gen_openapiv2.options.Response.schema:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Schema
        27, // 17: grpc.gateway.protoc_gen_openapiv2.options.Response.headers:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Response.HeadersEntry
        28, // 18: grpc.gateway.protoc_gen_openapiv2.options.Response.examples:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Response.ExamplesEntry
        29, // 19: grpc.gateway.protoc_gen_openapiv2.options.Response.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Response.ExtensionsEntry
        13, // 20: grpc.gateway.protoc_gen_openapiv2.options.Info.contact:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Contact
        14, // 21: grpc.gateway.protoc_gen_openapiv2.options.Info.license:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.License
        30, // 22: grpc.gateway.protoc_gen_openapiv2.options.Info.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Info.ExtensionsEntry
        17, // 23: grpc.gateway.protoc_gen_openapiv2.options.Schema.json_schema:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.JSONSchema
        15, // 24: grpc.gateway.protoc_gen_openapiv2.options.Schema.external_docs:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation
        2,  // 25: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.type:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.JSONSchemaSimpleTypes
        31, // 26: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.field_configuration:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.FieldConfiguration
        32, // 27: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.ExtensionsEntry
        15, // 28: grpc.gateway.protoc_gen_openapiv2.options.Tag.external_docs:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.ExternalDocumentation
        33, // 29: grpc.gateway.protoc_gen_openapiv2.options.Tag.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Tag.ExtensionsEntry
        34, // 30: grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions.security:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions.SecurityEntry
        3,  // 31: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.type:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Type
        4,  // 32: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.in:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.In
        5,  // 33: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.flow:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.Flow
        22, // 34: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.scopes:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Scopes
        35, // 35: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.extensions:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.ExtensionsEntry
        37, // 36: grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.security_requirement:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementEntry
        38, // 37: grpc.gateway.protoc_gen_openapiv2.options.Scopes.scope:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Scopes.ScopeEntry
        11, // 38: grpc.gateway.protoc_gen_openapiv2.options.Swagger.ResponsesEntry.value:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Response
        39, // 39: grpc.gateway.protoc_gen_openapiv2.options.Swagger.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        11, // 40: grpc.gateway.protoc_gen_openapiv2.options.Operation.ResponsesEntry.value:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Response
        39, // 41: grpc.gateway.protoc_gen_openapiv2.options.Operation.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        10, // 42: grpc.gateway.protoc_gen_openapiv2.options.Response.HeadersEntry.value:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.Header
        39, // 43: grpc.gateway.protoc_gen_openapiv2.options.Response.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        39, // 44: grpc.gateway.protoc_gen_openapiv2.options.Info.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        39, // 45: grpc.gateway.protoc_gen_openapiv2.options.JSONSchema.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        39, // 46: grpc.gateway.protoc_gen_openapiv2.options.Tag.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        20, // 47: grpc.gateway.protoc_gen_openapiv2.options.SecurityDefinitions.SecurityEntry.value:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme
        39, // 48: grpc.gateway.protoc_gen_openapiv2.options.SecurityScheme.ExtensionsEntry.value:type_name -&gt; google.protobuf.Value
        36, // 49: grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementEntry.value:type_name -&gt; grpc.gateway.protoc_gen_openapiv2.options.SecurityRequirement.SecurityRequirementValue
        50, // [50:50] is the sub-list for method output_type
        50, // [50:50] is the sub-list for method input_type
        50, // [50:50] is the sub-list for extension type_name
        50, // [50:50] is the sub-list for extension extendee
        0,  // [0:50] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_protoc_gen_openapiv2_options_openapiv2_proto_init() }</span>
func file_protoc_gen_openapiv2_options_openapiv2_proto_init() <span class="cov0" title="0">{
        if File_protoc_gen_openapiv2_options_openapiv2_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Swagger); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Operation); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Parameters); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*HeaderParameter); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Header); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Response); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Info); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Contact); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*License); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ExternalDocumentation); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Schema); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*JSONSchema); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Tag); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SecurityDefinitions); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SecurityScheme); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SecurityRequirement); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Scopes); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*JSONSchema_FieldConfiguration); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes[30].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SecurityRequirement_SecurityRequirementValue); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_protoc_gen_openapiv2_options_openapiv2_proto_rawDesc,
                        NumEnums:      6,
                        NumMessages:   33,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_protoc_gen_openapiv2_options_openapiv2_proto_goTypes,
                DependencyIndexes: file_protoc_gen_openapiv2_options_openapiv2_proto_depIdxs,
                EnumInfos:         file_protoc_gen_openapiv2_options_openapiv2_proto_enumTypes,
                MessageInfos:      file_protoc_gen_openapiv2_options_openapiv2_proto_msgTypes,
        }.Build()
        File_protoc_gen_openapiv2_options_openapiv2_proto = out.File
        file_protoc_gen_openapiv2_options_openapiv2_proto_rawDesc = nil
        file_protoc_gen_openapiv2_options_openapiv2_proto_goTypes = nil
        file_protoc_gen_openapiv2_options_openapiv2_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright (c) 2023 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.30.0
//         protoc        v3.21.9
// source: service.proto

package challengeservice

import (
        _ "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2/options"
        _ "google.golang.org/genproto/googleapis/api/annotations"
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Request/Response Messages
type GetChallengesRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *GetChallengesRequest) Reset() <span class="cov0" title="0">{
        *x = GetChallengesRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_service_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetChallengesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetChallengesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetChallengesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_service_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetChallengesRequest.ProtoReflect.Descriptor instead.
func (*GetChallengesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_service_proto_rawDescGZIP(), []int{0}
}</span>

type GetChallengesResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Challenges []*Challenge `protobuf:"bytes,1,rep,name=challenges,proto3" json:"challenges,omitempty"`
}

func (x *GetChallengesResponse) Reset() <span class="cov0" title="0">{
        *x = GetChallengesResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_service_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetChallengesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetChallengesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetChallengesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_service_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetChallengesResponse.ProtoReflect.Descriptor instead.
func (*GetChallengesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_service_proto_rawDescGZIP(), []int{1}
}</span>

func (x *GetChallengesResponse) GetChallenges() []*Challenge <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Challenges
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ClaimRewardRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ChallengeId string `protobuf:"bytes,1,opt,name=challenge_id,json=challengeId,proto3" json:"challenge_id,omitempty"`
        GoalId      string `protobuf:"bytes,2,opt,name=goal_id,json=goalId,proto3" json:"goal_id,omitempty"`
}

func (x *ClaimRewardRequest) Reset() <span class="cov0" title="0">{
        *x = ClaimRewardRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_service_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ClaimRewardRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ClaimRewardRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ClaimRewardRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_service_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ClaimRewardRequest.ProtoReflect.Descriptor instead.
func (*ClaimRewardRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_service_proto_rawDescGZIP(), []int{2}
}</span>

func (x *ClaimRewardRequest) GetChallengeId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ChallengeId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ClaimRewardRequest) GetGoalId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.GoalId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ClaimRewardResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        GoalId    string  `protobuf:"bytes,1,opt,name=goal_id,json=goalId,proto3" json:"goal_id,omitempty"`
        Status    string  `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
        Reward    *Reward `protobuf:"bytes,3,opt,name=reward,proto3" json:"reward,omitempty"`
        ClaimedAt string  `protobuf:"bytes,4,opt,name=claimed_at,json=claimedAt,proto3" json:"claimed_at,omitempty"`
}

func (x *ClaimRewardResponse) Reset() <span class="cov0" title="0">{
        *x = ClaimRewardResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_service_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ClaimRewardResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ClaimRewardResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ClaimRewardResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_service_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ClaimRewardResponse.ProtoReflect.Descriptor instead.
func (*ClaimRewardResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_service_proto_rawDescGZIP(), []int{3}
}</span>

func (x *ClaimRewardResponse) GetGoalId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.GoalId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ClaimRewardResponse) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ClaimRewardResponse) GetReward() *Reward <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Reward
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ClaimRewardResponse) GetClaimedAt() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ClaimedAt
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type HealthCheckRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *HealthCheckRequest) Reset() <span class="cov0" title="0">{
        *x = HealthCheckRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_service_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *HealthCheckRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*HealthCheckRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *HealthCheckRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_service_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use HealthCheckRequest.ProtoReflect.Descriptor instead.
func (*HealthCheckRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_service_proto_rawDescGZIP(), []int{4}
}</span>

type HealthCheckResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Status string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *HealthCheckResponse) Reset() <span class="cov0" title="0">{
        *x = HealthCheckResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_service_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *HealthCheckResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*HealthCheckResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *HealthCheckResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_service_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use HealthCheckResponse.ProtoReflect.Descriptor instead.
func (*HealthCheckResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_service_proto_rawDescGZIP(), []int{5}
}</span>

func (x *HealthCheckResponse) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Domain Models
type Challenge struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        ChallengeId string  `protobuf:"bytes,1,opt,name=challenge_id,json=challengeId,proto3" json:"challenge_id,omitempty"`
        Name        string  `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        Description string  `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
        Goals       []*Goal `protobuf:"bytes,4,rep,name=goals,proto3" json:"goals,omitempty"`
}

func (x *Challenge) Reset() <span class="cov0" title="0">{
        *x = Challenge{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_service_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Challenge) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Challenge) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Challenge) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_service_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Challenge.ProtoReflect.Descriptor instead.
func (*Challenge) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_service_proto_rawDescGZIP(), []int{6}
}</span>

func (x *Challenge) GetChallengeId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ChallengeId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Challenge) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Challenge) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Challenge) GetGoals() []*Goal <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Goals
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Goal struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        GoalId        string       `protobuf:"bytes,1,opt,name=goal_id,json=goalId,proto3" json:"goal_id,omitempty"`
        Name          string       `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        Description   string       `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
        Requirement   *Requirement `protobuf:"bytes,4,opt,name=requirement,proto3" json:"requirement,omitempty"`
        Reward        *Reward      `protobuf:"bytes,5,opt,name=reward,proto3" json:"reward,omitempty"`
        Prerequisites []string     `protobuf:"bytes,6,rep,name=prerequisites,proto3" json:"prerequisites,omitempty"`
        Progress      int32        `protobuf:"varint,7,opt,name=progress,proto3" json:"progress,omitempty"`
        Status        string       `protobuf:"bytes,8,opt,name=status,proto3" json:"status,omitempty"`
        Locked        bool         `protobuf:"varint,9,opt,name=locked,proto3" json:"locked,omitempty"`
        CompletedAt   string       `protobuf:"bytes,10,opt,name=completed_at,json=completedAt,proto3" json:"completed_at,omitempty"`
        ClaimedAt     string       `protobuf:"bytes,11,opt,name=claimed_at,json=claimedAt,proto3" json:"claimed_at,omitempty"`
}

func (x *Goal) Reset() <span class="cov0" title="0">{
        *x = Goal{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_service_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Goal) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Goal) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Goal) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_service_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Goal.ProtoReflect.Descriptor instead.
func (*Goal) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_service_proto_rawDescGZIP(), []int{7}
}</span>

func (x *Goal) GetGoalId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.GoalId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Goal) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Goal) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Goal) GetRequirement() *Requirement <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Requirement
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Goal) GetReward() *Reward <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Reward
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Goal) GetPrerequisites() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Prerequisites
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Goal) GetProgress() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Progress
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Goal) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Goal) GetLocked() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Locked
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Goal) GetCompletedAt() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CompletedAt
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Goal) GetClaimedAt() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ClaimedAt
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Requirement struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        StatCode    string `protobuf:"bytes,1,opt,name=stat_code,json=statCode,proto3" json:"stat_code,omitempty"`
        Operator    string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
        TargetValue int32  `protobuf:"varint,3,opt,name=target_value,json=targetValue,proto3" json:"target_value,omitempty"`
}

func (x *Requirement) Reset() <span class="cov0" title="0">{
        *x = Requirement{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_service_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Requirement) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Requirement) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Requirement) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_service_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Requirement.ProtoReflect.Descriptor instead.
func (*Requirement) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_service_proto_rawDescGZIP(), []int{8}
}</span>

func (x *Requirement) GetStatCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.StatCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Requirement) GetOperator() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Operator
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Requirement) GetTargetValue() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TargetValue
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type Reward struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Type     string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
        RewardId string `protobuf:"bytes,2,opt,name=reward_id,json=rewardId,proto3" json:"reward_id,omitempty"`
        Quantity int32  `protobuf:"varint,3,opt,name=quantity,proto3" json:"quantity,omitempty"`
}

func (x *Reward) Reset() <span class="cov0" title="0">{
        *x = Reward{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_service_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Reward) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Reward) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Reward) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_service_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Reward.ProtoReflect.Descriptor instead.
func (*Reward) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_service_proto_rawDescGZIP(), []int{9}
}</span>

func (x *Reward) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Reward) GetRewardId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RewardId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Reward) GetQuantity() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Quantity
        }</span>
        <span class="cov0" title="0">return 0</span>
}

var File_service_proto protoreflect.FileDescriptor

var file_service_proto_rawDesc = []byte{
        0x0a, 0x0d, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
        0x07, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x1a, 0x1c, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
        0x2f, 0x61, 0x70, 0x69, 0x2f, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x2d, 0x67,
        0x65, 0x6e, 0x2d, 0x6f, 0x70, 0x65, 0x6e, 0x61, 0x70, 0x69, 0x76, 0x32, 0x2f, 0x6f, 0x70, 0x74,
        0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x10, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69,
        0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x16, 0x0a, 0x14, 0x47, 0x65, 0x74, 0x43,
        0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x22, 0x4b, 0x0a, 0x15, 0x47, 0x65, 0x74, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65,
        0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x32, 0x0a, 0x0a, 0x63, 0x68, 0x61,
        0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e,
        0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67,
        0x65, 0x52, 0x0a, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73, 0x22, 0x50, 0x0a,
        0x12, 0x43, 0x6c, 0x61, 0x69, 0x6d, 0x52, 0x65, 0x77, 0x61, 0x72, 0x64, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x12, 0x21, 0x0a, 0x0c, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65,
        0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x63, 0x68, 0x61, 0x6c, 0x6c,
        0x65, 0x6e, 0x67, 0x65, 0x49, 0x64, 0x12, 0x17, 0x0a, 0x07, 0x67, 0x6f, 0x61, 0x6c, 0x5f, 0x69,
        0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x67, 0x6f, 0x61, 0x6c, 0x49, 0x64, 0x22,
        0x8e, 0x01, 0x0a, 0x13, 0x43, 0x6c, 0x61, 0x69, 0x6d, 0x52, 0x65, 0x77, 0x61, 0x72, 0x64, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x17, 0x0a, 0x07, 0x67, 0x6f, 0x61, 0x6c, 0x5f,
        0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x67, 0x6f, 0x61, 0x6c, 0x49, 0x64,
        0x12, 0x16, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x27, 0x0a, 0x06, 0x72, 0x65, 0x77, 0x61,
        0x72, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
        0x63, 0x65, 0x2e, 0x52, 0x65, 0x77, 0x61, 0x72, 0x64, 0x52, 0x06, 0x72, 0x65, 0x77, 0x61, 0x72,
        0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x6c, 0x61, 0x69, 0x6d, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18,
        0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x63, 0x6c, 0x61, 0x69, 0x6d, 0x65, 0x64, 0x41, 0x74,
        0x22, 0x14, 0x0a, 0x12, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x2d, 0x0a, 0x13, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68,
        0x43, 0x68, 0x65, 0x63, 0x6b, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x16, 0x0a,
        0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73,
        0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x89, 0x01, 0x0a, 0x09, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65,
        0x6e, 0x67, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65,
        0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x63, 0x68, 0x61, 0x6c, 0x6c,
        0x65, 0x6e, 0x67, 0x65, 0x49, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65,
        0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x23, 0x0a, 0x05,
        0x67, 0x6f, 0x61, 0x6c, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x73, 0x65,
        0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x47, 0x6f, 0x61, 0x6c, 0x52, 0x05, 0x67, 0x6f, 0x61, 0x6c,
        0x73, 0x22, 0xea, 0x02, 0x0a, 0x04, 0x47, 0x6f, 0x61, 0x6c, 0x12, 0x17, 0x0a, 0x07, 0x67, 0x6f,
        0x61, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x67, 0x6f, 0x61,
        0x6c, 0x49, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72,
        0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65,
        0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x36, 0x0a, 0x0b, 0x72, 0x65, 0x71,
        0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14,
        0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65,
        0x6d, 0x65, 0x6e, 0x74, 0x52, 0x0b, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e,
        0x74, 0x12, 0x27, 0x0a, 0x06, 0x72, 0x65, 0x77, 0x61, 0x72, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x0f, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x52, 0x65, 0x77, 0x61,
        0x72, 0x64, 0x52, 0x06, 0x72, 0x65, 0x77, 0x61, 0x72, 0x64, 0x12, 0x24, 0x0a, 0x0d, 0x70, 0x72,
        0x65, 0x72, 0x65, 0x71, 0x75, 0x69, 0x73, 0x69, 0x74, 0x65, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28,
        0x09, 0x52, 0x0d, 0x70, 0x72, 0x65, 0x72, 0x65, 0x71, 0x75, 0x69, 0x73, 0x69, 0x74, 0x65, 0x73,
        0x12, 0x1a, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x65, 0x73, 0x73, 0x18, 0x07, 0x20, 0x01,
        0x28, 0x05, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x65, 0x73, 0x73, 0x12, 0x16, 0x0a, 0x06,
        0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x74,
        0x61, 0x74, 0x75, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64, 0x18, 0x09,
        0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64, 0x12, 0x21, 0x0a, 0x0c,
        0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x0a, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x0b, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12,
        0x1d, 0x0a, 0x0a, 0x63, 0x6c, 0x61, 0x69, 0x6d, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x0b, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x09, 0x63, 0x6c, 0x61, 0x69, 0x6d, 0x65, 0x64, 0x41, 0x74, 0x22, 0x69,
        0x0a, 0x0b, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x1b, 0x0a,
        0x09, 0x73, 0x74, 0x61, 0x74, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x08, 0x73, 0x74, 0x61, 0x74, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x6f, 0x70,
        0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6f, 0x70,
        0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x12, 0x21, 0x0a, 0x0c, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74,
        0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0b, 0x74, 0x61,
        0x72, 0x67, 0x65, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x55, 0x0a, 0x06, 0x52, 0x65, 0x77,
        0x61, 0x72, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x72, 0x65, 0x77, 0x61, 0x72,
        0x64, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x72, 0x65, 0x77, 0x61,
        0x72, 0x64, 0x49, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79,
        0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x08, 0x71, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79,
        0x32, 0xef, 0x04, 0x0a, 0x07, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0xe7, 0x01, 0x0a,
        0x11, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67,
        0x65, 0x73, 0x12, 0x1d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x47, 0x65, 0x74,
        0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x1a, 0x1e, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x47, 0x65, 0x74, 0x43,
        0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x22, 0x92, 0x01, 0x92, 0x41, 0x79, 0x0a, 0x0a, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e,
        0x67, 0x65, 0x73, 0x12, 0x13, 0x47, 0x65, 0x74, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x63, 0x68,
        0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73, 0x1a, 0x48, 0x52, 0x65, 0x74, 0x72, 0x69, 0x65,
        0x76, 0x65, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65,
        0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e,
        0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x77, 0x69, 0x74,
        0x68, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x65,
        0x73, 0x73, 0x62, 0x0c, 0x0a, 0x0a, 0x0a, 0x06, 0x42, 0x65, 0x61, 0x72, 0x65, 0x72, 0x12, 0x00,
        0x82, 0xd3, 0xe4, 0x93, 0x02, 0x10, 0x12, 0x0e, 0x2f, 0x76, 0x31, 0x2f, 0x63, 0x68, 0x61, 0x6c,
        0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73, 0x12, 0xe0, 0x01, 0x0a, 0x0f, 0x43, 0x6c, 0x61, 0x69, 0x6d,
        0x47, 0x6f, 0x61, 0x6c, 0x52, 0x65, 0x77, 0x61, 0x72, 0x64, 0x12, 0x1b, 0x2e, 0x73, 0x65, 0x72,
        0x76, 0x69, 0x63, 0x65, 0x2e, 0x43, 0x6c, 0x61, 0x69, 0x6d, 0x52, 0x65, 0x77, 0x61, 0x72, 0x64,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
        0x65, 0x2e, 0x43, 0x6c, 0x61, 0x69, 0x6d, 0x52, 0x65, 0x77, 0x61, 0x72, 0x64, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x91, 0x01, 0x92, 0x41, 0x50, 0x0a, 0x0a, 0x43, 0x68, 0x61,
        0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73, 0x12, 0x11, 0x43, 0x6c, 0x61, 0x69, 0x6d, 0x20, 0x67,
        0x6f, 0x61, 0x6c, 0x20, 0x72, 0x65, 0x77, 0x61, 0x72, 0x64, 0x1a, 0x21, 0x43, 0x6c, 0x61, 0x69,
        0x6d, 0x20, 0x72, 0x65, 0x77, 0x61, 0x72, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x20, 0x63,
        0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x20, 0x67, 0x6f, 0x61, 0x6c, 0x62, 0x0c, 0x0a,
        0x0a, 0x0a, 0x06, 0x42, 0x65, 0x61, 0x72, 0x65, 0x72, 0x12, 0x00, 0x82, 0xd3, 0xe4, 0x93, 0x02,
        0x38, 0x3a, 0x01, 0x2a, 0x22, 0x33, 0x2f, 0x76, 0x31, 0x2f, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65,
        0x6e, 0x67, 0x65, 0x73, 0x2f, 0x7b, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x5f,
        0x69, 0x64, 0x7d, 0x2f, 0x67, 0x6f, 0x61, 0x6c, 0x73, 0x2f, 0x7b, 0x67, 0x6f, 0x61, 0x6c, 0x5f,
        0x69, 0x64, 0x7d, 0x2f, 0x63, 0x6c, 0x61, 0x69, 0x6d, 0x12, 0x96, 0x01, 0x0a, 0x0b, 0x48, 0x65,
        0x61, 0x6c, 0x74, 0x68, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x12, 0x1b, 0x2e, 0x73, 0x65, 0x72, 0x76,
        0x69, 0x63, 0x65, 0x2e, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1c, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
        0x2e, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x22, 0x4c, 0x92, 0x41, 0x39, 0x0a, 0x06, 0x48, 0x65, 0x61, 0x6c, 0x74,
        0x68, 0x12, 0x0c, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x1a,
        0x21, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x61,
        0x6e, 0x64, 0x20, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x20, 0x68, 0x65, 0x61, 0x6c,
        0x74, 0x68, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x0a, 0x12, 0x08, 0x2f, 0x68, 0x65, 0x61, 0x6c, 0x74,
        0x68, 0x7a, 0x42, 0x97, 0x02, 0x92, 0x41, 0x9f, 0x01, 0x12, 0x70, 0x0a, 0x1f, 0x41, 0x63, 0x63,
        0x65, 0x6c, 0x42, 0x79, 0x74, 0x65, 0x20, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65,
        0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x41, 0x50, 0x49, 0x12, 0x48, 0x43, 0x68,
        0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20,
        0x66, 0x6f, 0x72, 0x20, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x69, 0x6e, 0x67, 0x20, 0x75, 0x73, 0x65,
        0x72, 0x20, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x20, 0x70, 0x72, 0x6f, 0x67,
        0x72, 0x65, 0x73, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x72, 0x65, 0x77, 0x61, 0x72, 0x64, 0x20,
        0x63, 0x6c, 0x61, 0x69, 0x6d, 0x73, 0x32, 0x03, 0x31, 0x2e, 0x30, 0x22, 0x0a, 0x2f, 0x63, 0x68,
        0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x5a, 0x1f, 0x0a, 0x1d, 0x0a, 0x06, 0x42, 0x65, 0x61,
        0x72, 0x65, 0x72, 0x12, 0x13, 0x08, 0x02, 0x1a, 0x0d, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69,
        0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x02, 0x0a, 0x25, 0x6e, 0x65, 0x74, 0x2e, 0x61, 0x63,
        0x63, 0x65, 0x6c, 0x62, 0x79, 0x74, 0x65, 0x2e, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x64, 0x2e, 0x63,
        0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x50,
        0x01, 0x5a, 0x25, 0x61, 0x63, 0x63, 0x65, 0x6c, 0x62, 0x79, 0x74, 0x65, 0x2e, 0x6e, 0x65, 0x74,
        0x2f, 0x65, 0x78, 0x74, 0x65, 0x6e, 0x64, 0x2f, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67,
        0x65, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0xaa, 0x02, 0x21, 0x41, 0x63, 0x63, 0x65, 0x6c,
        0x42, 0x79, 0x74, 0x65, 0x2e, 0x45, 0x78, 0x74, 0x65, 0x6e, 0x64, 0x2e, 0x43, 0x68, 0x61, 0x6c,
        0x6c, 0x65, 0x6e, 0x67, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x62, 0x06, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_service_proto_rawDescOnce sync.Once
        file_service_proto_rawDescData = file_service_proto_rawDesc
)

func file_service_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_service_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_service_proto_rawDescData = protoimpl.X.CompressGZIP(file_service_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_service_proto_rawDescData</span>
}

var file_service_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_service_proto_goTypes = []interface{}{
        (*GetChallengesRequest)(nil),  // 0: service.GetChallengesRequest
        (*GetChallengesResponse)(nil), // 1: service.GetChallengesResponse
        (*ClaimRewardRequest)(nil),    // 2: service.ClaimRewardRequest
        (*ClaimRewardResponse)(nil),   // 3: service.ClaimRewardResponse
        (*HealthCheckRequest)(nil),    // 4: service.HealthCheckRequest
        (*HealthCheckResponse)(nil),   // 5: service.HealthCheckResponse
        (*Challenge)(nil),             // 6: service.Challenge
        (*Goal)(nil),                  // 7: service.Goal
        (*Requirement)(nil),           // 8: service.Requirement
        (*Reward)(nil),                // 9: service.Reward
}
var file_service_proto_depIdxs = []int32{
        6, // 0: service.GetChallengesResponse.challenges:type_name -&gt; service.Challenge
        9, // 1: service.ClaimRewardResponse.reward:type_name -&gt; service.Reward
        7, // 2: service.Challenge.goals:type_name -&gt; service.Goal
        8, // 3: service.Goal.requirement:type_name -&gt; service.Requirement
        9, // 4: service.Goal.reward:type_name -&gt; service.Reward
        0, // 5: service.Service.GetUserChallenges:input_type -&gt; service.GetChallengesRequest
        2, // 6: service.Service.ClaimGoalReward:input_type -&gt; service.ClaimRewardRequest
        4, // 7: service.Service.HealthCheck:input_type -&gt; service.HealthCheckRequest
        1, // 8: service.Service.GetUserChallenges:output_type -&gt; service.GetChallengesResponse
        3, // 9: service.Service.ClaimGoalReward:output_type -&gt; service.ClaimRewardResponse
        5, // 10: service.Service.HealthCheck:output_type -&gt; service.HealthCheckResponse
        8, // [8:11] is the sub-list for method output_type
        5, // [5:8] is the sub-list for method input_type
        5, // [5:5] is the sub-list for extension type_name
        5, // [5:5] is the sub-list for extension extendee
        0, // [0:5] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_service_proto_init() }</span>
func file_service_proto_init() <span class="cov0" title="0">{
        if File_service_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">file_permission_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_service_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetChallengesRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_service_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetChallengesResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_service_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ClaimRewardRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_service_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ClaimRewardResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_service_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*HealthCheckRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_service_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*HealthCheckResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_service_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Challenge); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_service_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Goal); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_service_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Requirement); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_service_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Reward); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_service_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   10,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_service_proto_goTypes,
                DependencyIndexes: file_service_proto_depIdxs,
                MessageInfos:      file_service_proto_msgTypes,
        }.Build()
        File_service_proto = out.File
        file_service_proto_rawDesc = nil
        file_service_proto_goTypes = nil
        file_service_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by protoc-gen-grpc-gateway. DO NOT EDIT.
// source: service.proto

/*
Package challengeservice is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package challengeservice

import (
        "context"
        "io"
        "net/http"

        "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
        "github.com/grpc-ecosystem/grpc-gateway/v2/utilities"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/grpclog"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/proto"
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = utilities.NewDoubleArray
var _ = metadata.Join

func request_Service_GetUserChallenges_0(ctx context.Context, marshaler runtime.Marshaler, client ServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq GetChallengesRequest
        var metadata runtime.ServerMetadata

        msg, err := client.GetUserChallenges(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err

}</span>

func local_request_Service_GetUserChallenges_0(ctx context.Context, marshaler runtime.Marshaler, server ServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq GetChallengesRequest
        var metadata runtime.ServerMetadata

        msg, err := server.GetUserChallenges(ctx, &amp;protoReq)
        return msg, metadata, err

}</span>

func request_Service_ClaimGoalReward_0(ctx context.Context, marshaler runtime.Marshaler, client ServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq ClaimRewardRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["challenge_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "challenge_id")
        }</span>

        <span class="cov0" title="0">protoReq.ChallengeId, err = runtime.String(val)
        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "challenge_id", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["goal_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "goal_id")
        }</span>

        <span class="cov0" title="0">protoReq.GoalId, err = runtime.String(val)
        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "goal_id", err)
        }</span>

        <span class="cov0" title="0">msg, err := client.ClaimGoalReward(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err</span>

}

func local_request_Service_ClaimGoalReward_0(ctx context.Context, marshaler runtime.Marshaler, server ServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq ClaimRewardRequest
        var metadata runtime.ServerMetadata

        newReader, berr := utilities.IOReaderFactory(req.Body)
        if berr != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
        }</span>
        <span class="cov0" title="0">if err := marshaler.NewDecoder(newReader()).Decode(&amp;protoReq); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
        }</span>

        <span class="cov0" title="0">var (
                val string
                ok  bool
                err error
                _   = err
        )

        val, ok = pathParams["challenge_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "challenge_id")
        }</span>

        <span class="cov0" title="0">protoReq.ChallengeId, err = runtime.String(val)
        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "challenge_id", err)
        }</span>

        <span class="cov0" title="0">val, ok = pathParams["goal_id"]
        if !ok </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "goal_id")
        }</span>

        <span class="cov0" title="0">protoReq.GoalId, err = runtime.String(val)
        if err != nil </span><span class="cov0" title="0">{
                return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "goal_id", err)
        }</span>

        <span class="cov0" title="0">msg, err := server.ClaimGoalReward(ctx, &amp;protoReq)
        return msg, metadata, err</span>

}

func request_Service_HealthCheck_0(ctx context.Context, marshaler runtime.Marshaler, client ServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq HealthCheckRequest
        var metadata runtime.ServerMetadata

        msg, err := client.HealthCheck(ctx, &amp;protoReq, grpc.Header(&amp;metadata.HeaderMD), grpc.Trailer(&amp;metadata.TrailerMD))
        return msg, metadata, err

}</span>

func local_request_Service_HealthCheck_0(ctx context.Context, marshaler runtime.Marshaler, server ServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) <span class="cov0" title="0">{
        var protoReq HealthCheckRequest
        var metadata runtime.ServerMetadata

        msg, err := server.HealthCheck(ctx, &amp;protoReq)
        return msg, metadata, err

}</span>

// RegisterServiceHandlerServer registers the http handlers for service Service to "mux".
// UnaryRPC     :call ServiceServer directly.
// StreamingRPC :currently unsupported pending https://github.com/grpc/grpc-go/issues/906.
// Note that using this registration option will cause many gRPC library features to stop working. Consider using RegisterServiceHandlerFromEndpoint instead.
func RegisterServiceHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ServiceServer) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_Service_GetUserChallenges_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/service.Service/GetUserChallenges", runtime.WithHTTPPathPattern("/v1/challenges"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Service_GetUserChallenges_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Service_GetUserChallenges_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("POST", pattern_Service_ClaimGoalReward_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/service.Service/ClaimGoalReward", runtime.WithHTTPPathPattern("/v1/challenges/{challenge_id}/goals/{goal_id}/claim"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Service_ClaimGoalReward_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Service_ClaimGoalReward_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Service_HealthCheck_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                var stream runtime.ServerTransportStream
                ctx = grpc.NewContextWithServerTransportStream(ctx, &amp;stream)
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/service.Service/HealthCheck", runtime.WithHTTPPathPattern("/healthz"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := local_request_Service_HealthCheck_0(annotatedContext, inboundMarshaler, server, req, pathParams)
                md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Service_HealthCheck_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

// RegisterServiceHandlerFromEndpoint is same as RegisterServiceHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterServiceHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) <span class="cov0" title="0">{
        conn, err := grpc.DialContext(ctx, endpoint, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        if cerr := conn.Close(); cerr != nil </span><span class="cov0" title="0">{
                                grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
                        }</span>
                }()
        }()

        <span class="cov0" title="0">return RegisterServiceHandler(ctx, mux, conn)</span>
}

// RegisterServiceHandler registers the http handlers for service Service to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterServiceHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error <span class="cov0" title="0">{
        return RegisterServiceHandlerClient(ctx, mux, NewServiceClient(conn))
}</span>

// RegisterServiceHandlerClient registers the http handlers for service Service
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "ServiceClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "ServiceClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "ServiceClient" to call the correct interceptors.
func RegisterServiceHandlerClient(ctx context.Context, mux *runtime.ServeMux, client ServiceClient) error <span class="cov0" title="0">{

        mux.Handle("GET", pattern_Service_GetUserChallenges_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/service.Service/GetUserChallenges", runtime.WithHTTPPathPattern("/v1/challenges"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Service_GetUserChallenges_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Service_GetUserChallenges_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("POST", pattern_Service_ClaimGoalReward_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/service.Service/ClaimGoalReward", runtime.WithHTTPPathPattern("/v1/challenges/{challenge_id}/goals/{goal_id}/claim"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Service_ClaimGoalReward_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Service_ClaimGoalReward_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">mux.Handle("GET", pattern_Service_HealthCheck_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithCancel(req.Context())
                defer cancel()
                inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
                var err error
                var annotatedContext context.Context
                annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/service.Service/HealthCheck", runtime.WithHTTPPathPattern("/healthz"))
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
                        return
                }</span>
                <span class="cov0" title="0">resp, md, err := request_Service_HealthCheck_0(annotatedContext, inboundMarshaler, client, req, pathParams)
                annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
                if err != nil </span><span class="cov0" title="0">{
                        runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
                        return
                }</span>

                <span class="cov0" title="0">forward_Service_HealthCheck_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)</span>

        })

        <span class="cov0" title="0">return nil</span>
}

var (
        pattern_Service_GetUserChallenges_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1}, []string{"v1", "challenges"}, ""))

        pattern_Service_ClaimGoalReward_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 1, 0, 4, 1, 5, 2, 2, 3, 1, 0, 4, 1, 5, 4, 2, 5}, []string{"v1", "challenges", "challenge_id", "goals", "goal_id", "claim"}, ""))

        pattern_Service_HealthCheck_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0}, []string{"healthz"}, ""))
)

var (
        forward_Service_GetUserChallenges_0 = runtime.ForwardResponseMessage

        forward_Service_ClaimGoalReward_0 = runtime.ForwardResponseMessage

        forward_Service_HealthCheck_0 = runtime.ForwardResponseMessage
)
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright (c) 2023 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.21.9
// source: service.proto

package challengeservice

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
        Service_GetUserChallenges_FullMethodName = "/service.Service/GetUserChallenges"
        Service_ClaimGoalReward_FullMethodName   = "/service.Service/ClaimGoalReward"
        Service_HealthCheck_FullMethodName       = "/service.Service/HealthCheck"
)

// ServiceClient is the client API for Service service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ServiceClient interface {
        // Get all challenges with user progress
        GetUserChallenges(ctx context.Context, in *GetChallengesRequest, opts ...grpc.CallOption) (*GetChallengesResponse, error)
        // Claim reward for completed goal
        ClaimGoalReward(ctx context.Context, in *ClaimRewardRequest, opts ...grpc.CallOption) (*ClaimRewardResponse, error)
        // Health check endpoint (Decision FQ5)
        HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type serviceClient struct {
        cc grpc.ClientConnInterface
}

func NewServiceClient(cc grpc.ClientConnInterface) ServiceClient <span class="cov0" title="0">{
        return &amp;serviceClient{cc}
}</span>

func (c *serviceClient) GetUserChallenges(ctx context.Context, in *GetChallengesRequest, opts ...grpc.CallOption) (*GetChallengesResponse, error) <span class="cov0" title="0">{
        out := new(GetChallengesResponse)
        err := c.cc.Invoke(ctx, Service_GetUserChallenges_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *serviceClient) ClaimGoalReward(ctx context.Context, in *ClaimRewardRequest, opts ...grpc.CallOption) (*ClaimRewardResponse, error) <span class="cov0" title="0">{
        out := new(ClaimRewardResponse)
        err := c.cc.Invoke(ctx, Service_ClaimGoalReward_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *serviceClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) <span class="cov0" title="0">{
        out := new(HealthCheckResponse)
        err := c.cc.Invoke(ctx, Service_HealthCheck_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// ServiceServer is the server API for Service service.
// All implementations must embed UnimplementedServiceServer
// for forward compatibility
type ServiceServer interface {
        // Get all challenges with user progress
        GetUserChallenges(context.Context, *GetChallengesRequest) (*GetChallengesResponse, error)
        // Claim reward for completed goal
        ClaimGoalReward(context.Context, *ClaimRewardRequest) (*ClaimRewardResponse, error)
        // Health check endpoint (Decision FQ5)
        HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
        mustEmbedUnimplementedServiceServer()
}

// UnimplementedServiceServer must be embedded to have forward compatible implementations.
type UnimplementedServiceServer struct {
}

func (UnimplementedServiceServer) GetUserChallenges(context.Context, *GetChallengesRequest) (*GetChallengesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUserChallenges not implemented")
}</span>
func (UnimplementedServiceServer) ClaimGoalReward(context.Context, *ClaimRewardRequest) (*ClaimRewardResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ClaimGoalReward not implemented")
}</span>
func (UnimplementedServiceServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}</span>
func (UnimplementedServiceServer) mustEmbedUnimplementedServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServiceServer will
// result in compilation errors.
type UnsafeServiceServer interface {
        mustEmbedUnimplementedServiceServer()
}

func RegisterServiceServer(s grpc.ServiceRegistrar, srv ServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;Service_ServiceDesc, srv)
}</span>

func _Service_GetUserChallenges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetChallengesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ServiceServer).GetUserChallenges(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Service_GetUserChallenges_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ServiceServer).GetUserChallenges(ctx, req.(*GetChallengesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Service_ClaimGoalReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ClaimRewardRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ServiceServer).ClaimGoalReward(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Service_ClaimGoalReward_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ServiceServer).ClaimGoalReward(ctx, req.(*ClaimRewardRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Service_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(HealthCheckRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ServiceServer).HealthCheck(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Service_HealthCheck_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ServiceServer).HealthCheck(ctx, req.(*HealthCheckRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Service_ServiceDesc is the grpc.ServiceDesc for Service service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Service_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "service.Service",
        HandlerType: (*ServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetUserChallenges",
                        Handler:    _Service_GetUserChallenges_Handler,
                },
                {
                        MethodName: "ClaimGoalReward",
                        Handler:    _Service_ClaimGoalReward_Handler,
                },
                {
                        MethodName: "HealthCheck",
                        Handler:    _Service_HealthCheck_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "service.proto",
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright (c) 2023-2025 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.

package response

import (
        "bytes"
        "fmt"

        "extend-challenge-service/pkg/cache"

        commonDomain "github.com/AccelByte/extend-challenge-common/pkg/domain"
)

// ChallengeResponseBuilder builds optimized challenge responses by combining
// pre-serialized static challenge data with user-specific progress data.
//
// This approach uses ZERO-COPY STRING INJECTION instead of unmarshal/marshal cycle.
// Performance: ~500-800s per challenge vs ~15ms for unmarshal+marshal (20-30x faster)
//
// Performance benefits:
//   - Eliminates 100% of JSON unmarshal overhead (was 9,025ms @ 200 RPS)
//   - Eliminates 100% of JSON re-marshal overhead (was 7,661ms @ 200 RPS)
//   - Total saved: ~16,686ms (56% of CPU)  ~100ms string ops (0.3% of CPU)
//   - Expected CPU reduction: ~55% overall
//   - Expected memory reduction: ~40% (no map[string]interface{} allocations)
//
// Thread-safety: Safe for concurrent use (cache uses RWMutex, string ops are read-only)
type ChallengeResponseBuilder struct {
        cache *cache.SerializedChallengeCache
}

// NewChallengeResponseBuilder creates a new response builder.
//
// Args:
//   - cache: Pre-serialization cache containing static challenge JSON
//
// Returns:
//   - *ChallengeResponseBuilder: Builder instance
func NewChallengeResponseBuilder(cache *cache.SerializedChallengeCache) *ChallengeResponseBuilder <span class="cov0" title="0">{
        return &amp;ChallengeResponseBuilder{
                cache: cache,
        }
}</span>

// BuildChallengesResponse builds the complete challenges response JSON by merging
// pre-serialized challenge data with user progress using string injection.
//
// Args:
//   - challengeIDs: List of challenge IDs to include in response
//   - userProgress: Map of goal ID -&gt; user progress data
//
// Returns:
//   - []byte: Complete challenges response JSON
//   - error: If any challenge is missing from cache or JSON operations fail
//
// Performance: This method is ~20-30x faster than unmarshal+marshal because:
//  1. Static challenge data is already in JSON format (no unmarshaling needed)
//  2. Progress fields are injected via string manipulation (no marshaling needed)
//  3. Zero reflection overhead (no map[string]interface{} operations)
//  4. Zero GC pressure from temporary allocations
//
// Algorithm:
//  1. Get pre-serialized JSON for each challenge
//  2. Inject user progress into each challenge using InjectProgressIntoChallenge
//  3. Concatenate all challenges into {"challenges": [...]} structure
//  4. Return final JSON bytes
func (b *ChallengeResponseBuilder) BuildChallengesResponse(
        challengeIDs []string,
        userProgress map[string]*commonDomain.UserGoalProgress,
) ([]byte, error) <span class="cov0" title="0">{
        if b.cache == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cache is nil")
        }</span>

        <span class="cov0" title="0">if len(challengeIDs) == 0 </span><span class="cov0" title="0">{
                // Empty response
                return []byte(`{"challenges":[]}`), nil
        }</span>

        // Build response with string concatenation
        // Typical size: 1 challenge = ~2KB, 5 challenges = ~10KB
        <span class="cov0" title="0">result := bytes.NewBuffer(make([]byte, 0, len(challengeIDs)*2048+100))

        // Start response
        result.WriteString(`{"challenges":[`)

        // Process each challenge
        for i, challengeID := range challengeIDs </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        result.WriteByte(',')
                }</span>

                // Get pre-serialized challenge JSON from cache
                <span class="cov0" title="0">staticJSON, ok := b.cache.GetChallengeJSON(challengeID)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("challenge %s not found in serialization cache", challengeID)
                }</span>

                // Inject user progress into challenge using string injection
                // This is the FAST operation - no unmarshal/marshal!
                <span class="cov0" title="0">challengeWithProgress, err := InjectProgressIntoChallenge(staticJSON, userProgress)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to inject progress into challenge %s: %w", challengeID, err)
                }</span>

                // Write injected challenge to result
                <span class="cov0" title="0">result.Write(challengeWithProgress)</span>
        }

        // End response
        <span class="cov0" title="0">result.WriteString(`]}`)

        return result.Bytes(), nil</span>
}

// BuildSingleChallenge builds a single challenge response by injecting user progress
// into pre-serialized challenge JSON using string injection.
//
// Args:
//   - challengeID: The challenge ID
//   - userProgress: Map of goal ID -&gt; user progress data
//
// Returns:
//   - []byte: Challenge JSON with user progress injected
//   - error: If challenge not found in cache or JSON operations fail
//
// Performance: ~500-800s vs ~15ms for unmarshal+marshal (20-30x faster)
//
// Algorithm:
//  1. Get pre-serialized challenge JSON from cache
//  2. Inject user progress using InjectProgressIntoChallenge (string manipulation)
//  3. Return modified JSON bytes
//
// Zero unmarshaling, zero marshaling - just string operations!
func (b *ChallengeResponseBuilder) BuildSingleChallenge(
        challengeID string,
        userProgress map[string]*commonDomain.UserGoalProgress,
) ([]byte, error) <span class="cov0" title="0">{
        // Get pre-serialized challenge JSON from cache
        staticJSON, ok := b.cache.GetChallengeJSON(challengeID)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("challenge %s not found in serialization cache", challengeID)
        }</span>

        // Inject user progress using string injection
        // This is FAST - no unmarshal/marshal cycle!
        <span class="cov0" title="0">challengeWithProgress, err := InjectProgressIntoChallenge(staticJSON, userProgress)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to inject progress: %w", err)
        }</span>

        <span class="cov0" title="0">return challengeWithProgress, nil</span>
}

// BuildGoalResponse builds a single goal response (useful for claim endpoints).
//
// Args:
//   - goalID: The goal ID
//   - userProgress: User progress data for this goal
//
// Returns:
//   - []byte: Goal JSON with user progress injected
//   - error: If goal not found in cache or JSON operations fail
//
// Performance: ~100-200s vs ~2-3ms for unmarshal+marshal (15-30x faster)
//
// Algorithm:
//  1. Get pre-serialized goal JSON from cache
//  2. Inject user progress using InjectProgressIntoGoal (string manipulation)
//  3. Return modified JSON bytes
func (b *ChallengeResponseBuilder) BuildGoalResponse(
        goalID string,
        userProgress *commonDomain.UserGoalProgress,
) ([]byte, error) <span class="cov0" title="0">{
        // Get pre-serialized goal JSON from cache
        staticJSON, ok := b.cache.GetGoalJSON(goalID)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("goal %s not found in serialization cache", goalID)
        }</span>

        // Inject user progress using string injection
        // This is FAST - no unmarshal/marshal!
        <span class="cov0" title="0">goalWithProgress := InjectProgressIntoGoal(staticJSON, userProgress)

        return goalWithProgress, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright (c) 2023-2025 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.

package response

import (
        "bytes"
        "fmt"
        "strconv"
        "time"

        commonDomain "github.com/AccelByte/extend-challenge-common/pkg/domain"
)

// InjectProgressIntoGoal injects user progress fields into a pre-serialized goal JSON.
//
// This uses zero-copy string manipulation instead of unmarshal/marshal cycle.
// Performance: ~100-200s vs ~2-3ms for unmarshal+marshal (15-30x faster)
//
// Input:  {"goal_id":"daily_login","name":"Login Daily",...}
// Output: {"goal_id":"daily_login","name":"Login Daily","progress":5,"status":"in_progress",...}
//
// Args:
//   - staticJSON: Pre-serialized goal JSON from cache
//   - progress: User progress data (nil for defaults)
//
// Returns:
//   - []byte: Goal JSON with progress fields injected
//
// Algorithm:
//  1. Find the last closing brace } in the JSON
//  2. Build progress fields as JSON string: ,"progress":5,"status":"in_progress"
//  3. Insert before the closing brace
//  4. Return modified bytes
//
// Safety:
//   - Validates JSON has closing brace
//   - Escapes string values to prevent injection
//   - Returns copy to avoid modifying cache
func InjectProgressIntoGoal(
        staticJSON []byte,
        progress *commonDomain.UserGoalProgress,
) []byte <span class="cov4" title="9">{
        // Find the closing brace of the goal object
        // We inject progress fields just before it
        closingBraceIdx := bytes.LastIndexByte(staticJSON, '}')
        if closingBraceIdx == -1 </span><span class="cov1" title="1">{
                // Invalid JSON - return as-is
                return staticJSON
        }</span>

        // Build progress fields
        <span class="cov4" title="8">var progressFields []byte
        if progress == nil </span><span class="cov2" title="2">{
                // No progress - use defaults
                progressFields = buildDefaultProgressFields()
        }</span> else<span class="cov4" title="6"> {
                progressFields = buildProgressFields(progress)
        }</span>

        // Allocate buffer for result (original + progress fields)
        // Typical: 200 bytes original + 100 bytes progress = 300 bytes
        <span class="cov4" title="8">result := make([]byte, 0, len(staticJSON)+len(progressFields)+10)

        // Build result: original[0:closingBrace] + progressFields + }
        result = append(result, staticJSON[:closingBraceIdx]...)
        result = append(result, progressFields...)
        result = append(result, '}')

        return result</span>
}

// buildDefaultProgressFields returns JSON fields for goals with no user progress.
func buildDefaultProgressFields() []byte <span class="cov2" title="2">{
        return []byte(`,"progress":0,"status":"not_started","completed_at":"","claimed_at":""`)
}</span>

// buildProgressFields builds JSON fields for a goal with user progress.
//
// Output format: ,"progress":5,"status":"in_progress","completed_at":"2025-01-15T10:30:00Z","claimed_at":""
//
// Args:
//   - progress: User progress data
//
// Returns:
//   - []byte: JSON fields string
func buildProgressFields(progress *commonDomain.UserGoalProgress) []byte <span class="cov4" title="6">{
        // Use bytes.Buffer for efficient string building
        // Average size: ~80-120 bytes
        buf := bytes.NewBuffer(make([]byte, 0, 120))

        // Inject progress (always present)
        buf.WriteString(`,"progress":`)
        buf.WriteString(strconv.FormatInt(int64(progress.Progress), 10))

        // Inject status (always present)
        buf.WriteString(`,"status":"`)
        buf.WriteString(escapeJSONString(string(progress.Status)))
        buf.WriteString(`"`)

        // Inject completed_at (if present)
        buf.WriteString(`,"completed_at":"`)
        if progress.CompletedAt != nil </span><span class="cov2" title="2">{
                buf.WriteString(progress.CompletedAt.Format(time.RFC3339))
        }</span>
        <span class="cov4" title="6">buf.WriteString(`"`)

        // Inject claimed_at (if present)
        buf.WriteString(`,"claimed_at":"`)
        if progress.ClaimedAt != nil </span><span class="cov1" title="1">{
                buf.WriteString(progress.ClaimedAt.Format(time.RFC3339))
        }</span>
        <span class="cov4" title="6">buf.WriteString(`"`)

        return buf.Bytes()</span>
}

// InjectProgressIntoChallenge injects user progress into multiple goals within a challenge JSON.
//
// Performance: ~500-800s for a challenge with 5 goals vs ~15ms for unmarshal+marshal (20-30x faster)
//
// Input:  {"challenge_id":"daily","goals":[{"goal_id":"g1",...},{"goal_id":"g2",...}]}
// Output: {"challenge_id":"daily","goals":[{"goal_id":"g1","progress":5,...},{"goal_id":"g2","progress":10,...}]}
//
// Args:
//   - staticJSON: Pre-serialized challenge JSON from cache
//   - userProgress: Map of goal ID -&gt; user progress data
//
// Returns:
//   - []byte: Challenge JSON with progress injected into all goals
//   - error: If JSON structure is invalid
//
// Algorithm:
//  1. Find "goals" array in JSON
//  2. For each goal in array:
//     a. Extract goal_id to find matching user progress
//     b. Inject progress fields before goal's closing brace
//  3. Return modified JSON
//
// Safety:
//   - Validates JSON structure
//   - Handles goals array correctly
//   - Returns copy to avoid modifying cache
func InjectProgressIntoChallenge(
        staticJSON []byte,
        userProgress map[string]*commonDomain.UserGoalProgress,
) ([]byte, error) <span class="cov2" title="3">{
        // Find "goals" field in JSON
        goalsIdx := bytes.Index(staticJSON, []byte(`"goals":`))
        if goalsIdx == -1 </span><span class="cov1" title="1">{
                // No goals field - return as-is
                return staticJSON, nil
        }</span>

        // Find the opening bracket [ of goals array
        <span class="cov2" title="2">arrayStartIdx := bytes.IndexByte(staticJSON[goalsIdx:], '[')
        if arrayStartIdx == -1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid goals structure: missing opening bracket")
        }</span>
        <span class="cov2" title="2">arrayStartIdx += goalsIdx

        // Find the closing bracket ] of goals array
        arrayEndIdx := findMatchingClosingBracket(staticJSON, arrayStartIdx)
        if arrayEndIdx == -1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid goals structure: missing closing bracket")
        }</span>

        // Build result buffer
        // Allocate: original + (5 goals * 100 bytes progress each) = original + 500 bytes
        <span class="cov2" title="2">result := bytes.NewBuffer(make([]byte, 0, len(staticJSON)+500))

        // Write everything before goals array
        result.Write(staticJSON[:arrayStartIdx+1])

        // Process each goal in the array
        goalsArrayJSON := staticJSON[arrayStartIdx+1 : arrayEndIdx]
        if err := processGoalsArray(result, goalsArrayJSON, userProgress); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to process goals array: %w", err)
        }</span>

        // Write goals array closing bracket and everything after
        <span class="cov2" title="2">result.Write(staticJSON[arrayEndIdx:])

        return result.Bytes(), nil</span>
}

// processGoalsArray processes each goal in the goals array and injects progress.
//
// Args:
//   - result: Buffer to write processed goals to
//   - goalsArrayJSON: JSON content between [ and ] of goals array
//   - userProgress: Map of goal ID -&gt; user progress
//
// Returns:
//   - error: If goal structure is invalid
func processGoalsArray(
        result *bytes.Buffer,
        goalsArrayJSON []byte,
        userProgress map[string]*commonDomain.UserGoalProgress,
) error <span class="cov2" title="2">{
        // Parse goals by properly tracking brace nesting depth
        // Goals can have nested objects (requirement, reward), so we need to match braces correctly
        goalStart := -1
        goalIndex := 0
        depth := 0
        inString := false
        escapeNext := false

        for i := 0; i &lt; len(goalsArrayJSON); i++ </span><span class="cov9" title="166">{
                c := goalsArrayJSON[i]

                // Handle escape sequences in strings
                if escapeNext </span><span class="cov0" title="0">{
                        escapeNext = false
                        continue</span>
                }
                <span class="cov9" title="166">if c == '\\' </span><span class="cov0" title="0">{
                        escapeNext = true
                        continue</span>
                }

                // Track whether we're inside a string
                <span class="cov9" title="166">if c == '"' </span><span class="cov7" title="36">{
                        inString = !inString
                        continue</span>
                }

                // Only process structural characters outside of strings
                <span class="cov9" title="130">if !inString </span><span class="cov6" title="30">{
                        if c == '{' </span><span class="cov3" title="4">{
                                if depth == 0 </span><span class="cov3" title="4">{
                                        // Start of a new goal object
                                        goalStart = i
                                }</span>
                                <span class="cov3" title="4">depth++</span>
                        } else<span class="cov6" title="26"> if c == '}' </span><span class="cov3" title="4">{
                                depth--
                                if depth == 0 &amp;&amp; goalStart != -1 </span><span class="cov3" title="4">{
                                        // Found end of a complete goal object
                                        goalJSON := goalsArrayJSON[goalStart : i+1]

                                        // Extract goal_id from this goal
                                        goalID, err := extractGoalID(goalJSON)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("failed to extract goal_id from goal %d: %w", goalIndex, err)
                                        }</span>

                                        // Get user progress for this goal
                                        <span class="cov3" title="4">progress := userProgress[goalID]

                                        // Inject progress into this goal
                                        processedGoal := InjectProgressIntoGoal(goalJSON, progress)

                                        // Write to result
                                        if goalIndex &gt; 0 </span><span class="cov2" title="2">{
                                                result.WriteByte(',')
                                        }</span>
                                        <span class="cov3" title="4">result.Write(processedGoal)

                                        goalIndex++
                                        goalStart = -1</span>
                                }
                        }
                }
        }

        <span class="cov2" title="2">return nil</span>
}

// extractGoalID extracts the goal_id value from a goal JSON object.
//
// Input:  {"goal_id":"daily_login","name":"Login",...}
// Output: "daily_login"
//
// Args:
//   - goalJSON: Goal JSON object
//
// Returns:
//   - string: Goal ID
//   - error: If goal_id field not found or invalid
func extractGoalID(goalJSON []byte) (string, error) <span class="cov4" title="8">{
        // Find "goal_id" field
        goalIDIdx := bytes.Index(goalJSON, []byte(`"goal_id"`))
        if goalIDIdx == -1 </span><span class="cov1" title="1">{
                return "", fmt.Errorf("goal_id field not found")
        }</span>

        // Find the colon after "goal_id"
        <span class="cov4" title="7">colonIdx := bytes.IndexByte(goalJSON[goalIDIdx:], ':')
        if colonIdx == -1 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid goal_id field: missing colon")
        }</span>
        <span class="cov4" title="7">colonIdx += goalIDIdx

        // Find the opening quote of the value
        valueStartIdx := bytes.IndexByte(goalJSON[colonIdx:], '"')
        if valueStartIdx == -1 </span><span class="cov1" title="1">{
                return "", fmt.Errorf("invalid goal_id field: missing opening quote")
        }</span>
        <span class="cov4" title="6">valueStartIdx += colonIdx + 1

        // Find the closing quote of the value
        valueEndIdx := bytes.IndexByte(goalJSON[valueStartIdx:], '"')
        if valueEndIdx == -1 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid goal_id field: missing closing quote")
        }</span>
        <span class="cov4" title="6">valueEndIdx += valueStartIdx

        return string(goalJSON[valueStartIdx:valueEndIdx]), nil</span>
}

// findMatchingClosingBracket finds the matching closing bracket ] for an opening bracket [.
//
// Args:
//   - json: JSON bytes
//   - openIdx: Index of opening bracket [
//
// Returns:
//   - int: Index of matching closing bracket ], or -1 if not found
func findMatchingClosingBracket(json []byte, openIdx int) int <span class="cov2" title="2">{
        depth := 1
        for i := openIdx + 1; i &lt; len(json); i++ </span><span class="cov10" title="168">{
                switch json[i] </span>{
                case '[':<span class="cov0" title="0">
                        depth++</span>
                case ']':<span class="cov2" title="2">
                        depth--
                        if depth == 0 </span><span class="cov2" title="2">{
                                return i
                        }</span>
                }
        }
        <span class="cov0" title="0">return -1</span>
}

// escapeJSONString escapes special characters in a string for JSON encoding.
//
// This prevents JSON injection attacks when inserting user data.
//
// Args:
//   - s: String to escape
//
// Returns:
//   - string: Escaped string safe for JSON
func escapeJSONString(s string) string <span class="cov5" title="12">{
        // For safety, we escape:
        // - Backslash: \ -&gt; \\
        // - Double quote: " -&gt; \"
        // - Control characters: \n, \r, \t
        //
        // Note: For production, consider using a proper JSON string escaper
        // or encoding/json's string encoding logic

        // Quick check: if string has no special chars, return as-is
        needsEscape := false
        for i := 0; i &lt; len(s); i++ </span><span class="cov9" title="135">{
                c := s[i]
                if c == '\\' || c == '"' || c == '\n' || c == '\r' || c == '\t' || c &lt; 0x20 </span><span class="cov3" title="5">{
                        needsEscape = true
                        break</span>
                }
        }

        <span class="cov5" title="12">if !needsEscape </span><span class="cov4" title="7">{
                return s
        }</span>

        // Escape special characters
        <span class="cov3" title="5">result := make([]byte, 0, len(s)*2)
        for i := 0; i &lt; len(s); i++ </span><span class="cov9" title="103">{
                c := s[i]
                switch c </span>{
                case '\\':<span class="cov1" title="1">
                        result = append(result, '\\', '\\')</span>
                case '"':<span class="cov2" title="2">
                        result = append(result, '\\', '"')</span>
                case '\n':<span class="cov1" title="1">
                        result = append(result, '\\', 'n')</span>
                case '\r':<span class="cov1" title="1">
                        result = append(result, '\\', 'r')</span>
                case '\t':<span class="cov1" title="1">
                        result = append(result, '\\', 't')</span>
                default:<span class="cov9" title="97">
                        if c &lt; 0x20 </span><span class="cov0" title="0">{
                                // Control character - escape as \uXXXX
                                result = append(result, []byte(fmt.Sprintf("\\u%04x", c))...)
                        }</span> else<span class="cov9" title="97"> {
                                result = append(result, c)
                        }</span>
                }
        }

        <span class="cov3" title="5">return string(result)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package service

import (
        "context"
        "fmt"
        "time"

        "extend-challenge-service/pkg/mapper"

        "github.com/AccelByte/extend-challenge-common/pkg/cache"
        "github.com/AccelByte/extend-challenge-common/pkg/client"
        "github.com/AccelByte/extend-challenge-common/pkg/domain"
        "github.com/AccelByte/extend-challenge-common/pkg/repository"

        "github.com/sirupsen/logrus"
)

// ClaimResult represents the result of a successful claim operation.
type ClaimResult struct {
        GoalID      string
        Status      string
        Reward      domain.Reward
        ClaimedAt   time.Time
        UserID      string
        ChallengeID string
}

// ClaimGoalReward handles the reward claim flow with transaction and row-level locking.
// This is the main entry point for the claim RPC handler.
//
// Flow (Decision Q3):
// 1. Start transaction with 10s timeout
// 2. Lock user progress row (SELECT ... FOR UPDATE)
// 3. Validate goal is completed and not claimed
// 4. Call AGS Platform Service (inside transaction with retry)
// 5. Mark as claimed in database
// 6. Commit transaction
//
// Error Handling:
// - Returns mapper.ErrGoalNotFound if goal doesn't exist in config
// - Returns mapper.ErrGoalNotCompleted if goal not completed
// - Returns mapper.ErrGoalAlreadyClaimed if already claimed
// - Returns mapper.ErrPrerequisitesNotMet if prerequisites not met
// - Returns mapper.ErrRewardGrantFailed if AGS call fails after retries
// - Returns mapper.ErrDatabaseError for database failures
func ClaimGoalReward(
        ctx context.Context,
        userID string,
        goalID string,
        challengeID string,
        namespace string,
        goalCache cache.GoalCache,
        repo repository.GoalRepository,
        rewardClient client.RewardClient,
) (*ClaimResult, error) <span class="cov10" title="26">{
        if userID == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("user ID cannot be empty")
        }</span>

        <span class="cov9" title="25">if goalID == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("goal ID cannot be empty")
        }</span>

        <span class="cov9" title="24">if challengeID == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("challenge ID cannot be empty")
        }</span>

        <span class="cov9" title="23">if namespace == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("namespace cannot be empty")
        }</span>

        <span class="cov9" title="22">if goalCache == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("goal cache cannot be nil")
        }</span>

        <span class="cov9" title="21">if repo == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("repository cannot be nil")
        }</span>

        <span class="cov9" title="20">if rewardClient == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("reward client cannot be nil")
        }</span>

        // Get goal from cache
        <span class="cov9" title="19">goal := goalCache.GetGoalByID(goalID)
        if goal == nil </span><span class="cov1" title="1">{
                return nil, &amp;mapper.GoalNotFoundError{
                        GoalID:      goalID,
                        ChallengeID: challengeID,
                }
        }</span>

        // Verify goal belongs to the specified challenge
        <span class="cov8" title="18">if goal.ChallengeID != challengeID </span><span class="cov1" title="1">{
                return nil, &amp;mapper.GoalNotFoundError{
                        GoalID:      goalID,
                        ChallengeID: challengeID,
                }
        }</span>

        // Start transaction with 10s timeout (Decision Q3, FQ1)
        <span class="cov8" title="17">txCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
        defer cancel()

        txRepo, err := repo.BeginTx(txCtx)
        if err != nil </span><span class="cov1" title="1">{
                logrus.WithFields(logrus.Fields{
                        "user_id":      userID,
                        "goal_id":      goalID,
                        "challenge_id": challengeID,
                        "error":        err,
                }).Error("Failed to start transaction")
                return nil, mapper.ErrDatabaseError
        }</span>

        // Ensure transaction is rolled back on error
        <span class="cov8" title="16">defer func() </span><span class="cov8" title="16">{
                if err != nil </span><span class="cov0" title="0">{
                        if rbErr := txRepo.Rollback(); rbErr != nil </span><span class="cov0" title="0">{
                                logrus.WithFields(logrus.Fields{
                                        "user_id":      userID,
                                        "goal_id":      goalID,
                                        "challenge_id": challengeID,
                                        "error":        rbErr,
                                }).Error("Failed to rollback transaction")
                        }</span>
                }
        }()

        // Lock user progress row (SELECT ... FOR UPDATE)
        <span class="cov8" title="16">progress, err := txRepo.GetProgressForUpdate(txCtx, userID, goalID)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "user_id":      userID,
                        "goal_id":      goalID,
                        "challenge_id": challengeID,
                        "error":        err,
                }).Error("Failed to lock progress row")
                return nil, mapper.ErrDatabaseError
        }</span>

        // Validate progress exists
        <span class="cov8" title="16">if progress == nil </span><span class="cov1" title="1">{
                return nil, &amp;mapper.GoalNotCompletedError{
                        GoalID: goalID,
                        Status: string(domain.GoalStatusNotStarted),
                }
        }</span>

        // Validate goal is completed
        <span class="cov8" title="15">if !progress.CanClaim() </span><span class="cov2" title="2">{
                if progress.IsClaimed() </span><span class="cov1" title="1">{
                        return nil, &amp;mapper.GoalAlreadyClaimedError{
                                GoalID:    goalID,
                                ClaimedAt: progress.ClaimedAt.UTC().Format(time.RFC3339),
                        }
                }</span>

                <span class="cov1" title="1">return nil, &amp;mapper.GoalNotCompletedError{
                        GoalID: goalID,
                        Status: string(progress.Status),
                }</span>
        }

        // Check prerequisites (Decision Q7)
        // Load all user progress for prerequisite checking
        <span class="cov8" title="13">allProgress, err := txRepo.GetUserProgress(txCtx, userID)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "user_id":      userID,
                        "goal_id":      goalID,
                        "challenge_id": challengeID,
                        "error":        err,
                }).Error("Failed to load user progress for prerequisite check")
                return nil, mapper.ErrDatabaseError
        }</span>

        // Build progress map and check prerequisites
        <span class="cov8" title="13">progressMap := buildProgressMap(allProgress)
        prereqChecker := NewPrerequisiteChecker(progressMap)

        if !prereqChecker.CheckAllPrerequisitesMet(goal) </span><span class="cov1" title="1">{
                missingPrereqs := prereqChecker.GetMissingPrerequisites(goal)
                return nil, &amp;mapper.PrerequisitesNotMetError{
                        GoalID:         goalID,
                        MissingGoalIDs: missingPrereqs,
                }
        }</span>

        // Grant reward via AGS Platform Service with retry (Decision Q3, FQ1)
        <span class="cov7" title="12">if err := grantRewardWithRetry(txCtx, namespace, userID, goal.Reward, rewardClient); err != nil </span><span class="cov6" title="8">{
                logrus.WithFields(logrus.Fields{
                        "user_id":      userID,
                        "goal_id":      goalID,
                        "challenge_id": challengeID,
                        "reward_type":  goal.Reward.Type,
                        "reward_id":    goal.Reward.RewardID,
                        "error":        err,
                }).Error("Failed to grant reward after retries")
                return nil, &amp;mapper.RewardGrantError{
                        GoalID: goalID,
                        Err:    err,
                }
        }</span>

        // Mark as claimed in database
        <span class="cov4" title="4">if err := txRepo.MarkAsClaimed(txCtx, userID, goalID); err != nil </span><span class="cov1" title="1">{
                logrus.WithFields(logrus.Fields{
                        "user_id":      userID,
                        "goal_id":      goalID,
                        "challenge_id": challengeID,
                        "error":        err,
                }).Error("Failed to mark goal as claimed")
                return nil, mapper.ErrDatabaseError
        }</span>

        // Commit transaction
        <span class="cov4" title="3">if err := txRepo.Commit(); err != nil </span><span class="cov1" title="1">{
                logrus.WithFields(logrus.Fields{
                        "user_id":      userID,
                        "goal_id":      goalID,
                        "challenge_id": challengeID,
                        "error":        err,
                }).Error("Failed to commit transaction")
                return nil, mapper.ErrDatabaseError
        }</span>

        <span class="cov2" title="2">logrus.WithFields(logrus.Fields{
                "user_id":      userID,
                "goal_id":      goalID,
                "challenge_id": challengeID,
                "reward_type":  goal.Reward.Type,
                "reward_id":    goal.Reward.RewardID,
        }).Info("Successfully claimed goal reward")

        // Return result
        return &amp;ClaimResult{
                GoalID:      goalID,
                Status:      string(domain.GoalStatusClaimed),
                Reward:      goal.Reward,
                ClaimedAt:   time.Now().UTC(),
                UserID:      userID,
                ChallengeID: challengeID,
        }, nil</span>
}

// grantRewardWithRetry calls AGS Platform Service with exponential backoff retry.
// Decision FQ1: 3 retries with 500ms base delay
//
// Error Classification:
// - Non-retryable errors (400, 404, 403, 401) fail immediately
// - Retryable errors (network, 502, 503) use exponential backoff
//
// Retry Schedule (for retryable errors):
// - Attempt 1: Immediate
// - Attempt 2: 500ms delay
// - Attempt 3: 1000ms delay
// - Attempt 4: 2000ms delay
//
// Total delays: ~3.5s + AGS call times (4-8s) = 7.5-11.5s (fits in 10s timeout)
func grantRewardWithRetry(
        ctx context.Context,
        namespace string,
        userID string,
        reward domain.Reward,
        rewardClient client.RewardClient,
) error <span class="cov7" title="12">{
        const (
                maxRetries  = 3
                baseDelay   = 500 * time.Millisecond
                maxDelay    = 2 * time.Second
                backoffRate = 2.0
        )

        var lastErr error
        delay := baseDelay

        for attempt := 0; attempt &lt;= maxRetries; attempt++ </span><span class="cov9" title="23">{
                // Add delay before retry (skip on first attempt)
                if attempt &gt; 0 </span><span class="cov7" title="11">{
                        select </span>{
                        case &lt;-time.After(delay):<span class="cov7" title="11"></span>
                                // Continue with retry
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return fmt.Errorf("context cancelled during retry: %w", ctx.Err())</span>
                        }

                        // Exponential backoff with max cap
                        <span class="cov7" title="11">delay = time.Duration(float64(delay) * backoffRate)
                        if delay &gt; maxDelay </span><span class="cov4" title="3">{
                                delay = maxDelay
                        }</span>
                }

                // Attempt to grant reward
                <span class="cov9" title="23">err := rewardClient.GrantReward(ctx, namespace, userID, reward)
                if err == nil </span><span class="cov4" title="4">{
                        // Success
                        if attempt &gt; 0 </span><span class="cov1" title="1">{
                                logrus.WithFields(logrus.Fields{
                                        "user_id":     userID,
                                        "reward_type": reward.Type,
                                        "reward_id":   reward.RewardID,
                                        "attempt":     attempt + 1,
                                }).Info("Reward granted successfully after retry")
                        }</span>
                        <span class="cov4" title="4">return nil</span>
                }

                <span class="cov9" title="19">lastErr = err

                // Check if error is retryable (Decision FQ1 enhancement)
                if !client.IsRetryableError(err) </span><span class="cov5" title="5">{
                        logrus.WithFields(logrus.Fields{
                                "user_id":     userID,
                                "reward_type": reward.Type,
                                "reward_id":   reward.RewardID,
                                "attempt":     attempt + 1,
                                "error":       err,
                        }).Error("Reward grant failed with non-retryable error")
                        return fmt.Errorf("reward grant failed (non-retryable): %w", err)
                }</span>

                // Log retry attempt for retryable errors
                <span class="cov8" title="14">if attempt &lt; maxRetries </span><span class="cov7" title="11">{
                        logrus.WithFields(logrus.Fields{
                                "user_id":     userID,
                                "reward_type": reward.Type,
                                "reward_id":   reward.RewardID,
                                "attempt":     attempt + 1,
                                "next_delay":  delay,
                                "error":       err,
                        }).Warn("Reward grant failed (retryable), retrying")
                }</span>
        }

        // All retries exhausted
        <span class="cov4" title="3">logrus.WithFields(logrus.Fields{
                "user_id":     userID,
                "reward_type": reward.Type,
                "reward_id":   reward.RewardID,
                "attempts":    maxRetries + 1,
                "error":       lastErr,
        }).Error("Reward grant failed after all retries")

        return fmt.Errorf("reward grant failed after %d retries: %w", maxRetries, lastErr)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package service

import (
        "github.com/AccelByte/extend-challenge-common/pkg/domain"
)

// PrerequisiteChecker checks if goal prerequisites are met using efficient per-request map optimization.
// This is NOT a persistent cache - it's a function-scoped helper for O(1) lookups.
//
// Performance improvement (Decision Q7, FQ4):
// - With map: 100 goals * 2 prereqs = 100 map lookups = O(100)
// - Without map: 100 goals * 2 prereqs * 50 progress records = 10,000 linear search comparisons = O(n)
// - Result: 100x performance improvement for typical workloads
type PrerequisiteChecker struct {
        // progressMap provides O(1) lookup of user progress by goal ID
        // Built from userProgress array once per request
        progressMap map[string]*domain.UserGoalProgress
}

// NewPrerequisiteChecker creates a new prerequisite checker with per-request map optimization.
// The map is built once from the userProgress array and discarded after the request completes.
func NewPrerequisiteChecker(userProgress map[string]*domain.UserGoalProgress) *PrerequisiteChecker <span class="cov10" title="36">{
        return &amp;PrerequisiteChecker{
                progressMap: userProgress,
        }
}</span>

// CheckGoalLocked determines if a goal is locked based on its prerequisites.
// A goal is locked if:
// 1. It has prerequisites AND
// 2. ANY of the prerequisites are not completed (status != 'completed' and status != 'claimed')
//
// Performance: O(p) where p is number of prerequisites (typically 1-3)
// Each prerequisite lookup is O(1) via map
func (pc *PrerequisiteChecker) CheckGoalLocked(goal *domain.Goal) bool <span class="cov9" title="27">{
        if goal == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        // No prerequisites = not locked
        <span class="cov9" title="26">if len(goal.Prerequisites) == 0 </span><span class="cov7" title="14">{
                return false
        }</span>

        // Check if all prerequisites are completed
        <span class="cov7" title="12">for _, prereqGoalID := range goal.Prerequisites </span><span class="cov8" title="17">{
                prereqProgress := pc.progressMap[prereqGoalID]

                // If prerequisite has no progress, it's not completed  goal is locked
                if prereqProgress == nil </span><span class="cov4" title="4">{
                        return true
                }</span>

                // If prerequisite is not completed or claimed  goal is locked
                <span class="cov7" title="13">if !prereqProgress.IsCompleted() </span><span class="cov3" title="3">{
                        return true
                }</span>
        }

        // All prerequisites are completed  goal is not locked
        <span class="cov5" title="5">return false</span>
}

// GetMissingPrerequisites returns the list of prerequisite goal IDs that are not completed.
// This is used for detailed error messages in the claim flow.
//
// Performance: O(p) where p is number of prerequisites
func (pc *PrerequisiteChecker) GetMissingPrerequisites(goal *domain.Goal) []string <span class="cov6" title="8">{
        if goal == nil || len(goal.Prerequisites) == 0 </span><span class="cov2" title="2">{
                return []string{}
        }</span>

        <span class="cov5" title="6">missing := make([]string, 0, len(goal.Prerequisites))

        for _, prereqGoalID := range goal.Prerequisites </span><span class="cov7" title="13">{
                prereqProgress := pc.progressMap[prereqGoalID]

                // Missing progress or not completed
                if prereqProgress == nil || !prereqProgress.IsCompleted() </span><span class="cov5" title="7">{
                        missing = append(missing, prereqGoalID)
                }</span>
        }

        <span class="cov5" title="6">return missing</span>
}

// CheckAllPrerequisitesMet returns true if all prerequisites are completed.
// This is the inverse of CheckGoalLocked and is used for validation in the claim flow.
//
// Performance: O(p) where p is number of prerequisites
func (pc *PrerequisiteChecker) CheckAllPrerequisitesMet(goal *domain.Goal) bool <span class="cov7" title="16">{
        return !pc.CheckGoalLocked(goal)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package service

import (
        "context"
        "fmt"

        "github.com/AccelByte/extend-challenge-common/pkg/cache"
        "github.com/AccelByte/extend-challenge-common/pkg/domain"
        "github.com/AccelByte/extend-challenge-common/pkg/repository"
)

// ChallengeWithProgress represents a challenge with user progress data.
// This is returned by progress query helpers to combine config and progress.
type ChallengeWithProgress struct {
        Challenge    *domain.Challenge
        UserProgress map[string]*domain.UserGoalProgress // Key: goal_id
}

// GetUserChallengesWithProgress retrieves all challenges with user progress.
// This helper function is used by the GetUserChallenges RPC handler.
//
// Steps:
// 1. Load all challenges from cache (O(1))
// 2. Load all user progress from repository (single DB query)
// 3. Build map of progress for efficient lookup
// 4. Return combined data
//
// Performance: ~10-20ms for 50 challenges with 200 goals
func GetUserChallengesWithProgress(
        ctx context.Context,
        userID string,
        namespace string,
        goalCache cache.GoalCache,
        repo repository.GoalRepository,
) ([]*ChallengeWithProgress, error) <span class="cov7" title="8">{
        if userID == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("user ID cannot be empty")
        }</span>

        <span class="cov6" title="7">if namespace == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("namespace cannot be empty")
        }</span>

        <span class="cov6" title="6">if goalCache == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("goal cache cannot be nil")
        }</span>

        <span class="cov5" title="5">if repo == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("repository cannot be nil")
        }</span>

        // Get all challenges from cache (O(1))
        <span class="cov5" title="4">challenges := goalCache.GetAllChallenges()
        if len(challenges) == 0 </span><span class="cov1" title="1">{
                // No challenges configured, return empty result
                return []*ChallengeWithProgress{}, nil
        }</span>

        // Load all user progress from DB (single query)
        <span class="cov4" title="3">allProgress, err := repo.GetUserProgress(ctx, userID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to load user progress: %w", err)
        }</span>

        // Build map for O(1) progress lookups
        <span class="cov3" title="2">progressMap := buildProgressMap(allProgress)

        // Combine challenges with progress
        result := make([]*ChallengeWithProgress, 0, len(challenges))
        for _, challenge := range challenges </span><span class="cov4" title="3">{
                result = append(result, &amp;ChallengeWithProgress{
                        Challenge:    challenge,
                        UserProgress: progressMap,
                })
        }</span>

        <span class="cov3" title="2">return result, nil</span>
}

// GetUserChallengeWithProgress retrieves a single challenge with user progress.
// This helper function is used by the GetUserChallenge RPC handler.
//
// Steps:
// 1. Load challenge from cache (O(1))
// 2. Load challenge-specific progress from repository (indexed query)
// 3. Build map of progress for efficient lookup
// 4. Return combined data
//
// Performance: ~5-10ms for 10 goals per challenge
func GetUserChallengeWithProgress(
        ctx context.Context,
        userID string,
        challengeID string,
        namespace string,
        goalCache cache.GoalCache,
        repo repository.GoalRepository,
) (*ChallengeWithProgress, error) <span class="cov7" title="9">{
        if userID == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("user ID cannot be empty")
        }</span>

        <span class="cov7" title="8">if challengeID == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("challenge ID cannot be empty")
        }</span>

        <span class="cov6" title="7">if namespace == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("namespace cannot be empty")
        }</span>

        <span class="cov6" title="6">if goalCache == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("goal cache cannot be nil")
        }</span>

        <span class="cov5" title="5">if repo == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("repository cannot be nil")
        }</span>

        // Get challenge from cache (O(1))
        <span class="cov5" title="4">challenge := goalCache.GetChallengeByChallengeID(challengeID)
        if challenge == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("challenge not found: %s", challengeID)
        }</span>

        // Load challenge-specific progress from DB (indexed query)
        <span class="cov4" title="3">challengeProgress, err := repo.GetChallengeProgress(ctx, userID, challengeID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to load challenge progress: %w", err)
        }</span>

        // Build map for O(1) progress lookups
        <span class="cov3" title="2">progressMap := buildProgressMap(challengeProgress)

        return &amp;ChallengeWithProgress{
                Challenge:    challenge,
                UserProgress: progressMap,
        }, nil</span>
}

// buildProgressMap creates a map from progress slice for O(1) lookups.
// This is a simple function-scoped helper, not a persistent cache.
//
// Example: For 100 progress records  O(100) to build map, then O(1) for each lookup
// Without map: Each lookup would be O(100) linear search  50 goals * 100 = 5,000 comparisons
func buildProgressMap(progress []*domain.UserGoalProgress) map[string]*domain.UserGoalProgress <span class="cov9" title="20">{
        progressMap := make(map[string]*domain.UserGoalProgress, len(progress))
        for _, p := range progress </span><span class="cov10" title="22">{
                progressMap[p.GoalID] = p
        }</span>
        <span class="cov9" title="20">return progressMap</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
